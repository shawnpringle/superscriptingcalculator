-- Euphoria Calculator release 0.3 for Windows 3.1,9x,NT,XP,Vista
-- Copyright by Shawn Pringle 2007-2015 under the GPL
-- Requires Euphoria 4.0
--
-- Use an editor that supports soft word wrapping for reading comments.  For example jEdit (word wrap:soft, column width:0)
--
--  TheGPL's gist is:
--
-- You may keep this software for your own use and you may even sell its distribution but you must leave credit to the author and if you modify it must remain under the same license

-- This code  has been modified since it was generated by Judith's IDE.  Therefore, there is no .prj file source code.
										     
-- Calculations are not done by this program.  Instead this program creates a mini-program and calls this program to get the result.
--
-- Thanks for downloading this software for testing or improvement.  I plan to credit each  modification in the source code with each contributor.  My aim is to create a calculator program that can show superscripts for powers and that willwork even with exponents that are themselves powers.   
--
-- CNTRL+T will run through test cases.  
-- 
-- If an expression you entered results in poor parsing or otherwise a bad result, you can save it by looking for expressi.rtf.  You can find it in in your user files directory or, on very old  Windows systems, in the directory containing this file.  Rename that file with the same expression or to some other name and it will become a test case.  Submit it to the EUForum.
-- Known bugs: 
--              The position indicator in the status bar is unmaintained and incorrect.
--
-- Limitations: No sequences allowed
--                         Making a superscript to a sequence doesn't parse as it should.  That's why curly braces are not available.
--              Exponents can not be powers
--                         To fix this you need towork with the RichEdit3 control.
--              Cannot use all of the EUPHORIA functions
--              Cannot include .e files

 
include Win32Lib.ew
include msgbox.e
without warning
include std/filesys.e
include std/os.e as os
include std/search.e as search
include std/filesys.e as fs
include std/types.e
include std/datetime.e
with type_check
--------------------------------------------------------------------------------
--  Window Window1
constant Window1 = createEx( Window, "Superscripting Calculator version 0.30 for Windows", 0, Default, Default, 600, 300, 0, 0 )
constant StatusBar5 = createEx( StatusBar, "", Window1, 0, 0, 0, 0, 0, 0 )
constant RichEdit3 = createEx( RichEdit, "", Window1, 16, 12, 568, 88, w32or_all({ES_NOHIDESEL}), 0 )
setIndex( RichEdit3,{1, length(getText(RichEdit3))} )
setFont( RichEdit3,{0,"Arial"},16,Normal)
setIndex( RichEdit3,length(getText(RichEdit3))+1 )
constant LTextOVR = createEx( LText, "INS", StatusBar5, 540, 3, 148, 19, 0, 0 )
constant LTextPosition = createEx( LText, "0", StatusBar5, 492, 3, 148, 19, 0, 0 )
constant LTextInstructions = createEx( LText, "Use \'UP\' and \'DOWN\' keys for power calculations", Window1, 10, 112, 368, 188, 0, 0 )
constant DebugInfo =  createEx( LText, "", StatusBar5, 5, 3, 460, 20, 0, 0 )
---------------------------------------------------------
--------------------------------------------------------------------------------
constant KEY_ENTER = 13, KEY_UP = 38, KEY_DOWN = 40




include joy.e as joy
include get.e
include std/pretty.e

constant operators = "(+-/*)"

type boolean( object o )
	return find(o,{0,1})
end type

if sequence(getenv("HOMEPATH")) then
	chdir(getenv("HOMEPATH"))
end if
delete_file("ex.err")

boolean debug
boolean cntrl_pressed
boolean overwrite_flag
boolean debug_exponent_parse
boolean debug_hsprint
boolean debug_remove_escape_strings, debug_execute
boolean debug_keyPress,debug_keyUpDown
integer cpos
cpos = 0
debug = 0
debug_exponent_parse = 0
debug_execute = 0
debug_hsprint = 0
debug_remove_escape_strings = 0
cntrl_pressed = 0
debug_keyPress = 0
debug_keyUpDown = 0
overwrite_flag = 0
constant debug_log = open(getenv("HOMEPATH") & "\\wcalc-debug.log", "a")

if debug_log = -1 then
	message_box("Could not open debug log", "Attention!", MB_OK)
	abort(0)
end if
constant TOK_COMMAND = "COM", TOK_BRACE = "BRACE", TOK_TEXT = "TXT", TOK_IGNORE = "IGNORE"



function scan(sequence text)
    sequence tokens = {}
    integer start = 1, pivot
    while start <= length(text) do
	pivot = start + 1
	switch text[start] do
	    case '{', '}' then
		tokens = append(tokens, {TOK_BRACE, text[start..start]})
	    case '\\' then
			pivot = pivot + 1
		while pivot <= length(text) and not find(text[pivot], " \\\t\n\r{}" & operators) do
		    pivot += 1
		end while
		tokens = append(tokens, {TOK_COMMAND, text[start..pivot-1]})
	   case ' ', '\r', '\n', '\t' then
		break
	   case '+','-','*','/','(',')' then
	       tokens = append(tokens, {TOK_TEXT, text[start..start]})
	   case else
	       while pivot <= length(text) and not find(text[pivot], "\\ \t\n\r{}+-*/()") do
		   pivot += 1
	       end while
	       tokens = append(tokens, {TOK_TEXT, text[start..pivot-1]})
	end switch
	start = pivot
    end while
    if equal(tokens[$],{0}) then
	tokens = chop(tokens)
    end if
    pretty_print(debug_log, "Scanned tokens:\n", {3})
    pretty_print(debug_log, tokens, {3})
    flush(debug_log)
    return tokens
end function

procedure display_tokens(sequence tokens)
    if not debug then
        return
    end if
    puts(1, "{\n")
    for i = 1 to length(tokens) do
      sequence t = tokens[i]
      printf(1, "<%s, %s>,\n", t)
   end for
   puts(1, "}\n")
end procedure

enum V_LVL, V_VAL, V_CLASS

enum VC_NUM, VC_OPERATOR

type value_entity(sequence s)
    if length(s) != 3 then
	return 0
    end if
    if not integer(s[V_LVL]) then
	return 0
    end if
    if not atom(s[V_VAL]) then
	return 0
    end if
    if not find(s[V_CLASS], {VC_NUM, VC_OPERATOR}) then
	return 0
    end if
    if s[V_CLASS] = VC_OPERATOR and not find(s[V_VAL], operators) then
    	return 0
    end if
    return 1
end type

type value_vector(sequence s)
    for i = 1 to length(s) do
	if not value_entity(s[i]) then
	    return 0
	end if
    end for
    return 1
end type

procedure display_value_vector(value_vector tokens)
    if debug = w32False then
        return
    end if
    puts(1, "{\n")
    for i = 1 to length(tokens) do
      value_entity t = tokens[i]
      if t[V_CLASS] = VC_NUM then
	printf(1, "<%d, %g, VC_NUM>,\n", t[1..2])
      else
	printf(1, "<%d, %s, VC_OPERATOR>,\n", t[1..2])
      end if
   end for
   puts(1, "}\n")
end procedure


type value_vector_with_all_0levels(value_vector v)
    for i = 1 to length(v) do
	if v[i][V_LVL] != 0 then
	    return FALSE
	end if
     end for
     return TRUE
end type

function parser(sequence tokens)
     value_vector values = {}
     object ve
     integer error
     ascii_string command = ""
     integer up = 0
     
     for i = 1 to length(tokens) do
	sequence t = tokens[i]
	 switch t[1] do
	     case TOK_COMMAND then
	     command = t[2]
	      if  begins("\\up", t[2]) then
		 {error, up} = value(t[2][4..$])
		 if error != GET_SUCCESS then
		     return {error, "Invalid number in up token"}
		 end if
	      elsif find(t[2], {"\\fcharset0", "\\generator", "\\fonttbl0", "\\fontcharset0", "\\colortbl"}) then
		 for j = i+1 to length(tokens)  do
		    if not equal(tokens[j][1], TOK_TEXT) then
			exit
		    end if
		    -- set to this so they get ignored
		    tokens[j][1] = TOK_IGNORE
		 end for
	      end if
	  case TOK_TEXT then
	      atom num
	      if length(t[2]) = 1 and find(t[2][1], operators) then
	        value_entity ve1 = {up, t[2][1], VC_OPERATOR}
		values = append(values, ve1)
	      elsif t_space(t[2]) or equal(t[2],{0}) then
		-- do nothing
	      else
		{error, num} = value(t[2])
		if error != GET_SUCCESS then
		    return {GET_FAIL, sprintf("Could not parse number \"%s\".  Last command was '%s'\n", {t[2], command})}
		end if
		ve = {up, num, VC_NUM}
		if not value_entity(ve) then
		    return {GET_FAIL, sprintf("Could not parse \"%s\" to a value", t[2..2])}
		end if
		values = append(values, ve)
	      end if
	  end switch
      end for
      puts(debug_log, "Parsed Values:\n")
      pretty_print(debug_log, values, {3})
      return {GET_SUCCESS, values}
end function

type true_value(object x)
    return equal(x,1)
end type

true_value truth

function execute(value_vector vals)
    -- first, the trival cases of 0 and one element:
    sequence region = {}
    if length(vals) < 1 then
	return {GET_FAIL, "Empty sequence cannot be evaluated"}
    elsif length(vals) = 1 then
	return {GET_SUCCESS, vals[1][2]}
    end if
    -- parentheses:
    
    display_value_vector(vals)
    integer r_pointer, l_pointer, vi
    value_entity r_v, l_v
    while l_pointer < r_pointer and equal(l_v[V_VAL..V_CLASS] & r_v[V_VAL..V_CLASS], 
	    {'(', VC_OPERATOR, ')', VC_OPERATOR} ) with entry do
	if l_v[V_LVL] != r_v[V_LVL] then
	    return {GET_FAIL, "Mismatched parenthesis: One in a base, the other in an exponent"}
	end if
	if l_pointer + 1 = r_pointer then
	    return {GET_FAIL, "Unsensible empty parenthesis"}
	end if
	sequence buf = vals[l_pointer+1..r_pointer-1]
	buf = execute(buf)
	if buf[1] != GET_SUCCESS then
	    return buf
	end if
	value_entity ve = {/*V_LVL*/vals[l_pointer+1][V_LVL], /* V_VAL*/buf[2], /*V_CLASS*/VC_NUM}
	vals = vals[1..l_pointer-1] & {ve} & vals[r_pointer+1..$]
        display_value_vector(vals)
    entry
	l_pointer = 0
	r_pointer = 0
	vi = 1
	while vi <= length(vals) do
	    if equal(vals[vi][V_VAL..V_CLASS], {'(', VC_OPERATOR}) then
	    	l_pointer = vi
	    elsif equal(vals[vi][V_VAL..V_CLASS], {')', VC_OPERATOR}) then
	    	r_pointer = vi
	    	if l_pointer then
	    	    exit
	    	end if
	    end if
	    vi = vi + 1
	end while
	if r_pointer = 0 xor l_pointer = 0 then
	    return {GET_FAIL, "Unbalanced parenthesis"}
	end if
	if r_pointer = 0 /* and l_pointer = 0 */ then
	    exit
	end if
	r_v = vals[r_pointer]
	l_v = vals[l_pointer]
    end while
    
    puts(debug_log, "After processing the ():\n")
    pretty_print(debug_log, vals, {3})    
    
    -- exponents
    integer exp_ends = -1 -- length(vals)
    integer exp_begs  = -1 -- length(vals)
    for i = length(vals) to 1 by -1 do
	if vals[i][V_LVL] > 0 then
	      exp_ends = i
	      exp_begs = i
	      for j = exp_ends to 1 by -1 do
		   if vals[i][V_LVL] = vals[j][V_LVL] then
		       exp_begs = j
		   else
		       exit
		   end if
	      end for
	      if exp_begs = 1 then
		  return {GET_FAIL, "Error exponent has no base in expression"}
	      end if
	      sequence buf
	      buf = vals[exp_begs..exp_ends] - repeat({/*V_LVL*/vals[exp_begs][V_LVL], /* V_VAL*/0, /*V_CLASS*/0}, exp_ends - exp_begs + 1)
	      buf = execute(buf)
	      if buf[1] != GET_SUCCESS then
		  return buf
	      end if
	      if vals[exp_begs-1][V_CLASS] != VC_NUM then
	          return {GET_FAIL, "Exponent base is not a number"}
	      end if
	      vals = vals[1..exp_begs-2] & {{vals[exp_begs-1][V_LVL], power(vals[exp_begs-1][V_VAL], buf[2]), VC_NUM}} 
		& vals[exp_ends+1..$]
	      if length(vals) = 1 then
		  return {GET_SUCCESS, vals[1][V_VAL]}
	      end if
	      return execute(vals)
	end if
    end for
    
    puts(debug_log, "After processing the exponents:\n")
    pretty_print(debug_log, vals, {3})
    display_value_vector(vals)
    
    integer k, m
    value_vector_with_all_0levels v_save = vals
    
    if length(vals) and vals[$][V_CLASS] = VC_OPERATOR then
        return {GET_FAIL, "Expressions must not end with an operator"}
    end if
    
    -- process the unary operators now.  This simplifies the other multiplicative ops
    k = 1
    integer sign = 1
    -- guarantee there is a binary operator left of every unary - or unary +
    vals = {{0, 1, VC_NUM}, {0, '*', VC_OPERATOR}} & vals
    while k <= length(vals)-2 do
	value_entity ve1 = vals[k]
	value_entity ve2 = vals[k+1]
	value_entity ve3 = vals[k+2]
	if ve1[V_CLASS] = VC_OPERATOR and ve2[V_CLASS] = VC_OPERATOR and ve3[V_CLASS] = VC_NUM then
	    m = k
	    sign = 1
	    switch ve2[V_VAL] do
	        case '+' then
	            sign = 1
		case '-' then
		    sign = -1
		case else
		    return {GET_FAIL, "Cannot evaluate " & ve2[V_VAL] & sprint(ve3[V_VAL]) & sprintf(": \'%s\' is  not a unary operator ", ve2[V_VAL])  }		    
	    end switch
	    ve3[V_VAL] = sign * ve3[V_VAL]
	    vals = vals[1..k] & {ve3} & vals[k+3..$]
	    -- we have made vals shorter.. don't increment k.  Instead decrement it if greater than one
	    if k > 1 then
	        k = k - 1
	    end if
	else
	    k = k + 1
	end if
    end while

    puts(debug_log, "After processing the unary ops:\n")
    pretty_print(debug_log, vals, {3})
    -- execute the "terms"
    atom product = 1
    boolean divide_op = FALSE
    boolean multiply_op = TRUE
    boolean add_op = FALSE
    boolean subtract_op = FALSE
    boolean post_operator = TRUE
    k = 1
    while k+2 <= length(vals) do
	doEvents(0)
	value_entity a = vals[k]
	value_entity op = vals[k+1]
	value_entity b = vals[k+2]
	
	if a[V_CLASS] = VC_NUM and op[V_CLASS] = VC_OPERATOR and
		b[V_CLASS] = VC_NUM and find(op[V_VAL],"/*") then
		atom c
		if op[V_VAL] = '*' then
		    c = a[V_VAL] * b[V_VAL]
		else
		    c = a[V_VAL]/b[V_VAL]
		end if
		
		vals = vals[1..k-1] & {{0, c, VC_NUM}} & vals[k+3..$]
	else
		k += 2
	end if
    end while
    
    puts(debug_log, "After processing the * / ops:\n")
    pretty_print(debug_log, vals, {3})    
    -- now finally to do the arithmetic operations
    loop do
	doEvents(0)
	switch length(vals) do
	    case 0,2 then
		return {GET_FAIL, "Could not reduce this expression"}
	    case 1 then
		exit
	end switch
	if vals[1][V_CLASS] = VC_NUM and vals[3][V_CLASS] = VC_NUM and vals[2][V_CLASS] = VC_OPERATOR then
		vals = {{0 /*V_LVL*/, vals[1][V_VAL] + power(-1, vals[2][V_VAL] = '-') * vals[3][V_VAL], VC_NUM}} & vals[4..$]
	end if
    until FALSE
    end loop
    
    puts(debug_log, "After processing the + - ops:\n")
    pretty_print(debug_log, vals, {3})
    flush(debug_log)
    if length(vals) = 1 then
	return {GET_SUCCESS, vals[1][V_VAL]}
    end if
    return {GET_FAIL, "Could not resolve to a single value" }
end function

-- Returns a string that can be displayed on one line
-- from an arbitrary sequence. [broken for now]
function hsprint( sequence s )
	boolean there_is_sequence
	integer nlloc,crloc

	s = remove_objects(s,"\n\r")
	if debug_remove_escape_strings then
		printf(1,"--before escape removal removal     s=\'%s\'\n",{s})
	end if
	--s = remove_escape_strings(s)
	if debug_remove_escape_strings then
		printf(1,"\n After escape string removal s=\'%s\'\n\n",{s})
	end if
	
	there_is_sequence = 0
	for i = 1 to length(s) do
		if sequence(s[i]) then
			there_is_sequence = 1
		end if
	end for
	if there_is_sequence then
		return sprint( s )
	else
		return s
	end if  
end function


function calculate(sequence richText)
	sequence ts = scan( richText )
	sequence vs
	object answer
	integer error
	{error, vs} = parser( ts )
	if error != GET_SUCCESS then
	    return {error,vs}
	end if
	{error, answer} = execute(vs)
	flush(debug_log)
	if error != GET_SUCCESS then
	    return {error,answer}
	end if
	answer = sprint(answer)
	integer e_loc = joy:rfind('e', answer)
	if e_loc > 0 then
	    --should the number have an 'e' in it, convert this to real power of ten notation
	    ascii_string exponent = answer[e_loc+1..$]
	    sequence buffer = value(exponent) -- get rid of extraneous + signs or zeroes.
	    exponent = sprint(buffer[2])
	    answer = answer[1..e_loc-1] & `*10 \up16\fs16 ` & exponent
	end if
	richText = `{\rtf1\ansi\ansicpg1252\deff0\deflang3082{\fonttbl{\f0\fnil\fcharset0 Arial;}}

{\colortbl ;\red0\green0\blue0;}

{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\cf1\lang1033\fs32 ` &
answer & `\par

 }`
	return {GET_SUCCESS, richText}
end function

procedure test_runs()
	sequence testsdir
	object rtfs
	sequence buffer
	sequence eText
	integer rtffd
	object line
	line = command_line()
	testsdir = fs:dirname(line[2]) & SLASH & "tests" & SLASH
	rtfs = dir(testsdir & "*.rtf")
	if atom(rtfs) then
	    setText( DebugInfo, "This software was badly installed : tests directory is missing!")
	    return
	end if
	for i = 1 to length(rtfs) do
		if compare( rtfs[i][D_NAME], "expressi.rtf" ) = 0 then
			rtfs = rtfs[1..i-1] & rtfs[i+1..length(rtfs)]
			exit
		end if
	end for
	for i = 1 to length(rtfs) do
		rtffd = open( testsdir & rtfs[i][D_NAME], "r" )
		if rtffd = -1 then
			setText( DebugInfo, sprintf("Unable to open %s", rtfs[i][D_NAME]) )
			doEvents( 0 )
			os:sleep(2)
		end if
		buffer = ""
		line = ""
		while sequence(line) do
			buffer &= chop(line)
			line = gets(rtffd)
		end while
		close( rtffd )
		eText = buffer
		putStream( RichEdit3, StreamRTF, buffer )
		doEvents( 0 )
		os:sleep(2)
		doEvents( 0 )
		buffer = calculate(buffer)
		doEvents( 0 )
		if buffer[1] != GET_SUCCESS
		 then
		    if atom(line) then
			setText( DebugInfo, sprintf( "%s = %d", { eText, line } ) )
			putStream( RichEdit3, StreamText, sprintf("%d",line) )
		    else
			setText( DebugInfo, sprintf( "%s = %s", { eText, line } ) )
			putStream( RichEdit3, StreamText, line )
		    end if
		end if
		setIndex( RichEdit3, {1, 0} )
		doEvents( 0 )           
		os:sleep(1)
		putStream( RichEdit3, StreamRTF, buffer[2])
		os:sleep(2)
		doEvents(0)
	end for
end procedure


--------------------------------------------------------------------------------
procedure RichEdit3_onKeyDown (integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
	integer cfd, mb, cnt, richout
	sequence parsed_calculation, richText
	sequence cl = command_line()
	ascii_string eText
	sequence parsed_answer
	sequence tempexecfn, tempfilefn
	integer shellexec_return_value
	object return_value
	if debug then
		
	end if
	
	sequence wcalcinfo = pathinfo(cl[2])
	-- Get the rich text from the control.                                                     
	richText = getStream( RichEdit3, StreamRTF)
	sequence richpath = "expressi.rtf"

	if params[2] = ControlMask and params[1] = KEY_ENTER then
		richout = open( sprintf("%s\\tests\\example-%d.rtf", {wcalcinfo[1], to_unix(now())}), "w" )
	else
		richout = open( "NUL", "w" )
	end if
	if richout = -1 then
		setText( DebugInfo, sprintf("Cannot open temporary file %s.", {richpath}) )
	else
		printf(richout, "%s", { richText } )
		close( richout )
	end if
	setText( DebugInfo, "" )

	if params[1] = KEY_ENTER then                  
		-- here parse the ^() into power
		integer error
		{error, richText} = calculate( richText )
		if error != GET_SUCCESS then
		    eText = richText
		    setText( DebugInfo, eText )
		    returnValue(-1)
		    return
		else
		    putStream( RichEdit3, StreamRTF, richText )
		    returnValue(-1)
		end if
	end if
	
	if compare( params, { KEY_UP, 0 } ) = 0 then -- up is pressed
			setTextAlign( self, AlignTop )
			setFont( self, "Arial", 8, Bold+Italic+Superscript )
			if debug then
				setText(DebugInfo, "font exponent set" )
			end if
			cpos += 1
			returnValue(-1)
	elsif params[1] = KEY_DOWN  then        -- down is pressed
			setFont( self, "Arial", 16, Normal )
			setTextAlign( self, AlignBottom )
			if debug then
				
			end if
			cpos += 1
			returnValue(-1)
	elsif and_bits(ControlMask, params[2]) = ControlMask then
	    if params[1] = 'T' then
	        test_runs()
	    elsif params[1] = 'D' then
	        debug = not debug
	    end if
	end if


	if overwrite_flag then
		setText( LTextOVR, "OVR" )
	else
		setText( LTextOVR, "INS" )
	end if
	setText( LTextPosition, sprint( index_get(getSelection( RichEdit3 ),{1}) ) )
	
	if debug_keyUpDown then
		puts(1, "keyDown") ? params
	end if
	
end procedure
setHandler( RichEdit3, w32HKeyDown, routine_id("RichEdit3_onKeyDown"))
--------------------------------------------------------------------------------
procedure RichEdit3_onKeyPress (integer self, integer event, sequence params)--params is ( int keyCode, int shift )
	if debug_keyPress then
		puts(1, "KeyPress") ? params
	end if
	if params[1] = 13 then -- supress putting newlines in the RichText3 control
		returnValue(-1)
	elsif params[1] = 20 then
		test_runs()
	elsif not find(params[1],"0123456789." & operators) then
		returnValue(-1) -- only allow characters we like. ;)
		setText( DebugInfo, sprintf("Character %s isn't allowed", params[1]))
	end if
end procedure

setHandler( RichEdit3, w32HKeyPress, routine_id("RichEdit3_onKeyPress"))
--------------------------------------------------------------------------------
procedure RichEdit3_onKeyUp (integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
	if debug_keyUpDown then
		puts(1, "KeyUp" ) ? params
	end if

	if params[1] = 17 then
		cntrl_pressed = 0
	end if  
end procedure
setHandler( RichEdit3, w32HKeyUp, routine_id("RichEdit3_onKeyUp"))

WinMain( Window1,Normal )
