without warning
without trace
include std/dll.e
include std/machine.e
include std/error.e
include std/text.e
include std/wildcard.e
include std/rand.e
include std/sort.e
include std/sequence.e
include std/convert.e
include std/win32/msgbox.e

--/makedoc title Documentation for Win32lib v0.70.20

--/topic Constants
--/const Win32LibVersion
--/desc Contains the current version of win32lib library.
-- This is a sequence containing four elements. /n
--/li Major version number (integer)
--/li Minor version number (integer)
--/li Patch or /i Revision number (integer)
--/li Date of the version in DD-Mmm-YYYY format (string)
--
-- The indexes of these parts are known as Win32libVersionMajor, Win32libVersionMinor,
-- Win32libVersionPatch and Win32libVersionDate respectively.
--
--Example
--/code
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d, %s",
--                            Win32LibVersion))
--/endcode
global constant
    Win32LibVersion = {0,70,20, "13-Nov-2010"}   -- {Major, Minor, Patch, Date}
global constant
    Win32libVersionMajor = 1,
    Win32libVersionMinor = 2,
    Win32libVersionPatch = 3,
    Win32libVersionDate = 4

-- w32msgs.e

global constant
 False = 0,
 True  = not False

integer
    showWarnings            -- if false, suppresses warning messages
object
    xUserCleanUp            -- the user's "clean up" routine(s)

    xUserCleanUp = -1       -- defined by user
    showWarnings = True     -- display warning messages


sequence
     vMsgsToIgnore vMsgsToIgnore = {}

sequence vAppName,
         vVersion
vAppName = ""
vVersion = ""

------------------------------------------------
procedure fCleanUp(integer pErrCode, sequence pDispMsg)
------------------------------------------------
integer lRC, lNumUserIds
object lUserCleanUp

    -- user clean up
    if sequence(xUserCleanUp) then
        lUserCleanUp = xUserCleanUp
        xUserCleanUp = -1
        lNumUserIds = length(lUserCleanUp)
        for i = 1 to length(lUserCleanUp) do
            lRC = call_func( lUserCleanUp[i],
	           {pErrCode, pDispMsg, i, (i = lNumUserIds)} )
            if lRC = -1 then
                exit
            end if
        end for
        xUserCleanUp = lUserCleanUp
    end if

end procedure

procedure fShowError( sequence pParams, integer pMode )
    integer lErrCode
    integer lResponse
    integer lStyle

    sequence s
    sequence lDispMsg
    sequence lTitle


    if length(pParams) = 0 and pMode = 2 then
        -- This causes the attached cleanup routines to run and nothing else to happen.
        pMode = 3
        lErrCode = 0

    elsif length(pParams) >= 2 and
        sequence(pParams[1]) then
        s = pParams[1]
        if integer(pParams[2]) then
            lErrCode = pParams[2]
        else
            lErrCode = 0
        end if
        if length(pParams) >= 3 then
            s = sprintf(s, pParams[3])
        end if
        lDispMsg = sprintf("Error code %d\n%s", {lErrCode, s})
    else
        s = pParams
        lErrCode = 0
        lDispMsg = s
    end if

    lTitle = vAppName & " - "
    if pMode = 1 then
        lTitle &= "Error Warning"
        lDispMsg &= "\n\n" &
            "Press\n" &
            "  [ YES ]  to continue,\n" &
            "  [ NO ] to ignore repeats, or\n" &
            "  [ Cancel ]  to quit."
        lStyle = MB_ICONEXCLAMATION + MB_YESNOCANCEL
    elsif pMode = 2 then
        lTitle &= "Fatal Error"
        lStyle = MB_ICONHAND
    else -- pMode = 3
        lDispMsg = ""
        lTitle = ""
        lStyle = 0
    end if

    -- give message
    if pMode != 3 and find(lErrCode, vMsgsToIgnore) = 0 then
        lDispMsg &= "\n\n" & vVersion
        lResponse = message_box( lDispMsg, lTitle, lStyle+MB_TASKMODAL )
    else
        lResponse = IDYES
    end if

    if pMode = 2 or pMode = 3 or lResponse = IDCANCEL then
        fCleanUp(lErrCode, lDispMsg)

        if pMode = 2 then
            -- abort
            crash_message(lDispMsg)
        end if
        if pMode != 3 then
            abort(1/0) -- Force the ex.err to be created.
        end if

        if lResponse = IDNO  then
            vMsgsToIgnore &= lErrCode
        end if
    end if

end procedure



-----------------------------------------------------------------------------
--/topic Errors
--/proc abortErr( sequence errorparam )
--/desc Display an error message, run any user-defined cleanup routines, and then abort.
-- /i errorparam can be either a text message or a two-element sequence in which the
-- first is a text message and the second is an error code (integer).
--
-- If any user-defined clean up routine have been attached, they are invoked prior to
-- win32lib's own cleanup routine, then the application is aborted. See /attachCleanUp()
-- for details.
--
-- Example:
--
--/code
--      abortErr( {"The tape drive is not responding.", /w32MsgNum + 17} )
--
--      abortErr(  "Fatal error. Bummer, dude." )
--/endcode


global procedure abortErr( sequence pParams )
   fShowError(pParams, 2)
end procedure


-----------------------------------------------------------------------------
--/topic Errors
--/proc warnErr( sequence errorparam )
--/desc Display an error message, with option to abort.
-- /i errorparam can be either a text message or a two-element sequence in which the
-- first is a text message and the second is an error code (integer).
--
-- This routine will display a dialog window with three buttons. /n
-- /i"[ YES ]" : If selected, the program will continue. /n
-- /i"[ NO  ]" : if pressed, the program will continue, but future warning about the /b same
-- error will be ignored. /n
-- /i"[CANCEL]": if pressed, will stop the program running immediately.
--
-- If any user-defined clean up routine have been attached, they are invoked prior to
-- win32lib's own cleanup routine, if the application is aborted. See /attachCleanUp()
-- for details.
-- Example:
--
--/code
--      warnErr( "Bad data. Abort program?" )
--/endcode

global procedure warnErr( sequence pParams )

   if showWarnings != 0 then
      fShowError(pParams, showWarnings)
   end if

end procedure

-----------------------------------------------------------------------------
--/topic Errors
--/proc setWarning( integer flag )
--/desc Shows or Hides warning messages from user.
-- Since 'warning' messages (triggered by /warnErr) are only warnings and
-- not fatal, it may be advantageous to suppress them in an application.
--
-- The /i flag maybe one of ... /n
--/li 0 To hide warning messages
--/li 1 To show warning messages, giving the option to continue or quit.
--/li 2 To turn all warning messages into fatal errors instead.
--
-- By default, the setting is /b 1
-- Example:
--
--/code
--      -- suppress warning messages
--      setWarning( 0 )
--/endcode

global procedure setWarning( integer flag )
sequence
     lRealFlag

   lRealFlag = {1,0,1,2}
   -- show or suppress warnErr messages
   showWarnings = lRealFlag[ find(flag, {0,1,2}) + 1 ]

end procedure

-----------------------------------------------------------------------------
--/topic Errors
--/proc attachCleanUp( routine_id )
--/desc Establishes a user defined clean up routine which is invoked just prior to win32lib ending or aborting.
--/ret (INTEGER) The number of clean up routines attached.
-- Allows the application to clean up when win32lib application is ending or detects an abort situation.
-- It is possible to attach multiple clean up routines. If this is done, they are invoked by win32lib in
-- order of most-recently-attached to first-attached, that is in reverse order that they were attached in.
--
-- The clean up routine, when invoked by win32lib, is passed four parameters...
--/li /b ErrorCode (integer) Zero if this is a normal end, or the code number for the
-- error that is causing win32lib to abort.
--/li /b ErrorText (sequence) The text displayed to the user.
--/li /b ControlId (integer) The id of the current control (0 => no control is current).
--/li /b LastCleanup (integer) A flag which is 1 if this is the last user defined cleanup
-- routine to be invoked, and 0 if there are others still to be invoked.
--
-- The clean up routine must return an integer /i flag. If the /i flag is -1, then no further attached
-- clean up routines will be invoked before win32lib aborts, otherwise any other routines will
-- be invoked. You only return -1 if you really do know what the side-effects will be.
--
-- The clean up routines are run before the crash_routines the program may have defined
-- if using Euphoria v2.5 or higher.
--
-- Example:
--
--/code
--   function AppCleanUp(integer ErrCode, sequence ErrText, integer ControlId, integer LastCleanUp)
--      . . .
--      return 0 -- Continue with other clean up routines.
--   end function
--
--   -- Link in my clean-up routine
--   cnt = attachCleanUp( routine_id("AppCleanUp" ))
--/endcode

global function attachCleanUp( integer pId )

    if pId >= 0 then
        if atom(xUserCleanUp) then -- this is the first defined routine
            xUserCleanUp = {pId}
        else -- not the first defined routine
            xUserCleanUp = prepend(xUserCleanUp, pId)
        end if

        return length(xUserCleanUp)
    else
        return pId
    end if

end function


-----------------------------------------------------------------------------
--/topic Errors
--/proc detachCleanUp( routine_id )
--/desc Removes a user defined clean up routine from the list of attached ones.
--/ret If unsuccessful this returns -1, else the number of clean up routines still attached.
--
-- Example:
--
--/code
--   integer cnt, CU_id
--   . . .
--   function AppCleanUp(integer ErrCode, sequence ErrText, integer ControlId, integer LastCleanUp)
--      . . .
--      return 0 -- Continue with other clean up routines.
--   end function
--
--   -- Link in my clean-up routine
--   CU_id = routine_id("AppCleanUp" )
--   cnt = attachCleanUp( CU_id )
--   . . .
--   cnt = detachCleanUp( CU_id )
--/endcode

global function detachCleanUp( integer pId )
integer lRc
   if atom(xUserCleanUp)
   then
      return -1
   end if

   lRc = find( pId, xUserCleanUp)

    if lRc > 0 then
        if length(xUserCleanUp) = 1 then
            xUserCleanUp = -1
            return 0
        else
            xUserCleanUp = xUserCleanUp[1 .. lRc - 1] & xUserCleanUp[lRc + 1 .. length(xUserCleanUp)]
            return length(xUserCleanUp)
        end if
    else
        return -1
    end if

end function

--/topic Constants
--/const w32MsgNum
--/desc This is the recommended starting point for user defined error codes.
-- There are no win32lib error codes from this number on. /n
-- Example:
--/code
--   constant BadResponse  = w32MsgNum + 0,
--            FileNotFound = w32MsgNum + 1,
--            ReadOnlyFile = w32MsgNum + 2
--   . . .
--   /abortErr( {The requested file could not be located.", FileNotFound})
--
--/endcode

global constant
   w32MsgNum = 500   -- All win32lib error codes are less than this.

global procedure Init_UI_Msgs(sequence pKeyVals)

    for i = 1 to length(pKeyVals) do
        if equal(upper(pKeyVals[i][1]), "APPNAME") then
            vAppName = pKeyVals[i][2]

        elsif equal(upper(pKeyVals[i][1]), "APPVERSION") then
            vVersion = pKeyVals[i][2]
            if match("Beta", vVersion) then
                puts(1, vVersion)
                puts(1, '\n')
            end if

        end if
    end for
end procedure

-- w32utils.ew

--------------------NOTICE-------------------------------*
-- Software ID: w32utils.e
-- Version:     0.70.4a
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*

--/topic Support Routines
--/info
--Miscellaneous 'generic' routines used by win32lib
--These routines can be used by many applications as they are
--not specific to the Win32Lib library.

--/topic Constants
--/const w32False
--/desc The value for a boolean FALSE.

--/topic Constants
--/const w32True
--/desc The value for a boolean True

--/topic Constants
--/const w32True
--/desc Pass this value as a parameter to obtain its current value without setting it.
-- Some routines will use a different magic value when this one could be a valid input.

global constant
    w32False   = (1 = 0),
    w32True    = (1 = 1),
    w32GetValue = -1


--/topic Types
--/type w32string
--/desc Implements an ASCII string.
--Identifiers declared as type w32string are sequences that can only
-- contain integers in the range 0 to 255 inclusive.
--
--Example:
--/code
--  w32string Name
--  Name = "abc" -- Okay.
--  Name = 12 -- Fails
--  Name = {'a', 'b', 'c'} -- Okay
--  Name = {'a', 'b', 12.3} -- Fails
--  Name = {"abc", "def"} -- Fails.
--/endcode
---------------------------------------
global type w32string( object s )
---------------------------------------
    if not sequence(s) then
        return 0
    end if

    for i = 1 to length(s) do
        if not integer(s[i]) then
            return 0
        end if

        if s[i] < 0 or s[i] > 255 then
            return 0
        end if

    end for
    return w32True
end type

--/topic Support Routines
--/func w32to_string( object pData )
--/desc Converts the parameter to a string repesentation of its value.
--/ret SEQUENCE: A string representation of the parameter.
---------------------------------------
global function w32to_string( object s )
---------------------------------------
    sequence lResult

    if atom(s) then
        return sprintf("%g", s)
    end if

    if w32string(s) then
        return s
    end if

    lResult = ""
    for i = 1 to length(s) do

        lResult &= "'"
        lResult &= w32to_string(s[i])
        lResult &= "'"

        if i != length(s) then
            lResult &= ", "
        end if
    end for

    return lResult
end function



--/topic Support Routines
--/func w32get_bits( atom b32 )
--/desc Does the reverse of /w32or_all() in that it gets all the bit values from an atom.
--/ret Sequence: The non-zero bits set in /i b32.
--
-- Typically used to extract which bits have been set on in a flag.
--
-- Example:
--
-- /code
--      -- combine flags
--      integer flags
--      sequence codes
--      codes = w32get_bits( origflag )
--      if find(WS_EX_CLIENTEDGE, codes) then
--          setText(statusarea, "Client Edge has been specified")
--      end if
-- /endcode
constant kBitPosn = {
    #00000001 , #00000002, #00000004, #00000008,
    #00000010 , #00000020, #00000040, #00000080,
    #00000100 , #00000200, #00000400, #00000800,
    #00001000 , #00002000, #00004000, #00008000,
    #00010000 , #00020000, #00040000, #00080000,
    #00100000 , #00200000, #00400000, #00800000,
    #01000000 , #02000000, #04000000, #08000000,
    #10000000 , #20000000, #40000000, #80000000
                     }
global function w32get_bits(atom b32)
sequence lResult

    lResult = {}
    for i = 1 to length(kBitPosn) do
        if and_bits(b32, kBitPosn[i]) then
            lResult &= kBitPosn[i]
        end if
    end for

    if length(lResult) = 0 then
        lResult = {0}
    end if

    return lResult
end function


--/topic Support Routines
--/func w32signed_word( atom a )
--/desc Converts /i a into a signed 16-bit integer.
--/ret INTEGER: Signed 16 bits of a 32 bit word.
-- Typically used to decode Win32 message values when several values
-- are packed into a single number.
--
-- Example:
--
-- /code
--      -- extract the low portion from lParam
--      integer x
--      x = w32signed_word( lParam )
-- /endcode

global function w32signed_word( atom a )
    -- return low word
    integer x
    x = and_bits( a, #FFFF )
    if x > #7FFF then
        x -= #10000
    end if
    return x
end function



-----------------------------------------------------------------------------

--/topic Support Routines
--/func w32pack_word( integer low, integer high )
--/desc Packs values into word.
--/ret ATOM: 32 bit word with low value in low 16 bits, high value in high 16 bits.
-- Typically used to encode a message parameter into a 32 bit word.
--
-- Example:
--
-- /code
--      -- pack min and max into parameter
--      integer y
--      lParam = w32pack_word( min, max )
-- /endcode

global function w32pack_word( integer low, integer high )
    -- return packed 32 bit value

    return ( and_bits( high, #FFFF ) * #10000 ) + and_bits( low,  #FFFF )

end function


--/topic Support Routines
--/func w32lo_word( atom pData)
--/desc returns the low-16 bits of /i pData
--/ret INTEGER: Bits 15-0 of the parameter
--
-- Example:
-- /code
--      integer y
--      y = w32lo_word( bigval )
-- /endcode

global function w32lo_word( atom pData)
    return and_bits(pData, #FFFF)
end function


--/topic Support Routines
--/func w32hi_word( atom pData)
--/desc returns the high 16 bits of /i pData
--/ret INTEGER: Bits 31-16 of the parameter as a 16 bit value.
--
-- Example:
-- /code
--      integer y
--      y = w32hi_word( bigval )
-- /endcode

global function w32hi_word( atom pData)
    return and_bits(and_bits(pData, #FFFF0000) / #10000, #FFFF)
end function


--/topic Support Routines
--/func w32abs( object a )
--/desc Absolute value.
--/ret Absolute value of the atom or sequence.
--
--Example
--/code
--       sequence s
--       atom a
--
--       a = w32abs(-1)   -- = 1
--       s = w32abs({-2,-1,{-1,0,1},1,2}) -- = {2,1,{1,0,1},1,2}
--/endcode

global function w32abs( object a )
    if atom(a) then
        if a < 0 then
            return -a
        else
            return a
        end if
    else
        for i = 1 to length(a) do
            a[i] = w32abs(a[i])
        end for

        return a
    end if

end function


--/topic Support Routines
--/func w32unpack_dword( atom a )
--/desc Converts a number into two 16-bit integers
--/ret (SEQUENCE) The pair {low word,high word}
-- Typically used to decode Win32 message values.
global function w32unpack_dword( atom a )
    if a<0 then
        a+=power(2,32)
    end if
    return floor(remainder({a,a/#10000},#10000))
end function

--/topic Support Routines
--/func w32shortInt( atom a )
--/desc Converts a number into a 16-bit signed integer
--/ret INTEGER: The value of /i a as a short int, in the -32,768..32767 range.
-- Typically used to decode Win32 message values
--
-- Example:
--
-- /code
--      -- Mouse Position
--      sequence hilo, x, y
--      lohi = w32unpack_dword( lParam )
--      x = w32shortInt(lohi[2])
--      y = w32shortInt(lohi[1])
-- /endcode
global function w32shortInt( atom i )

    -- converts numbers ( 4 bytes #0000 to #FFFF)
    -- to signed short ints (2 bytes -32768 to 32767 )

    -- Force the use of only the rightmost 2 bytes.
    i = and_bits(i, #FFFF)

    if i >= 0 and i <= #7FFF then
        return i
    else
        return i - #10000
    end if

end function

global constant
    w32RoundDown = 1,
    w32RoundUp = 2,
    w32RoundToZero = 3,
    w32RoundToInf = 4,
    w32RoundScientific = 5,
    w32RoundCommercial = 6

--/topic Support Routines
--/func w32remainder(object a,object b)
--/desc Ensures that the result has the sign of /i b, contrary to remainder().
--/ret (ATOM) The remainder of /i a divided by /i b, the result having the sign of /i b.
-- remainder() returns a result which has the sign of /i a. /n
-- This function extends to sequences.
global function w32remainder(object a,object b)
    if sequence(a) then
        for i=1 to length(a) do
            a[i]=remainder(a[i],b)
        end for
        return a
    elsif sequence(b) then
        for i=1 to length(a) do
            b[i]=remainder(a,b[i])
        end for
        return b
    end if
    if compare(a,0.0)=compare(b,0.0) then
        return remainder(a,b)
    else
        return b+remainder(a,b)
    end if
end function

--/topic Support Routines
--/func w32average(sequence data,object weight)
--/desc Computes the weighted average of /i data using the weight(s) /i weight.
--/ret (OBJECT) The ratio sum_of_data/sum_of_weights.
-- If /i data is not homogeneous, or /i weight is a sequence and has a sequence element, or
-- the supplied weight is 0, or the sum of supplied weights is 0, then
-- an "absurd" value is returned: 0 if data[1] is a sequence, else {}./n
-- Extra data or weights are discarded./n
-- If data or weight is an empty sequence, 0 is returned.
global function w32average(sequence data,object weight)
    object pattern,test,sum_data,x,on_error
    atom sum_weight

    if sequence(weight) then
        if length(data)>length(weight) then
            data=data[1..length(weight)]
        elsif length(data)<length(weight) then
            weight=weight[1..length(data)]
        end if
    end if
    if equal(weight,{}) then
        return 0
    elsif equal(data,{}) then
        return 0
    elsif length(data)=1 then
        return data[1]
    end if
    pattern=data[1]
    sum_data=pattern
    pattern=0
    if atom(pattern) then
        on_error = {}
    else
        on_error = 0
    end if
    if atom(weight) then
        if weight=0 then
            return on_error
        end if
        for i=2 to length(data) do
            x=data[i]
            test=x
            test=0
            if compare(test,pattern) then --data is not homogeneous
                return on_error
            end if
            sum_data+=x
        end for
        return sum_data/weight
    else
        sum_weight=weight[1]
        for i=2 to length(data) do
            x=data[i]
            test=x
            test=0
            if sequence(weight[i]) or compare(test,pattern) then --data is not homogeneous
                return on_error
            end if
            sum_data+=x
            sum_weight+=weight[i]
        end for
        if sum_weight=0 then
            return on_error
        else
            return sum_data/sum_weight
        end if
    end if
end function

--/topic Support Routines
--/func w32round(object a,object b,integer flag)
--/desc Rounds /i a, or all the atoms in the sequence /i a, to some multiple of /i b.
--/ret The rounded value(s).
-- This function extends to sequences, except for the /i flag argument. /n
-- The way the rounded value is reckoned from a is defined by /i flag. Supported values are:
--/li w32RoundDown: round to the highest less or equal multiple of /i b
--/li w32RoundUp: round to the lowest greater or equal multiple of /i b
--/li w32RoundToZero: round to the closest multiple of /i b betwaeen /i a and 0.0
--/li w32RoundToInf: round to the closest multiple of /i b betwaeen /i a and the infinity.
--/li w32RoundScientific: round to closest multiple of /i b. If there is a tie, ensure
-- deterministic evenness of choices.
--/li w32RoundCommercial: round to closest multiple of /i b.
global function w32round(object a,object b,integer flag)
    atom diff
    integer sgn

    if sequence(a) then
        for i=1 to length(a) do
            a[i]=remainder(a[i],b)
        end for
        return a
    elsif sequence(b) then
        for i=1 to length(a) do
            b[i]=remainder(a,b[i])
        end for
        return b
    end if

    if b<=0.0 or a=0.0 then
        return a
    end if
    if sequence(a) then
        for i=1 to length(a) do
            a[i]=w32round(a[i],b,flag)
        end for
        return a
    end if

    diff = w32remainder(a,b)
    sgn = compare(a,0.0)
    if diff/(a*sgn)<1e-8 then   -- a is a multiple of b
        return a
    end if
    -- now sgn is guaranteed to be 1 or -1
    if flag=w32RoundUp then
        return a+b-diff
    elsif flag=w32RoundDown then
        return a-diff
    elsif flag=w32RoundToZero then
        if sgn=1 then
            return a-diff
        else
            return a+b-diff
        end if
    elsif flag=w32RoundToInf then
        if sgn=-1 then
            return a-diff
        else
            return a+b-diff
        end if
    else -- any unknown value defaults to w32Scientific
        sgn = compare(diff+diff,b)
        if sgn=1 then
            return a+b-diff
        elsif sgn=-1 then
            return a-diff
        elsif flag = w32RoundCommercial then
            return a
        else
            if remainder(floor(a/b),2) then
                return a+diff -- makes the integer part even
            else
                return a
            end if
        end if
    end if
end function

constant
    vDigits = ".,0123456789ABCDEF",
    vIgnored = find('0',vDigits)
sequence vCurrencySym vCurrencySym = "$£¤¥€"
integer decimal_mark decimal_mark=1
global constant
    w32DECIMAL_DOT = 1,
    w32DECIMAL_COMMA = 2
--/topic Support Routines
--/func setDecimalMark(integer new_mark)
--/desc Gets and possibly sets the decimal mark w32TextToNumner() is to recognise.
--/ret (INTEGER) The previous or current value.
-- new_mark is either '.', ',', w32DECIMAL_DOT, w32DECIMAL_COMMA or w32GetValue.
-- Negative values are considered to be w32GetValue, positive unknown value are assumed to be w32DECIMAL_DOT.
-- If the new mark is not w32GetValue, the new mark becomes the decimal mark w32TextToNumber()
-- will use. The former value is always returned.
global function setDecimalMark(integer new_mark)
    integer old_mark

    old_mark = decimal_mark
    if new_mark>=0 then
        if new_mark=',' then
            new_mark = w32DECIMAL_COMMA
        elsif new_mark != w32DECIMAL_COMMA then
            new_mark = w32DECIMAL_DOT
        end if
        decimal_mark = new_mark
    end if
    return old_mark
end function

--/topic Support Routines
--/func w32TextToNumber( sequence text )
--/ret Atom: The number represented by the text.
--/desc This converts the text into a number.
-- If the text contains invalid characters, zero is returned.
--
-- /b "Note 1:" You can supply /b Hexadecimal values if the value is preceded by
-- a '#' character, /b Octal values if the value is preceded by a '@' character,
-- and /b Binary values if the value is preceded by a '!' character. With
-- hexadecimal values, the case of the digits 'A' - 'F' is not important. Also,
-- any period character embedded in the number is used with the correct base.
--
-- /b "Note 2:" Any underscore characters or thousands separators, that are embedded in the text
-- number are ignored. These can be used to help visual clarity for long numbers. The thousands
-- separator is ',' if the decimal mark is '.' (the default), or '.' if it is ','. You
-- inspect and set it using /setDecimalMark().
--
--/b "Note 3:" You can supply a leading or trailing, minus or plus sign.
--
--/b "Note 4:" You can supply trailing percentage sign(s). Each one present causes
-- the resulting value to be divided by 100.
--
--/b "Note 5:" Any single currency symbol to the left of the first digit is ignored.
-- A currency symbol is any character of the string: "$£¤¥€". A currency symbol may
-- have no digit before it, and must be followed by a dot or digit. If there is none,
-- a single trailing currency sign will be ignored, but there must not be any digit
-- past it.
--
--/b "Note 6:" Leading characters may appear in any order and be mixed. Only the
-- sign or base symbol further inside is taken into acount.
--
-- This function can optionally return information about invalid numbers. If
-- /i text has the form of {sequence, integer} then if the integer is nonzero,
-- a sequence is returned. The first element is the value converted, and the
-- second is the position in the text where conversion stopped. If no errors
-- were found then this is zero.
--
--/code
--     sequence rc
--     atom   val
--     rc = w32TextToNumber({"12.34a", 1})
--     --  rc ---> {12.34, 6} -- Error at position 6
--     rc = w32TextToNumber({"12.34", 1})
--     --  rc ---> {12.34, 0} -- No errors.
--
--     val = w32TextToNumber("12.34a")
--     --  val ---> 0
--
--      val = w32TextToNumber("#f80c") --> 63500
--      val = w32TextToNumber("#f80c.7aa") --> 63500.47900390625
--      val = w32TextToNumber("@1703") --> 963
--      val = w32TextToNumber("!101101") --> 45
--      val = w32TextToNumber("12_583_891") --> 12583891
--      val = w32TextToNumber("12_583_891%") --> 125838.91
--      val = w32TextToNumber("12,583,891%%") --> 1258.3891
--
--/endcode
global function w32TextToNumber( sequence text)
    -- get the numeric value of text
    integer dot,sign,tstart,tend, v, note, notify
    atom lhs, rhs, lh, rh
    integer base, pc
    atom value
    integer digcnt
    integer currency
-- modified CChris <oedoc@free.fr>, Dec 5, 2006
-- the innermost trailing currency sign is taken into account if no leading currency sign
    integer nomoredigit

    dot = 0
    lh = 0
    lhs = 0
    rh = 0
    rhs = 1
    sign = 0
    note = 0
    base = 10
    pc = 1
    digcnt = 0
    currency = 0
    nomoredigit = 0

    if  length(text) = 2  and
        sequence(text[1]) and
        integer(text[2])
    then
        notify  = text[2]
        text = text[1]
    else
        notify = 0
    end if

    -- convert the value of the text
    text = upper(text)
    tstart = 1
    tend = length(text)
    -- Ignore leading whitespace
    while tstart <= tend do
        if equal(text[tstart], '-') and sign = 0 then
            sign = -1
        elsif equal (text[tstart],'+') and sign = 0 then
            sign = 1
        elsif equal (text[tstart],'#') then
            base = 16
        elsif equal (text[tstart],'@') then
            base = 8
        elsif equal (text[tstart],'!') then
            base = 2
        elsif find(text[tstart], {'\t', ' ', #A0}) = 0 then
            exit
        end if
        tstart += 1
    end while

    -- Ignore trailing whitespace
    while tstart <= tend do
        if equal(text[tend], '-') and sign = 0 then
            sign = -1
        elsif equal(text[tend],'+') and sign = 0 then
            sign = 1
        elsif equal(text[tend],'%') then
            pc *= 100
        elsif find(text[tend], {'\t', ' ', #A0, #A2}) = 0 then
            exit
        end if
        tend -= 1
    end while

    -- Set the default sign.
    if sign = 0 then
        sign = 1
    end if

    for i = tstart to tend do
        if lhs > 0 and find(text[i],"_") > 0 then
            -- ignore an embedded grouping characters.
        elsif digcnt = 0 and currency = 0 and find(text[i],vCurrencySym) > 0 then
            -- ignore a single leading currency symbol.
            currency = i
        else
            v = find(text[i], vDigits)
            if v >= vIgnored+base then
                v=0
            end if
            if v < vIgnored then
                if v = decimal_mark then -- A dot found, or an ignored character.
                    if dot = 0 then
                        dot = 1
                    else
                        v=0 -- this period is illegal
                    end if
                -- else ignore
                end if
                if v=0 then
                -- Invalid char so force a zero return.
                    note = i
                    if notify = 0 then
                        sign = 0
                    end if
                    exit
                end if
            else
                v -= vIgnored
                if v < 0 or v > base then
                    if not currency and find(text[i],vCurrencySym) then
                        currency = 1
                        nomoredigit = 1
                    else
                        note = i
                    -- Illegal char found.
                        if notify = 0 then
                            sign = 0
                        end if
                        exit
                    end if
                elsif nomoredigit then  -- trailing currency sign, shouldn't be any more digits
                    note = i
                    if notify = 0 then
                        sign = 0
                    end if
                    exit
                else
                    if dot = 1 then
                        rhs *= base
                        rh = (rh * base) + v
                        digcnt += 1
                    else
                        lhs += 1
                        lh = (lh * base) + v
                        digcnt += 1
                    end if
                end if
             end if
        end if

        -- I got to the end without error!
        if i = tend then
            note = 0
        end if

    end for

    if rh = 0 and pc = 1 then
        -- Common situation optimised for speed.
        value = lh * sign
    else
        value = ((lh + (rh / rhs)) * sign) / pc
    end if

    if notify = 0 then
        return value
    else
        -- Error if no actual digits where converted.
        if note = 0 and digcnt = 0 and value = 0 then
            note = 1
        end if
        return {value, note}
    end if
end function

--/topic Support Routines
--/func w32or_all( object pData )
--/desc Calculates a binary OR against each element in /pData
--/ret ATOM: The OR'd value
--
--example:
--/code
--      atom flags
--      flags = w32or_all({WS_CHILD, WS_VISIBLE, WS_BORDER})
--/endcode

global function w32or_all( object pData )
    atom lResult

    if atom(pData) then
        return pData
    end if

    if length(pData) = 0 then
        return 0
    end if

    if length(pData) = 1 then
        return w32or_all(pData[1])
    end if

    lResult = or_bits(pData[1], pData[2])
    for i = 3 to length(pData) do
        lResult = or_bits(lResult, pData[i])
    end for

    return lResult
end function

--/topic Support Routines
--/func w32findKeyEx( object key, sequence list, object element )
--/desc Find key in list using the depth indicated in element.
--/ret INTEGER: The index for the item that contains /i key. Zero if not found.
--The /i element parameter specifies which sub-elements are to be inspected.
--
-- Example:
--/code
--      -- find a value from a list
--      constant aList = { {"red", {17, 1, "ap"}}, {"blue", {10,3,"ef"}},
--                         {"orange", {299, 9, "op"}}, {"black", {0,4, "yz"} } }
--      integer at
--      at = w32findKey( "op", aList, {2,3} )
--      -- 'at' should now equal 3.
--      at = w32findKey( 10, aList, {2,1} )
--      -- 'at' should now equal 2.
--      at = w32findKey( "gh", aList, {2,3} )
--      -- 'at' should now equal 0.
--/endcode


global function w32findKeyEx( object pKey, object pList, object pElement )
    integer lPos
    if atom(pList) then
        return equal(pKey,pList)
    end if

    if sequence(pElement) and length(pElement) = 1 then
        pElement = pElement[1]
    end if

    if sequence(pElement) then
        lPos = 0
        for i = 1 to length(pList) do
            lPos = w32findKeyEx(pKey, pList[i][pElement[1]], pElement[2..length(pElement)])
            if lPos != 0 then
                return i
            end if
        end for
        return 0
    else
        if pElement < 1 then
            for i = 1 to length( pList ) do
                if sequence(pList[i]) and find( pKey, pList[i] ) then
                    return i
                elsif atom(pList[i]) and  equal(pKey, pList[i]) then
                    return i
                end if
            end for
        else
            for i = 1 to length( pList ) do
                if sequence(pList[i]) and length(pList[i]) >= pElement and equal( pList[i][pElement], pKey ) then
                    return i
                elsif i = pElement and equal( pList[i], pKey ) then
                    return i
                end if
            end for
        end if
    end if
    return 0

end function

--/topic Support Routines
--/func w32findKey( object key, sequence list )
--/desc Find the element in /i list that has /i key as its first element.
--/ret INTEGER: The index for the item that contains /i key. Zero if not found.
--The /i list must be a sequence of sequences. That is, each element in /i list must
--be a sequence containing at least one element. The /i key is the first element in
-- each sub-sequence of /i list.
--
-- Example:
--
--/code
--      -- find a value from a list
--      constant aList = { {"red", 17}, {"blue", 10}, {"orange", 299}, {"black", 0} }
--      integer at
--      at = w32findKey( "orange", aList )
--      -- 'at' should now equal 3.
--      at = w32findKey( "white", aList )
--      -- 'at' should now equal 0.
--/endcode

global function w32findKey( object pKey, sequence pList )
    return w32findKeyEx(pKey, pList, 1)
end function

--/topic Support Routines
--/func w32removeIndex( integer index, sequence list )
--/desc Remove the element at position /i index from the sequence /i list
--/ret The /i list without the element.
--
--If /i index is greater than the list length, the list is returned intact.
-- If /i index is less than 1, it represents the end of the list PLUS
-- the index. So an index of '-1' means the second-last element.
--
-- Example:
--
--/code
--      -- Remove the 4th element from the Name List
--      nameList = w32removeIndex( 4, nameList )
--      -- Remove the last element.
--      nameList = w32removeIndex( 0, nameList )
--/endcode

global function w32removeIndex( integer index, sequence list )
    -- Sanity check for non-existant elements.
    if index > length(list) then
        return list
    end if

    if index < 1 then
        index = length(list) + index
        if index < 1 then
            return list
        end if
    end if

    return list[1 .. index-1] & list[index+1 .. length(list)]
end function

--/topic Support Routines
--/func w32lookup(object pItem, sequence pSource, sequence pTarget)
--/desc Returns the corresponding element.
--/ret OBJECT: The corresponding element or 0/{} if not found.
--This searches /i pSource for /i pItem and if found, it returns the
-- corresponding element from /i pTarget. /n
--If /i pItem is not found in /i pSource, then what is returned depends
-- on a few things. /n
--If /i pTarget is longer than /i pSource then the last element in
-- /i pTarget is returned. This implements a way to return a default
-- value of your choosing. /n
--If /i pTarget is not longer than /i pSource then if the first element
-- of /i pTarget is an atom then zero is returned; otherwise an empty
-- sequence is returned. If pTarget is empty, then 0 is returned.
--
--Examples:
--
--/code
--       x = w32lookup('a', "cat", "dog") --> 'o'
--       x = w32lookup('d', "cat", "dogx") --> 'x'
--       x = w32lookup('d', "cat", "dog") --> 0
--       x = w32lookup("ape", {"ant","bear","cat"}, {"spider","seal","dog"}) --> ""
--       x = w32lookup("ant", {"ant","bear","cat"}, {"spider","seal","dog"}) --> "spider"
--/endcode
global function w32lookup(object pItem, sequence pSource, sequence pTarget)
    integer lPosn

    -- invalid pTarget
    if not length(pTarget) then
        return 0
    end if

    lPosn = find(pItem, pSource)
    if lPosn > 0 then
-- added CChris <oedoc@free.fr> Dec 5, 2006
-- avoided crash when pTarget is too short
        if length(pTarget) >= lPosn then
            return pTarget[lPosn]
        end if
    elsif length(pTarget) > length(pSource) then
        return pTarget[length(pTarget)]
    end if

    -- pTarget is too short, return a guess of an invalid, non crashing value
    if atom(pTarget[1]) then
        return 0
    else
        return ""
    end if

end function

--/topic Support Routines
--/func w32iff (atom test, object ifTrue, object ifFalse)
--/desc Used to embed an 'if' test inside an expression.
--/ret If /i test is /b true then /i ifTrue is returned otherwise /i ifFalse is returned.
--
--Example
--/code
--         msg = sprintf("%s: %s", {
--                      w32iff(ErrType = 'E', "Fatal error", "Warning"),
--                      errortext } )
--/endcode

----------------------------------------------------------------------------
global function w32iff( atom test, object ifTrue, object ifFalse )
    -- returns ifTrue if flag is true, else returns ifFalse
    -- ex:  ? w32iff( 1, "this", "that" )
    --      --> "this"
    if test then
        return ifTrue
    else
        return ifFalse
    end if

end function


--/topic Support Routines
--/func w32removeItem( object item, sequence list)
--/desc Removes /i item from the /i list, if it is in the list.
--/ret The /i list without the item.
--
--Example
--/code
--     -- Remove the name 'fred' from the list.
--     nameList = w32removeItem("fred", nameList)
--/endcode
----------------------------------------------------------------------------
global function w32removeItem( object item, sequence list )
    -- Removes the item from the list if item is in the list.
    item = find(item,  list )
    if item != 0 then
        return list[1 .. item-1] & list[item+1 .. length(list)]
    else
        return list
    end if
end function

--/topic Support Routines
--/func w32insertElement( sequence list, integer pos, object item )
--/desc Inserts the /i object into the /i list at position /i pos
--/ret The /i list with the /i item inserted.
--The new element becomes the /i"pos"'th element in the list. /n
--
--This routine also handles positions less than 1. If pos < 1 then it will
-- be changed to length(list)+pos+1, meaning that a value of 0 will add to the
-- end of the list, -1 just before the end, etc... If the recalculated /i pos
-- is less than 1 then the element is added to the front of the /i list.
--
--Example
--/code
--     -- Insert the name 'fred' before the 3rd element in the list.
--     nameList = w32insertElement(nameList, 3 , "fred")
--/endcode

----------------------------------------------------------------------------
global function w32insertElement(sequence list, integer pos, object item  )
    if pos = 0 then
        pos = length(list)+1
    elsif pos < 0 then
        pos = length(list)+1 + pos
        if pos < 1 then
            pos = 1
        end if
    end if
    if sequence(item) then
        item = {item}
    end if
    return list[1..pos-1] & item & list[pos..length(list)]
end function

--/topic Support Routines
--/func w32replaceItem(sequence pList, object pOld, object pNew)
--/desc Replaces all occurances of /i pOld with /i pNew
--/ret SEQUENCE: Updated /i pList.
--Note this routine will not do recursive replacements. That is, if pNew contains pOld, it
--doesn't go into a never-ending loop.
--
--Example: /n
--/code
--  sequence lRes
--  lRes = w32replaceItem("a;b;c;d;e", ";", " ; ")
--  -- gives "a ; b ; c ; d ; e"
--  lRes = w32replaceItem("The ^^ word is correct", "^^", "third")
--  -- gives "The third word is correct"
--/endcode

global function w32replaceItem(sequence pList, object pOld, object pNew  )
    integer lPos
    integer lFrom
    integer lLenOld
    integer lLenNew

    if atom(pOld) then
        pOld = {pOld}
    end if
    if atom(pNew) then
        pNew = {pNew}
    end if

    lLenOld = length(pOld)
    lLenNew = length(pNew)

    lFrom = 1
    lPos = match(pOld, pList[lFrom .. length(pList)])
    while lPos > 0 do
        lPos += lFrom - 1
        pList = pList[1..lPos-1] & pNew & pList[lPos + lLenOld .. length(pList)]
        lFrom = lPos + lLenNew
        lPos = match(pOld, pList[lFrom .. length(pList)])
    end while

    return pList

end function

----------------- Sorting ------------------------------------------
--/topic Support routines
--/func w32ordered_find(object x,sequence s,integer verif)
--/desc Uses a binary tree search to find /i x in /i s, possibly
-- checking if /i s is well ordered.
--/ret (INTEGER) The position of /i x in /i s, if any, or the opposite of the
-- position it would have if inserted.
-- /i verif is nonzero if it is desired to check whether /i s is increasing or decreasing.
-- A value of 0 skips the check. 0 is returned if the check fails.
-- If /i x would be inserted at the end of /i s, -1-length(/i s) is returned.
-- If /i s is {}, 0 is returned. If /i s has length 1, it is assumed to be increasing.
global function w32ordered_find(object x,sequence s,integer verif)
    integer flag,p,q,r
    if not length(s) then
        return 0
    elsif length(s)=1 then
        return w32lookup(compare(x,s[1]),{-1,0,1},{-1,0,-2})
    end if
    flag=compare(s[2],s[1])
    if flag=0 then
        return 0
    elsif verif then
        for i=3 to length(s) do
            if compare(s[i],s[i-1])!=flag then
                return 0
            end if
        end for
    end if
    p=compare(s[1],x)
    if p=flag then
        return -1
    elsif p=0 then
        return 1
    end if
    p=compare(x,s[length(s)])
    if p=flag then
        return -1-length(s)
    elsif p=0 then
        return length(s)
    end if
    if flag=1 then
        p=1
        q=length(s)
    else
        q=-1
        p=length(s)
    end if
    while w32abs(q-p)>1 do
        r=floor((p+q)/2)
        verif=compare(x,s[r])
        if verif=0 then
            return r
        elsif verif=flag then
            q=r
        else
            p=r
        end if
    end while
    return w32iff(flag=1,-q,-p)
end function

--/topic Support routines
--/func w32index(sequence s)
--/desc Returns the list of positions of items in /i s.
--/ret (SEQUENCE) A sequence s1 such that s1[i] is the position of the i-th item of sort(s).
global function w32index(sequence s)
    sequence s1,result,rep
    integer p

    s1=sort(s)
    result=repeat(0,length(s))
    rep=result
    for i=1 to length(s) do
        p=w32ordered_find(s[i],s1,1)
        result[p+rep[p]]=i
        rep[p]+=1
    end for
    return result
end function

--/topic Support routines
--/func w32index_by(sequence s,integer field)
--/desc Indexes /i s using the field number /i field.
--/ret (SEQUENCE) A sequence of indexes like /w32index().
global function w32index_by(sequence s,integer field)
    for i=1 to length(s) do
        s[i]=s[i][field]
    end for
    return w32index(s)
end function

----------------- Predefined Whitespace Routines --------------------

sequence whitespace
whitespace = ' ' & 9 & 10 & 11 & 12 & 13

--/topic Support Routines
--/func w32trim(object pSource)
--/desc Removes any whitespace chars from both ends of /i pSource
--/ret The original sequence with the matching characters removed.
--/i pSource is the sequence from which to remove whitespace. /n
-- If /i pSource is enclosed in quotes (single or double) they are
-- removed. This is a way to force leading and/or trailing whitespace
--Example:
--/code
--       sequence result
--       result = w32trim("  abc def  ")
--       ? result  -- Should display "abc def"
--       result = w32trim("\"  abc def  \"")
--       ? result  -- Should display "  abc def  "
--/endcode
------------------------------------------------------
global function w32trim(object pSource)
------------------------------------------------------
    integer lStart, lEnd

    if atom(pSource) then
        return pSource
    end if
    lEnd = length(pSource)
    if lEnd = 0 then
        return pSource
    end if

    -- Check for quote-enclosed string.
    if length(pSource) >= 2 and find(pSource[1], "'\"") and pSource[lEnd] = pSource[1] then
        return pSource[2..length(pSource)-1]
    end if

    -- Common check.
    if not find(pSource[1], whitespace) and not find(pSource[lEnd], whitespace) then
        return pSource
    end if


    lStart = 1
    while lStart <= lEnd do
        if find(pSource[lStart], whitespace) = 0 then
            exit
        end if
        lStart += 1
    end while

    while lEnd > lStart do
        if find(pSource[lEnd], whitespace) = 0 then
            exit
        end if
        lEnd -= 1
    end while

    pSource = pSource[lStart..lEnd]
    -- Check for quote-enclosed string.
    if length(pSource) >= 2 and find(pSource[1], "'\"") and pSource[length(pSource)] = pSource[1] then
        return pSource[2..length(pSource)-1]
    else
        return pSource
    end if

end function

--/topic Support Routines
--/func w32trim_right(sequence pSource)
--/desc Removes any whitespace chars from the end of /i pSource
--/ret The original sequence with the matching characters removed.
--/i pSource is the sequence from which to remove whitespace. /n
--Example:
--/code
--       sequence result
--       result = w32trim_right("  abc def  ")
--       ? result  -- Should display "  abc def"
--/endcode

------------------------------------------------------
global function w32trim_right(sequence pSource)
------------------------------------------------------
    integer lStart, lEnd

    lEnd = length(pSource)
    if lEnd = 0 then
        return pSource
    end if

    -- Common check first.
    if not find(pSource[lEnd], whitespace) then
        return pSource
    end if


    lStart = 1

    while lEnd >= lStart do
        if find(pSource[lEnd], whitespace) = 0 then
            exit
        end if
        lEnd -= 1
    end while

    return pSource[lStart..lEnd]

end function

--/topic Support Routines
--/func w32trim_left(sequence pSource)
--/desc Removes any whitespace chars from the beginning of /i pSource
--/ret The original sequence with the matching characters removed.
--/i pSource is the sequence from which to remove whitespace. /n
--Example:
--/code
--       sequence result
--       result = w32trim_left("  abc def  ")
--       ? result  -- Should display "abc def  "
--/endcode

------------------------------------------------------
global function w32trim_left(sequence pSource)
------------------------------------------------------
    integer lStart, lEnd

    lEnd = length(pSource)
    if lEnd = 0 then
        return pSource
    end if
    lStart = 1

    while lStart <= lEnd do
        if find(pSource[lStart], whitespace) = 0 then
            exit
        end if
        lStart += 1
    end while

    return pSource[lStart..lEnd]

end function

--/topic Support Routines
--/func w32split(sequence pSource, object pDelim)
--/desc Returns the undelimited substrings
--/ret SEQUENCE: A set of sequences, one per delimited substring in /i pSource
--/i pSource is the sequence from which to extract the substrings. /n
--/i pDelim is the delimiter character, delimiter string, or a set of
-- single character delimiters. /n
--
--/b "Note 1" - if /i pDelim is an atom and not equal to '{' then sections
--of text enclosed in matching '{' and '}' are not scanned. /n
--/b "Note 2" - if /i pDelim is a single string inside a sequence, then
-- it is considered to be a set of delimiter characters and any one of
-- them can delimiter the /i pSource. The results in this case are that
-- each delimitered text is followed by the sequence containing the
-- character that caused the delimitation. A final empty sequence means
-- that no delimiter was found to end the /i pSource text.
--
--Example:
--/code
--  sequence result
--  result = w32split("if abc = def then xyz()", ' ')
--  ? result  -- Should be {"if","abc","=","def","then","xyz()"}
--
--  -- Example of embedded delimiter...
--  result = w32split("event=Click,font={Courier,12}", ',')
--  ? result  -- Should be {"event=Click","font={Courier,12}"}
--
--  -- Example of delimiter set...
--  result = w32split("event=Click,font={Courier,12}", {"=,{}"})
--  ? result  -- Should be {"event","=","Click",",","font","=","","{","Courier",",","12","}"}
--
--/endcode

------------------------------------------------------
global function w32split(sequence pSource,  object pDelim)
------------------------------------------------------
    sequence lResult
    integer l,r,e
    integer lDepth
    integer lP, lS

    lResult = {}
    lDepth = 0
    l = 1
    r = 1
    if atom(pDelim) then
        -- Single char delimiter.
        while r <= length(pSource) do
            if lDepth = 0 then
                if pSource[r] = pDelim then
                    lResult = append(lResult, pSource[l..r-1])
                    l = r+1
                    r = l
                else
                    if find(pSource[r],"({") then
                        lDepth += 1
                        lP = pSource[r]
                        if lP = '{' then
                            lS = '}'
                        else
                            lS = ')'
                        end if
                    end if
                    r += 1
                end if
            else
                if pSource[r] = lP then
                    lDepth += 1
                elsif pSource[r] = lS then
                    lDepth -= 1
                end if
                r += 1
            end if
        end while
        lResult = append(lResult, pSource[l..r-1])

    elsif length(pDelim) > 0 then
        if atom(pDelim[1]) then
            -- Delimiter is assumed to be a simple string.
            e = r+length(pDelim)-1
            while e <= length(pSource) do
                if equal(pSource[r..e], pDelim) then
                    lResult = append(lResult, pSource[l..r-1])
                    l = e+1
                    r = l
                    e = r+length(pDelim)-1
                else
                    r += 1
                    e += 1
                end if
            end while

            lResult = append(lResult, pSource[l..length(pSource)])
        else
            -- In this case, the format is a string inside a sequence
            -- and the string is a list of single char delimiters.
            pDelim = pDelim[1]
            while r <= length(pSource) do
                if find(pSource[r], pDelim) then
                    lResult = append(lResult, pSource[l..r-1])
                    lResult = append(lResult, {pSource[r]})
                    l = r+1
                    r = l
                else
                    r += 1
                end if
            end while
            lResult = append(lResult, pSource[l..r-1])
            lResult = append(lResult, {})
        end if
    else
        return pSource
    end if
  return lResult
end function

global constant
    w32DELIM_FIRST = 1,
    w32DELIM_LAST = 2
--/topic Support routines
--/func w32join(sequence substrings,object delimiter,integer flag)
--/desc Builds a string by concatenating itmes in substrings, separated by delimiters.
--/ret (SEQUENCE) a whole sequence made from all substrings stitched together.
-- If the w32DELIM_FIRST flag is set, the returned string will start by the delimiter.
-- If the w32DELIM_LAST flag is set, the returned string will end with the delimiter.
global function w32join(sequence substrings,object delimiter,integer flags)
    sequence result,item

    if and_bits(flags,w32DELIM_FIRST) then
        result=delimiter & substrings[1]
    else
        result=substrings[1]
    end if
    for i=2 to length(substrings) do
        item=delimiter & substrings[i]
        result &= item
    end for
    if and_bits(flags,w32DELIM_LAST ) then
       return result & delimiter
    else
       return result
    end if
end function

--/topic Miscellaneous
--/func w32MinSequenceSize(sequence pList, integer pMinSize, object pNewData)
--/desc Pads /i pList to the right until its length reaches /i pMinSize using /i pNewData as filler.
--/ret The padded sequence, unchanged if its size was not less than /i pMinSize on input.
global function w32MinSequenceSize(sequence pList, integer pMinSize, object pNewData)

    if length(pList) < pMinSize then
        pList &= repeat(pNewData, pMinSize - length(pList))
    end if

    return pList
end function

global constant
    w32BOUNDS_MIN=0,
    w32BOUNDS_MAX=1,
    w32BOUNDS_INDEX=0,
    w32BOUNDS_VALUE=2,
    w32BOUNDS_PAIR=4,
    w32BOUNDS_INDEX_FIRST=w32BOUNDS_INDEX,
    w32BOUNDS_VALUE_FIRST=w32BOUNDS_VALUE
--/topic Utilities
--/func w32bounds(sequence items,integer flags)
--/desc Returns index(es) or value(s) of the minimal/maximal element in a sequence
--/ret (OBJECT) One or two indices, or one or two values, depending on flags.
-- /i flags is the sum of zero or more of:
--/li w32BOUNDS_MIN=0: return a minimum index or value;
--/li w32BOUNDS_MAX=1: return a maximum index or value;
--/li w32BOUNDS_INDEX=0,
--/li w32BOUNDS_VALUE=2,
--/li w32BOUNDS_PAIR=4,
--/li w32BOUNDS_INDEX_FIRST=w32BOUNDS_INDEX
--/li w32BOUNDS_VALUE_FIRST=w32BOUNDS_VALUE
-- Obviously, only some combinations make sense.
global function w32bounds(sequence items,integer flags,integer from)
    object x,y
    integer cmp

    if from<=0 or from > length(items) then
        if and_bits(flags,w32BOUNDS_VALUE+w32BOUNDS_PAIR) then
            return {}
        else
            return 0
        end if
    end if
    x=items[from]
    cmp=w32iff(and_bits(flags,w32BOUNDS_MAX),-1,1)
    for i=from+1 to length(items) do
        y=items[i]
        if compare(x,y)=cmp then
            x=y
            from=i
        end if
    end for
    if and_bits(flags,w32BOUNDS_PAIR) then
        if and_bits(flags,w32BOUNDS_VALUE_FIRST) then
            return {x,from}
        else
            return {from,x}
        end if
    elsif and_bits(flags,w32BOUNDS_VALUE) then
        return x
    else
        return from
    end if
end function

-- Character Type Tests

global constant
    Control_CT      = #0001,
    Alpha_CT        = #0002,
    Digit_CT        = #0004,
    Punct_CT        = #0008,
    Symbol_CT       = #0010,
    White_CT        = #0020,
    Lowercase_CT    = #0040,
    Uppercase_CT    = #0080,
    Printable_CT    = #0100,
    NameChar_CT     = #0200,
    User1_CT        = #0400,
    User2_CT        = #0800,
    User3_CT        = #1000,
    User4_CT        = #2000,
    User5_CT        = #4000,
    User6_CT        = #8000,
    AlphaNumeric_CT = #0006

sequence vCharAttr

vCharAttr = repeat(0, 256)

integer ctype_range_lo,ctype_range_hi,ctype_mode
sequence ctype_string
constant pChar_VALID=1, pChar_ATOM=2,pChar_RANGE=4
procedure sanity_CType(object pChar)
-- sets the vars above so as to allow faster/more versatile operation of *w32CType routines.
    integer p
    object c1,c2

    ctype_mode=0
    if atom(pChar) then
        if pChar>=0 and pChar<=#FFFF then
            ctype_mode = pChar_VALID + pChar_ATOM
            ctype_range_lo = pChar+1
            vCharAttr = w32MinSequenceSize(vCharAttr,ctype_range_lo,0)
        end if
    elsif atom(pChar[1]) then -- plain list
        p=0
        for i=1 to length(pChar) do
            c1=pChar[i]
            if not integer(c1) or c1<0 or c1>#FFFF then
                if p=0 then
                   p=i
                end if
            elsif p then
                pChar[p] = c1
                p+=1
            end if
        end for
        if p=0 then
            ctype_mode = pChar_VALID
            ctype_string = pChar+1
        elsif p>1 then
            ctype_mode = pChar_VALID
            ctype_string = pChar[1..p-1]+1
        end if
        if ctype_mode then
            vCharAttr = w32MinSequenceSize(vCharAttr,w32bounds(ctype_string,w32BOUNDS_MAX+w32BOUNDS_VALUE,1),0)
        end if
    elsif length(pChar)=2 and sequence(pChar[2]) and length(pChar[1]) and length(pChar[2]) then
        c1=pChar[1][1]
        c2=pChar[2][1]
        if integer(c1) and integer(c2) and c1<=c2 and c1<=#FFFF and c2>=0 then
            if c1<0 then
                c1=0
            end if
            if c2>#FFFF then
                c2=#FFFF
            end if
            ctype_range_lo=c1+1
            ctype_range_hi=c2+1
            ctype_mode=pChar_VALID + pChar_RANGE
            vCharAttr = w32MinSequenceSize(vCharAttr,ctype_range_hi,0)
        end if
    end if
end procedure

--/topic Support Routines
--/func w32CType( object pChar, object pSet)
--/desc Tests a character to see if it 'belongs' to a specified CharType set.
--/ret OBJECT: w32True or w32False if pChar is an atom, a sequence of these otherwise..
--/i pChar is the character(s) to check. This can take the form of a single
-- character such as 'A', a list of characters such as "1234567890", or
-- a range of characters such as {"a", "z"}. /n
--/i pSet is either a single CharType code or a set of codes. /n
--See /w32SetCType for a complete list of valid CharType codes. /n
-- w32True is returned only if the character belongs to all sets /i pSet refers to.
-- Only single byte characters are supported.
--
--Example:
--/code
--      if w32CType( text[i], Alpha_CT) then
--          ... process an alphabetic char
--      elsif w32CType( text[i], Digit_CT) then
--          ... process an digit char
--      end if
--/endcode
global function w32CType( integer pChar, object pSet)
    sequence sResult
    atom lValue
    integer shift

    sanity_CType(pChar)

    if not ctype_mode then -- invalid input
        if atom(pChar) then
            return w32False
        else
            return {}
        end if
    end if

    if and_bits(ctype_mode,pChar_ATOM) then
        lValue = vCharAttr[ctype_range_lo]

        if atom(pSet) then
            pSet = {pSet}
        end if

        for i = 1 to length(pSet) do
            if not and_bits(lValue,pSet[i]) then
                return w32False
            end if
        end for
        return w32True
    elsif and_bits(ctype_mode,pChar_RANGE) then
        shift = ctype_range_lo-1
        sResult = repeat(w32True,ctype_range_hi-shift)
        for i=ctype_range_lo to ctype_range_hi do
            lValue =vCharAttr[i]
            for j=1 to length(pSet) do
                if not and_bits(lValue,pSet[j]) then
                    sResult[i-shift]=w32False
                    exit
                end if
            end for
        end for
    else
        sResult = repeat(w32True,length(ctype_string))
        for i=1 to length(ctype_string) do
            lValue =vCharAttr[ctype_string[i]]
            for j=1 to length(pSet) do
                if not and_bits(lValue,pSet[j]) then
                    sResult[i]=w32False
                    exit
                end if
            end for
        end for
    end if
    return sResult
end function

--/topic Support Routines
--/func w32GetCType( object pChar)
--/desc Gets the CharType for the specified character(s)
--/ret Same datatype as /i pChar: The CharType code for the character(s)
--/i pChar is the character(s) to check. This can take the form of a single
-- character such as 'A', a list of characters such as "1234567890", or
-- a range of characters such as {"a", "z"}. /n
--
--Example:
--/code
--      object lRC
--      -- Returns an integer containing the CharType Codes for 'a'
--      lRC = w32GetCType('a')
--      -- Returns a sequence containing the CharType Codes for 'a', '1' and '$'
--      lRC = w32GetCType("a1$")
--/endcode
global function w32GetCType( object pChar)
    -- Only support single byte characters.

    sanity_CType(pChar)
    if not ctype_mode then -- invalid input
        if atom(pChar) then
            return w32False
        else
            return {}
        end if
    end if

    if and_bits(ctype_mode,pChar_ATOM) then
        return vCharAttr[ctype_range_lo]
    elsif and_bits(ctype_mode,pChar_RANGE) then
        return vCharAttr[ctype_range_lo..ctype_range_hi]
    else
        for i = 1 to length(pChar) do
            pChar[i] = vCharAttr[ctype_string[i]]
        end for
        return pChar
    end if

end function

--/topic Support Routines
--/proc w32SetCType( object pChar, object pSet)
--/desc Sets one or more character types used by /w32CType and /w32GetCType
--/i pChar is the character(s) to set. This can take the form of a single
-- character such as 'A', a list of characters such as "1234567890", or
-- a range of characters such as {"a", "z"}. /n
--/i pSet is either a single CharType code or a list of CharType codes. /n
--The valid CharType codes are ... /n
--/li Control_CT
--/li Alpha_CT
--/li Digit_CT
--/li Punct_CT
--/li Symbol_CT
--/li White_CT
--/li Lowercase_CT
--/li Uppercase_CT
--/li Printable_CT
--/li NameChar_CT
--/li User1_CT
--/li User2_CT
--/li User3_CT
--/li User4_CT
--/li User5_CT
--/li User6_CT
--/li AlphaNumeric_CT (a combination of Alpha_CT and Digit_CT)
--
-- You may define new character sets: the associated value must be a power of 2
-- greater than #8000 and less than #20000000.
--
--Example:
--/code
--      w32SetCType( 255, User1_CT) -- Single char
--      w32SetCType( {"n","z"}, User3_CT ) -- Range of chars
--      w32SetCType( "13579", User2_CT ) -- List of chars
--/endcode
global procedure w32SetCType( object pChar, object pSet)

    atom lSet

    sanity_CType(pChar)
    if not ctype_mode then -- invalid input
        return
    end if

    if atom(pSet) then
        lSet = pSet
    else
        lSet = w32or_all(pSet)
    end if

    if integer(pChar) then
        vCharAttr[ctype_range_lo] = lSet
    elsif and_bits(ctype_mode,pChar_RANGE) then
        vCharAttr[ctype_range_lo..ctype_range_hi] = lSet
    else
        for i=1 to length(ctype_string) do
            vCharAttr[ctype_string[i]] = lSet
        end for
    end if
end procedure

--/topic Support routines
--/proc addToCType(object pChar,object pSet)
--/desc Adds characters to one or more sets.
--/i pChar is the character(s) to set. This can take the form of a single
-- character such as 'A', a list of characters such as "1234567890", or
-- a range of characters such as {"a", "z"}. /n
--/i pSet is either a single CharType code or a list of CharType codes. /n
global procedure addToCType(object pChar, object pSet)
    atom lSet

    sanity_CType(pChar)
    if not ctype_mode then -- invalid input
        return
    end if

    if sequence(pSet) then
        lSet = w32or_all(pSet)
    else
        lSet = pSet
    end if
    if and_bits(ctype_mode,pChar_ATOM) then
        vCharAttr[ctype_range_lo]=or_bits(vCharAttr[ctype_range_lo],lSet)
    elsif and_bits(ctype_mode,pChar_RANGE) then
        vCharAttr[ctype_range_lo..ctype_range_hi]=or_bits(vCharAttr[ctype_range_lo..ctype_range_hi],lSet)
    else
        for i=1 to length(ctype_string) do
            vCharAttr[ctype_string[i]] = or_bits(vCharAttr[ctype_string[i]],lSet)
        end for
    end if
end procedure

--/topic Support routines
--/proc removeFromCType(object pChar,object pSet)
--/desc Removes characters from one or more sets.
--/i pChar is the character(s) to set. This can take the form of a single
-- character such as 'A', a list of characters such as "1234567890", or
-- a range of characters such as {"a", "z"}. /n
--/i pSet is either a single CharType code or a list of CharType codes. /n
global procedure removeFromCType(object pChar, object pSet)
    atom lSet

    sanity_CType(pChar)
    if not ctype_mode then -- invalid input
        return
    end if

    if sequence(pSet) then
        lSet = w32or_all(pSet)
    else
        lSet = pSet
    end if
    if and_bits(ctype_mode,pChar_ATOM) then
        vCharAttr[ctype_range_lo]-=and_bits(vCharAttr[ctype_range_lo],lSet)
    elsif and_bits(ctype_mode,pChar_RANGE) then
        vCharAttr[ctype_range_lo..ctype_range_hi]-=and_bits(vCharAttr[ctype_range_lo..ctype_range_hi],lSet)
    else
        for i=1 to length(ctype_string) do
            vCharAttr[ctype_string[i]] -= and_bits(vCharAttr[ctype_string[i]],lSet)
        end for
    end if
end procedure

w32SetCType({{097},{122}}, Alpha_CT + Lowercase_CT + Printable_CT + NameChar_CT)
w32SetCType({{065},{090}}, Alpha_CT + Uppercase_CT + Printable_CT + NameChar_CT)
w32SetCType({{009},{013}}, Control_CT + White_CT)
w32SetCType({{000},{008}}, Control_CT)
w32SetCType({{014},{031}}, Control_CT)
w32SetCType({{048},{057}}, Digit_CT + Printable_CT + NameChar_CT)
w32SetCType({{033},{047}}, Punct_CT + Printable_CT)
w32SetCType({{058},{064}}, Punct_CT + Printable_CT)
w32SetCType({{091},{096}}, Punct_CT + Printable_CT)
w32SetCType({{123},{126}}, Punct_CT + Printable_CT)
w32SetCType({{127},{159}}, Symbol_CT)
w32SetCType({{161},{255}}, Symbol_CT)
w32SetCType({32,160}, White_CT + Printable_CT)
w32SetCType('_', Punct_CT + Printable_CT + NameChar_CT)


--/topic Support Routines
--/func w32Encode(sequence PlainText, sequence Mask, integer Size)
--/desc This routine transforms a string into an encoded form
--/ret SEQUENCE: A set of /i Size ascii digits.
--This creates a one way hash based on the values of /i PlainText, /i Mask and /i Size.
--/i PlainText is usually a password entered in by a user. /n
--/i Mask is anything your application wishes to use to ensure that two identical
-- /i PlainText values will generate different outputs. For example if this is
-- used for passwords, the /i Mask could be the user's ID. Thus two people that
-- just happen to have the same password cannot know that just by looking at the
-- output of this function. /n
--/i Size is the number of encoded characters you wish returned. This can be
-- any positive integer. The larger the /i Size the less chance that two different
-- /i"PlainText" - /i"Mask" combinations will generate the same output. Values
-- from /b 16 to /b 64 would be sufficient in nearly all cases.
--
--Example:
--/code
--      sequence lCode
--      lCode = w32Encode(PasswordText, UserID, 16)
--/endcode
global function w32Encode(sequence pPlainText, sequence pMask, integer pSize)
    sequence lResult
    atom lValue
    sequence lText
    sequence lMask
    sequence lDigits
    integer j
    atom lRound

    lResult = ""
    lText = sprintf("%d%d%s%s%d", {
            pSize,
            length(pPlainText),
            pPlainText,
            pMask,
            length(pMask)
                })
    lText &= reverse(lText)
    lMask = sprintf("%s%d%s%d%d%d", {
            pMask,
            length(lText),
            pPlainText,
            length(pMask)+49,
            length(pPlainText)+49,
            pSize+49
                })
    j = 0
    for i = 1 to length(lText) do
        j += 1
        if j > length(lMask) then
            j = 1
        end if
        if and_bits(lMask[length(lMask)-j+1], 1) then
            lText[i] = (lText[i] * lMask[j]) - (lText[i] / (lMask[j]))
        else
            lText[i] = (lText[i] * lText[i]) + (lMask[j] * lMask[j])
        end if
        if i > 1 then
            lText[i] += lText[i-1]
        end if
    end for
    lText[1] += lMask[length(lMask)]

    lValue = length(pPlainText) * length(pMask) * (11.76943 + (pSize + length(lText) * length(lMask)))
    lRound = length(pPlainText) + length(pMask)
    while length(lResult) < pSize do
        for i = 1 to length(lText) do
            lValue = (lValue * 723.11251) + lText[i] - lRound

            if lText[1+length(lText)-i] != 0 then
                if lValue < 1E-10 or lValue > 1E+10 then
                    lValue = (length(pPlainText) - length(lResult)) * length(pMask) * (1.76943 + pSize)
                else
                    lValue = (lValue / (lText[1+length(lText)-i]) )
                end if
            end if
        end for
        lDigits = sprintf("%.15g", lValue)
        if length(lDigits) > 2 then
            lDigits = lDigits[2..length(lDigits)-1]
        end if
        j = length(lDigits)
        while j >= 1 do
            if lDigits[j] != '0' then
                lDigits = lDigits[1..j]
                exit
            end if
            j -= 1
        end while
        j = 1
        while j <= length(lDigits) do
            if find(lDigits[j], "0123456789") = 0 then
                lDigits = lDigits[1..j-1] & lDigits[j+1..length(lDigits)]
            else
                j += 1
            end if
        end while
        if length(lDigits) > 3 then
            lResult &= lDigits[3..length(lDigits)-2]
        end if
        lValue /= 691971
        lRound *= (length(lResult) - 5.4321)
        lRound = -lRound
    end while

    return lResult[1..pSize]
end function

-------------------------------------------
--/topic Miscellaneous
--/func w32MaxWidth(object pData)
--/desc Computes the maximum width of elements of /i pData.
--/ret The maximum width.
-- The width of a string is its length. The width of an atom is the length of its
-- string representation using the %15.15g format specifier.
global function w32MaxWidth(object pData)
-------------------------------------------
    integer w
    integer n
    if atom(pData) then
        return length(w32trim(sprintf("%15.15g", pData)))
    end if

    if w32string(pData) then
        return length(pData)
    end if

    w = 0
    for i = 1 to length(pData) do
        n = w32MaxWidth(pData[i])
        if n > w then
            w = n
        end if
    end for

    return w
end function

-------------------------------------------
--/topic Miscellaneous
--/func w32ToString(object pData)
--/desc Assembles a sequence from the substrings in /i pData, separated by commas.
--/ret A sequence concatenating all substrings of /i pdata, with a comma as separator.
-- The returned sequence is enclosed between '(' and ')'.
global function w32ToString(object pData)
-------------------------------------------
    sequence ld

    if atom(pData) then
        return w32trim(sprintf("%15.15g", pData))
    end if

    if w32string(pData) then
        return pData
    end if

    ld = "("
    for i = 1 to length(pData) do
        ld &= w32ToString(pData[i])
        if i != length(pData) then
            ld &= ','
        else
            ld &= ")"
        end if
    end for
    return ld
end function

--/topic Support routines
--/func w32extract_formats(sequence s)
--/desc Determines all substrings of i s which are format specifiers
--/ret (SEQUENCE) A triple of lists: starting points, status, end points.
-- The returned lists have the same length:
--/li the first list holds the indexes of the starting '%' of the assumed format specifiers;
--/li the second list holds a 1 to mark an actual specifier, else a 0.
--/li the third list holds the terminating indexes of the assumesd format specifiers;
-- When a format specifier is succesfully parsed, its terminating index is the index of its last character.
-- Otherwise, it is the index of the first illegal character found past it starting index.
global function w32extract_formats(sequence s)
    integer pos,nextstart,fallover,stage
    sequence r1,r2,r3

    r1={} -- starting points
    r2={} -- status
    r3={} -- end points
    pos=find('%',s)
    fallover=length(s)+1
    while pos>0 and pos<length(s) do
        if s[pos+1]='%' then -- an actual percent sign, skip over it
            nextstart=pos+2
        else
            nextstart=fallover -- assume an error condition
            stage=0 -- expect +0-,1-9,valid letter
            r1&=pos
            for i=pos+1 to length(s) do
                if find(s[i],"defgosx") then -- specifier was parsed succesfully
                    r3&=i
                    r2&=1
                    nextstart=i+1
                    exit
                elsif find(s[i],"-0+") then -- must be the first format char, if there
                    if stage=0 then
                        stage=1
                    else -- invalid at this point
                        r3&=i
                        r2&=0
                        nextstart=i+1
                        exit
                    end if
                elsif s[i]>='1' and s[i]<='9' then
                    if stage<2 then -- if not seen a nonzero digit, that's our stage
                        stage=2
                    elsif stage=3 then -- there was a period, second figure (group)
                        stage=4
                    end if
                elsif s[i]='.' then
                    if stage<=2 then -- not valid after a previous period
                        stage=3
                    else
                        r3&=i
                        r2&=0
                        nextstart=i+1
                        exit
                    end if
                else -- illegal char
                    r3&=i
                    r2&=0
                    nextstart=i+1
                    exit
                end if
            end for
            -- if we didn't use one of the exit statements, nextstart is past the end of the string.
        end if
        if nextstart>=fallover then
        -- the end, because either a format started but didn't terminate, or a terminating char was the last in string
            exit
        end if
        pos=find_from('%',s,nextstart) -- move to next
    end while
    if pos=length(s) then -- string ends in '%' which is not part of a specifier
        r1&=pos
        r3&=pos
        r2&=0
    end if
    return {r1,r2,r3}
end function

object vOldSeed vOldSeed = #69F5C10D

-------------------------------------------
--/topic Miscellaneous
--/func w32rand32(atom N)
--/ret A random integer between 1 and /i N. N may be any atom representing a 32-bit integer.
global function w32rand32(atom N)
-------------------------------------------
    integer a, b
    sequence d
    atom X

    d = date()
    d = vOldSeed * d
    vOldSeed = d[1] + d[2] + d[3]
    vOldSeed += time() * (time() + 17)
    vOldSeed = floor(remainder(vOldSeed * (vOldSeed - 3), #3FFFFFFF))
    set_rand(vOldSeed)
    a = rand(#3FFFFFFF)
    vOldSeed += d[4] + d[5] + d[6]
    vOldSeed += (time() + 3.1427) * (time() + 619)
    vOldSeed = floor(remainder((vOldSeed + 1) * (vOldSeed - 1) + 1, #3FFFFFFF))
    set_rand(vOldSeed)
    b = rand(#3FFFFFFF)
    X =  and_bits(a, #FFFF) * #10000 + and_bits(b, #FFFF)
    return floor(X - floor(X/N)*N) + 1

end function

--/topic Support routines
--/func w32rectangle_delta(object r1,object r2, integer typecheck)
--/desc Determines the difference and intersection between two rectangles
--/ret (SEQUENCE) {} on failure, else {r1-r2, r1 inter r2, r2-r1}.
-- /i r1 or /i r2 may be atoms, in hich case they  are RAM addresses to peek4s() a rectangle from. /n
-- If /i r1 or /i r2 is not a sequence of four signed integers, nor an atom, then {} is returned. /n
-- If the left position is not less than the right position, or the top position is not less
-- than the bottom position, for any of the rectangles, {} is returned if typechecking was requested. /n
-- Otherwise, the returned sequence has length 3:
--/li the first element is a possibly empty list of non overlapping rectangles, whose union is
-- the part of /i r1 which lies outside /i r2.
--/li the last element is a possibly empty list of non overlapping rectangles, whose union is
-- the part of /i r2 which lies outside /i r1.
--/li the middle element is a rectangle, the intersection of /i r1 and /i r2. If the rectangles
-- don't meet, the middle element is {} (an empty rectangle).
--
-- Note that the whole type checking is performed if /i typecheck is not zero, and skipped for speed if it is zero.
--
-- All rectangles are given {left,top,right,bottom}.
global function w32rectangle_delta(object r1,object r2,integer typecheck)
    sequence result,inter,rect
    integer other_edge

    if typecheck then
        -- type check r1
        if sequence(r1) then
            if length(r1)!=4 then
                return {}
            end if
            for i=1 to 4 do
                if not integer(r1[i]) then
                    return {}
                end if
            end for
        else
            r1=peek4s({r1,4})
        end if
        if r1[1]>=r1[3] or r1[2]>=r1[4] then
            return {}
        end if

        -- type check r2
        if sequence(r2) then
            if length(r2)!=4 then
                return {}
            end if
            for i=1 to 4 do
                if not integer(r2[i]) then
                    return {}
                end if
            end for
        else
            r2=peek4u({r2,4})
        end if
        if r2[1]>=r2[3] or r2[2]>=r2[4] then
            return {}
        end if

    else -- no type checking, we know wat we're doing, by gum!
        if atom(r1) then
            r1=peek4s({r1,4})
        end if
        if atom(r2) then
            r2=peek4s({r2,4})
        end if
    end if

    -- intersection is empty, early return
    if r1[1]>r2[3] or r1[3]<r2[1] or r1[2]>r2[4] or r1[4]<r2[2] then
        return {{r1},{},{r2}}
    end if

    -- initialise
    result={{},0,{}}
    inter=r1

    if r1[1]<r2[1] then
    -- r1 contributes to the r1-r2 part if its left edge is left of r2's
        rect=r1
        other_edge=r2[1]
        rect[3]=other_edge
        result[1]=append(result[1],rect)
        r1[1]=other_edge
        inter[1]=other_edge
    elsif r1[1]>r2[1] then
    -- r2 contributes to the r2-r1 part if its left edge is left of r1's
        rect=r2
        other_edge=r1[1]
        rect[3]=other_edge
        result[3]=append(result[3],rect)
        r2[1]=other_edge
    end if

    -- and so on for the other three edges
    if r1[2]<r2[2] then
        rect=r1
        other_edge=r2[2]
        rect[4]=other_edge
        result[1]=append(result[1],rect)
        r1[2]=other_edge
        inter[2]=other_edge
    elsif r1[2]>r2[2] then
        rect=r2
        other_edge=r1[2]
        rect[4]=other_edge
        result[3]=append(result[3],rect)
        r2[2]=other_edge
    end if

    if r1[3]>r2[3] then
        rect=r1
        other_edge=r2[3]
        rect[1]=other_edge
        result[1]=append(result[1],rect)
        r1[3]=other_edge
        inter[3]=other_edge
    elsif r1[3]<r2[3] then
        rect=r2
        other_edge=r1[3]
        rect[1]=other_edge
        result[3]=append(result[3],rect)
        r2[3]=other_edge
    end if

    -- no need to change r1 or r2 here, as they are not used in the sequel
    if r1[4]>r2[4] then
        rect=r1
        other_edge=r2[4]
        rect[2]=other_edge
        result[1]=append(result[1],rect)
        inter[4]=other_edge
    elsif r1[4]<r2[4] then
        rect=r2
        other_edge=r1[4]
        rect[2]=other_edge
        result[3]=append(result[3],rect)
    end if

    -- inter has gathered the innermost values for all four edges
    result[2]=inter
    return result
end function

-- w32memory.ew

--------------------NOTICE-------------------------------*
-- Software ID: w32memory.ew
-- Version:     0.70.4a
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*

--/topic Memory management
--/info
--Routines to allocate, use, and release of Random Access Memory (RAM).
--Normally, a Euphoria program doesn't have to worry about this as it is handled quietly
-- in the background. However, when working with external systems, such as the Windows API,
-- the coder often needs to explicitly manage RAM as resource, primarily when sharing data
-- between your application and Windows. /n/n
--
-- How the structure engine works.
-- Memory structures are a set of fields. You define a structure by calling /w32allot()
-- passing the fields in sequence, and retrieving a field descriptor which can be used
-- to access the field. When done, call the /w32allotted_size(). This function does two things:
--/li It returns the size of the structure, or at least its fixed stub size (read below).
--/li As a side effect, it /b "registers the structure template you just defined" and
-- cleans up so as to possibly start another structure definition later.
-- In addition, you can define a structure identifier. This is returned by /w32define_this_struct(),
-- and is used by the bulk load/store routines.
-- w32define_this_struct() is also useful to define shorter variants of a maximal structure.
-- For instance, Windows XP uses more fields than Windows 98 in some cases. You don't need
-- to define two different structures: just insert a w32define_this_struct() call at the
-- "break points" so as to retrieve structure ids for the various versions.
-- /n
-- Variable length members.
-- Some Windows API structure include arrays or strings of variable length. In that case,
-- only the length of the part of the structure preceding the first variable length field
-- is known and reported. The library supports a wide range of schemes and special alignment fields
-- to deal with these beasts. Please read further under /w32allot().
-- /n
-- Unions are also supported. The only limitation is that no alternative field description
-- can be a union itself. Read further under /w32define_union().

constant
krnl32      = open_dll( "kernel32.dll" ),
xIsBadWritePtr = define_c_func(krnl32, "IsBadWritePtr", {C_LONG, C_LONG}, C_LONG),
xIsBadReadPtr = define_c_func(krnl32, "IsBadReadPtr", {C_LONG, C_LONG}, C_LONG),
--xIsBadCodePtr = define_c_func(kernel32, "IsBadReadPtr", {C_LONG, C_LONG}, C_LONG),
_lstrlen      = define_c_func(krnl32,"lstrlen",{C_POINTER},C_INT),
_lstrlenw     = define_c_func(krnl32,"lstrlenW",{C_POINTER},C_INT)


-- stores abort handler's routine id
integer  vAbortRtn  vAbortRtn  = -1

-- The number of allocations
integer vAllocations vAllocations = 0
sequence vExtraCare vExtraCare = {}

-- List of memset ids
sequence vOwners vOwners = {}

-- List of address sets. Each set has a list of addresses.
sequence vSets   vSets = {}

-- stores the accumulated size of a structure as it is being defined.
integer  vAllotted  vAllotted  = 0

-- This is added to calls to alloc.
integer vSafetyBuffer vSafetyBuffer = 4

--/topic Memory Management
--/Var w32UsingSafeCode
--/desc Determines whether or not the 'safe' versions of peek and poke are used.
--This is primarily as debugging aid. You only need to set this if you suspect
--that your program is causing memory corruptions or accessing strange locations.
--
-- Set this to zero to turn off the safe versions..
--
-- The initial setting is 0. That is, the safe versions are not being used.
--
--Example:
--/code
--     --Ensure I can change RAM safely
--     w32UsingSafeCode = 1
--     l_SafePoke4( adr, 0)
--/endcode

global integer w32UsingSafeCode w32UsingSafeCode = 0

--/topic Memory Management
--/func w32llSetAbort( i )
--/desc Possibly sets the routine id of an Abort routine.
--/ret The previous value set.
--
-- Used to indicate if an error routine needs to be
-- called in the event of a catastophic error.
-- The error routine is assumed to be a procedure
-- that accepts a single sequence (typically an
-- message string). /n
-- Use -1 to remove the handler. Use any sequence to simply return the handler.
--
-- Example:
--
-- /code
--      integer RtnID, OldID
--      RtnID = routine_id("abortErr")
--      OldID = w32llSetAbort(RtnID)
-- /endcode

global function w32llSetAbort(object i)
-- Set the abort handler id. The routine must take two parameters,
-- a sequence (msg) and a integer (mode ==> 1=warning, 2=fatal)
    integer lOldRtn

    lOldRtn = vAbortRtn

    if atom(i) then
        vAbortRtn = i
    end if

    return lOldRtn
end function


procedure l_MyFreeMem(atom pAddress)
    object VOID
    integer lPosn

    if c_func(xIsBadWritePtr, {pAddress, 1}) then -- not a valid address, or not suitable to free
        return
    end if

    -- Check if this addr needs extra care checking.
    lPosn = find(pAddress, vExtraCare)
    if lPosn != 0 then
        pAddress -= 16
        if peek4u(pAddress) != pAddress or
           peek4u(pAddress+4) != pAddress + 4 or
           peek4u(pAddress+8) != #C0D0E0F0 or
           peek4u(pAddress+12) != #8899AABB then
               -- The area prior to the users RAM was corrupted.
                if vAbortRtn >= 0 then
                    call_proc(vAbortRtn, {
                                sprintf("Corrupted RAM at address %d.", pAddress)} )
                else
                    crash_message(sprintf("Corrupted RAM at address %d.", pAddress))
                    VOID = 0/0 -- Force a crash
                end if
        end if
        -- Remove it from the list.
        vExtraCare = vExtraCare[1..lPosn-1] & vExtraCare[lPosn+1..length(vExtraCare)]
    end if

    pAddress -= 4

    vAllocations -= 1

    free(pAddress)
    return

end procedure

 function l_MyAllocate(integer pSize)
    atom lAddr
    atom lPreSize
    integer lMemSize



    if w32UsingSafeCode != 0 then
        lPreSize = 16
    else
        lPreSize = 0
    end if

    -- Add some bytes for a safety buffer
    lMemSize = lPreSize + pSize + 4 + vSafetyBuffer
    lAddr = allocate(lMemSize)

    if lAddr != 0 then
        mem_set( lAddr, 0, lMemSize)

        vAllocations += 1


        -- Save total size for later reuse.
        poke4(lAddr, lMemSize)
        lAddr += 4

        -- If being safe, add this address to the extra care list,
        -- so that the free() can see if nothing was messed up.
        if lPreSize != 0 then
            lPreSize = lAddr
            lAddr += 16
            vExtraCare &= lAddr
            poke4(lPreSize, {lPreSize, lPreSize+4, #C0D0E0F0, #8899AABB})
        end if
    end if

    return lAddr
end function


--/func l_SafePeek(object addr)
--/desc This is an enhanced version of Euphoria's peek() function
--/ret see peek() for details.
--If /i w32UsingSafeCode is not zero, this does a memory access check first.

 function l_SafePeek(object addr)
    atom a, l
    if w32UsingSafeCode = 0 then
        return peek(addr)
    end if

    if sequence(addr) and length(addr) = 2 and atom(addr[1]) and atom(addr[2]) then
        l = addr[2]
        a = addr[1]
    else
        a = addr
        l = 1
    end if

    if c_func(xIsBadReadPtr, {a,l}) = 0 then
        return peek(addr)
    else
        if vAbortRtn >= 0
        then
            call_proc(vAbortRtn, {
                        sprintf("Peek at address %d for length %d failed.",
                                    {a,l})} )
            return 0 -- Just in case the abort does not crash program.
        else
            if object(addr) then
                return {}
            else
                return 0
            end if
        end if
    end if
end function


--/func l_SafePeek4s(object addr)
--/desc This is an enhanced version of Euphoria's peek4s() function
--/ret see peek4s() for details.
--If /i w32UsingSafeCode is not zero, this does a memory access check first.
 function l_SafePeek4s(object addr)
    atom a, l

    if w32UsingSafeCode = 0 then
        return peek4s(addr)
    end if


    if sequence(addr) and length(addr) = 2 and atom(addr[1]) and atom(addr[2]) then
        l = addr[2] * 4
        a = addr[1]
    else
        a = addr
        l = 4
    end if

    if c_func(xIsBadReadPtr, {a,l}) = 0 then
        return peek4s(addr)
    else
        if vAbortRtn >= 0
        then
            call_proc(vAbortRtn, {
                        sprintf("Peek4s at address %d for count of %d failed.",
                                    {a,l/4})} )
            return 0 -- Just in case the abort does not crash program.
        else
            if object(addr) then
                return {}
            else
                return 0
            end if
        end if
    end if
end function

--/func l_SafePeek4u(object addr)
--/desc This is an enhanced version of Euphoria's peek4u() function
--/ret see peek4u() for details.
--If /i w32UsingSafeCode is not zero, this does a memory access check first.
 function l_SafePeek4u(object addr)
    atom a, l

    if w32UsingSafeCode = 0 then
        return peek4u(addr)
    end if


    if sequence(addr) and length(addr) = 2 and atom(addr[1]) and atom(addr[2]) then
        l = addr[2] * 4
        a = addr[1]
    else
        a = addr
        l = 4
    end if

    if c_func(xIsBadReadPtr, {a,l}) = 0 then
        return peek4u(addr)
    else
        if vAbortRtn >= 0
        then
            call_proc(vAbortRtn, {
                        sprintf("Peek4u at address %d for count of %d failed.",
                                    {a,l/4})} )
            return 0 -- Just in case the abort does not crash program.
        else
            if object(addr) then
                return {}
            else
                return 0
            end if
        end if
    end if
end function

--/func l_SafePoke(object addr)
--/desc This is an enhanced version of Euphoria's poke() function
--/ret see poke() for details.
--If /i w32UsingSafeCode is not zero, this does a memory access check first.
 procedure l_SafePoke(atom addr, object thedata)
    atom lBytes

    if w32UsingSafeCode = 0 then
        poke(addr, thedata)
        return
    end if


    if sequence(thedata) then
        lBytes = length(thedata)
    else
        lBytes = 1
    end if

    if c_func(xIsBadWritePtr, {addr,lBytes}) = 0 then
        poke(addr, thedata)
    else
        if vAbortRtn >= 0
        then
            call_proc(vAbortRtn, {
                        sprintf("Poke at address %d for length of %d failed.",
                                    {addr,lBytes})} )
            return -- Just in case the abort does not crash program.
        end if
    end if
end procedure

--/func l_SafePoke4(object addr)
--/desc This is an enhanced version of Euphoria's poke4() function
--/ret see poke4() for details.
--If /i w32UsingSafeCode is not zero, this does a memory access check first.
 procedure l_SafePoke4(atom addr, object thedata)
    atom lBytes

    if w32UsingSafeCode = 0 then
        poke4(addr, thedata)
        return
    end if


    if sequence(thedata) then
        lBytes = length(thedata) * 4
    else
        lBytes = 4
    end if

    if c_func(xIsBadWritePtr, {addr,lBytes}) = 0 then
        poke4(addr, thedata)
    else
        if vAbortRtn >= 0
        then
            call_proc(vAbortRtn, {
                        sprintf("Poke4 at address %d for count of %d failed.",
                                    {addr,lBytes/4})} )
            return -- Just in case the abort does not crash program.
        end if
    end if
end procedure

--/topic Memory management
--/func w32peek2(object pos)
--/desc Retrieves a sequence of double byte encoded characters as a regular sequence
--/ret (OBJECT) A sequence where each element represents two contiguous bytes, lowest weight at lowest address.
-- If pos is a {address,length} sequence, a sequence is returned. If /i pos is a
-- single atom, the 16-bit word at that address is returned.

global function w32peek2(object pos)
    atom a
    integer odd,n
    sequence result

    if atom(pos) then  -- peek single word
        return peek(pos)+256*peek(pos+1)
    else -- peek {at address, how many words}
        a = pos[1]
        n = pos[2]
        odd = and_bits(n,1)
        result = repeat(0,n)
        for i=1 to n-odd-1 by 2 do  -- peek dwords for speedup
            result[i..i+1]=w32unpack_dword(l_SafePeek4u(a))
            a+=4
        end for
        if odd then
            result[n] = peek(a)+256*peek(a+1)
        end if
        return result
    end if
end function

--/topic Memory Management
--/func w32peek_string( address )
--/desc Get sequence from address holding C-style string.
--/ret SEQUENCE: containing the C-style string.
-- This is typically done automatically by the /fetch
-- function. Note that this will not work with UTF-16 encoded strings.
--
-- Example:
--
--/code
--      -- get a C-string from address
--      sequence s
--
--      s = /w32peek_string( address )
--/endcode
global function w32peek_string(atom a)
-- V0.56 Al Getz
    integer l
    sequence s

    -- Only deal with non-zero addresses
    if a then
        l = c_func(_lstrlen,{a})
        s = l_SafePeek({a, l})
    else
        s = {}
    end if

    -- send back all the bytes found.
    return s

end function

--/topic Memory management
--/func w32peek_string16(atom addr)
--/desc Returns a 0000 terminated DBCS encoded string starting at /i addr.
--/ret (SEQUENCE) A sequence of integers, all of them in the 0-65535 range.
global function w32peek_string16(atom addr)
    sequence result
    integer p,q

    if not addr then
        return {}
    end if
    p = c_func(_lstrlenw,{addr})
    if p<=0 then
        return {}
    end if
    result=peek({addr,2*p})
    q=1
    for i=1 to p do
        result[i]=result[q]+256*result[q+1]
        q+=2
    end for
    return result[1..p]
end function

atom vPermMemSet_

function vPermMemSet()
    return vPermMemSet_
end function


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Memory Management memory management Routines
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

--/topic Memory Management
--/func w32manage_mem( atom Owner, object Address)
--/desc Records an acquired memory for garbage collection.
-- Normally this is handled automatically by /w32acquire_mem() but if you
-- are expected to manage some memory acquired by another means, such as
-- a Windows call or a 'C' routine, you can use this to record the memory for
-- subsequent release by /w32release_mem(). If Address is a sequence, it is a sequence of addresses to manage.
--
-- Example:
-- /code
--      atom mset, pt, pstr
--
--      -- Establish a new memory set.
--      mset = /w32new_memset()
--      -- calls a routine which returns a structure address.
--      pt = c_func( xyz, {abc})
--      -- register this memory
--      w32manage_mem(mset, pt)
--      . . .
--      give all the memory area in 'mset' back
--      w32release_mem(mset)
-- /endcode

global procedure w32manage_mem( atom pOwner, object pAddr )
    -- save location for garbage collection
    -- This also is used to move a block from one memset to another.
    integer lOwnerSub, lAddrSub

    if sequence(pAddr) then
        for i=1 to length(pAddr) do
            w32manage_mem(pOwner,pAddr[i])
        end for
        return
    end if
    -- Take the address out of any existing memset.
    lAddrSub = 0
    if pOwner = -2 then
        pOwner = vPermMemSet()
    end if
    for i = 1 to length(vSets) do
        lAddrSub = find(pAddr, vSets[i])
        if lAddrSub != 0 then
            vSets[i] = w32removeIndex(lAddrSub, vSets[i])
            exit
        end if
    end for

    -- Create a new memset if required.
    lOwnerSub = find(pOwner, vOwners)
    if lOwnerSub = 0 then
        vOwners &= pOwner
        lOwnerSub = length(vOwners)
        vSets = append(vSets, {})
    end if

    -- Store the address into the specified memset
    vSets[lOwnerSub] &= pAddr
end procedure

-----------------------------------------------------------------------------

--/topic Memory Management
--/proc w32release_mem( atom structure )
--/desc Returns the memory allocated by /w32acquire_mem() back to the system.
-- If /i structure is a memory set id, as returned by /w32new_memset(), then
-- all the memory owned in the memory set is returned and the memory set id
-- is released. That is, it cannot be reused. /n
-- If /i structure is a memory address returned by /w32acquire_mem(), then just
-- that memory is released. The memory set it belonged to is still usable.
--
-- Example:
-- /code
--      atom mset, pt, pstr
--
--      -- Establish a new memory set.
--      mset = /w32new_memset()
--      -- get enough memory to hold a UInt datatype
--      xy = /w32acquire_mem( UInt )
--      -- allocate a point structure
--      pt = /w32acquire_mem( mset, SIZEOF_POINT )
--      -- copy a Euphoria string to a 'C' string area.
--      pstr = /w32acquire_mem( mset, "My String Data" )
--      . . .
--      give all the memory area in 'mset' back
--      w32release_mem(mset)
-- /endcode

global procedure w32release_mem( atom pData )
    integer lOwnerSub
    integer lAddrSub, lAddrList
    integer ls, ss, Phase1
    sequence sets

    -- Check for "special" uninitialized memset value.
    if pData = -1 then
        return
    elsif pData = -2 then
        pData = vPermMemSet()
    end if

    -- See if this is a memset owner.
    lOwnerSub = find(pData, vOwners)

    if lOwnerSub = 0 then
        -- If not a memset, see which memset it belongs to.
        lAddrSub = 0
        for i = 1 to length(vSets) do
            lAddrSub = find(pData, vSets[i])
            if lAddrSub != 0 then
                lAddrList = i
                exit
            end if
        end for

        if lAddrSub = 0 then
            -- Not in any memset!
            if vAbortRtn >= 0 then
                call_proc(vAbortRtn, {"Trying to release unacquired memory"})
                return
            end if

        else
            -- Remove it from the memset
            vSets[lAddrList] = w32removeIndex(lAddrSub,
                                           vSets[lAddrList])
            -- Give the memory back to the system
            l_MyFreeMem(pData)
        end if

        return
    end if

    --
    sets = {pData}
    ss   = 1

    -- Phase 1: Identified the complete hierarchy of owned memory sets.
    Phase1 = 1
    while Phase1 do
        ls = length(sets)
        for i = ss to ls do
            lOwnerSub = find(sets[i], vOwners)
            for j = 1 to length(vSets[lOwnerSub]) do
                lAddrSub = find(vSets[lOwnerSub][j],
                                vOwners)
                if lAddrSub != 0 then
                    sets &= vOwners[lAddrSub]
                end if
            end for
        end for
        ss = ls + 1
        Phase1 = (ls != length(sets))
    end while

    -- Phase 2: Free the memory addresses.
    for i = length(sets) to 1 by -1 do
        lOwnerSub = find(sets[i], vOwners)
        for j = 1 to length(vSets[lOwnerSub]) do
            if vSets[lOwnerSub][j] != 0 then
                l_MyFreeMem(vSets[lOwnerSub][j])

            end if
        end for
    end for
    if sets[1] != 0 then
        l_MyFreeMem(sets[1])

    end if

    -- Phase 3: - clean up the allocation array
    for i = 1 to length(sets) do
        lOwnerSub = find(sets[i], vOwners)
        if lOwnerSub > 0 then
            vSets = w32removeIndex(lOwnerSub, vSets)
            vOwners = w32removeIndex(lOwnerSub, vOwners)
        end if
        for j = 1 to length(vSets) do
            lOwnerSub = find(sets[i], vSets[j])
            if lOwnerSub != 0 then
                vSets[j] = w32removeIndex(lOwnerSub,
                                         vSets[j])
                exit
            end if
        end for
    end for

end procedure

global constant
    Align   = -17,
    Byte    = -1,
    Int8    = Byte,
    Word    = -2,
    Integer = Word,
    Int16   = Word,
    Long    = -3,
    DWord   = Long,
    Int32   = Long,
    Lpsz    = -4,
    Hndl    = -5,
    HndlAddr = -6,
    Strz    = -7,
    UInt    = -8,
    Ptr     = UInt,
    ULong   = UInt,
    Single  = -9,
    Float   = Single,
    Double  = -10,
    Upsz    = -11,
    Ustrz   = -12,
    asBuffer= -13,
    usBuffer= -14,
    aszText = -16,
    uszText = -15,
    Point   = -18,
    Rect    = -19,
    ByteFill= -20,
    AlignRel= -21

constant vSizeNames = {Byte, Word, Long, Lpsz, Hndl, HndlAddr, Strz, UInt, Single, Double, Upsz, Ustrz, asBuffer, usBuffer, Align, aszText, uszText, Rect, Point, ByteFill, AlignRel}
constant vSizeLengs = {   1,    2,    4,    4,    4,        4,    1,    4,      4,      8,    4,     4,        8,        8,    -1,      -1,      -1,   16,     8,        1,        1}
constant vIsVirtual = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0}
constant vFillers = {Align, ByteFill, AlignRel}

global constant
    SIZEOF_Long = 4,
    SIZEOF_Word = 2
--------- Structure management with variable length members -------------
-- hereby called "virtual"

sequence vStructSizes         -- sizes of all structures; only the initial fixed part when there are vlm's
vStructSizes={}
sequence vFirstVirtualFields  -- # of first virtual field or 0
vFirstVirtualFields={}
sequence vLayouts             -- sequence of field sequences
vLayouts={}
sequence vNumAligns           -- number of align fields in structure
vNumAligns={}
sequence vPreprocessDataIn    -- routine_id called by w32to_memory before writing data to this sort of structure
vPreprocessDataIn={}

sequence vStartWithSize       -- 1 if fixed size is first field. This optimises w32to_memory()
vStartWithSize={}

-- temp data used while building a structure
sequence vLayout          -- current sequence of fields
vLayout={}
integer vNumField         -- number of the current field, if any
vNumField=0
integer vNumVirtual       -- index of the first virtual field, if any
vNumVirtual=0
integer vNumAlign         -- index of first alignment field, if any
vNumAlign=0

-- union description
sequence unionVariants    -- lists of field variants for unions
unionVariants={}
sequence unionSelectors   -- list of selector routine_ids for unions
unionSelectors={}
sequence unionDataInfer   -- list of routine ids to call when assessing how to store data
unionDataInfer={}

-- structures holding virtualisation data for structs with variable length fields,
-- unions not supported yet
sequence virtualStructs       -- base addresses of structs which have a variable member
                              -- and which were accessed
virtualStructs = {}
sequence virtualWasBlank      -- 1 if struct created thru w32acquire_mem()
virtualWasBlank={}
sequence virtualTypes         -- master type of the structure
virtualTypes={}
sequence virtualFields        -- field data for fields whose addr is known, for each struct
virtualFields={}
sequence virtualAddresses     -- addr (relocated or not) for these fields
virtualAddresses={}
sequence virtualSizes         -- global size of fields
virtualSizes={}
sequence virtualStatus        -- global status of fields
virtualStatus={}   -- 0=fixed, -1=untouched, 1=relocated
sequence virtualOrgAddresses  -- initial field addresses
virtualOrgAddresses={}
sequence virtualIndAddresses   -- current addr or set of addr
virtualIndAddresses={}
sequence virtualIndStatus      -- current status or set of status
virtualIndStatus={}
sequence virtualIndOrgAddresses  -- initial address or set of addresses
virtualIndOrgAddresses={}
sequence virtualIndSizes       -- current size or set of sizes
virtualIndSizes={}
sequence virtualUnions      -- selector for virtual fields which are unions
virtualUnions={}

-- fields of a structure field definition
constant
        numField  = 1,    -- order of current field in current master structure
        fieldOffset = 2,  -- base fieldOffset, or {} when there's any variable length foeld before in the struct
        fieldType = 3,    -- type of elementary unit in this field
        arrayCount = 4,   -- # of units in the field,or field desc, or terminator string
        strType = 5,      -- id of the maximal structure this field belongs to
        isVirtual = 6,    -- 0 if not, 1 if it is vlm, -1 if it is only vpm
        unitSize = 7,     -- size of an unit, or -1 if variable
        unionSpec = 8,    -- selector for a union type structure
        stdFieldEntry = 8,-- entries which don't refer to an array position stop here
        arrayPos = 9,     -- 1 based position/slice start in array, when present
        arrayEndSlice = 10-- 1 based end of slice, if present

constant  -- format of a short structure descriptor. A structure descriptor is just {{type}}.
        descType = 1,
        descSize = 2,
        descNumFields = 3,
        descNumAligns = 4


function check_array(sequence s)
-- returns true if, in the field definition s, a position/slice is valid, else false
-- all relevant fields must resolve to integers
    if length(s)<=stdFieldEntry then
        return s[arrayCount]
    elsif not integer(s[arrayPos]) or s[arrayPos]<1 or s[arrayPos]>s[arrayCount] then
        return 0
    elsif length(s)=arrayPos then
        return 1
    elsif not integer(s[arrayEndSlice]) or s[arrayEndSlice]<s[arrayPos] or s[arrayEndSlice]>s[arrayCount] then
        return 0
    else
        return s[arrayEndSlice]-s[arrayPos]+1
    end if
end function

-- series.e  v1.0 17/July/2002, Derek Parnell
-- A set of routines to manage sets of sequential unique numbers.
--
-- Contains the following routines:
--      next_number(name)              Returns the next number in a
--                                        named series.
--      current_number(name)           Returns the number returned
--                                        by the most recent call to
--                                        next_number()
--      define_series(name, attrvals)  Used to initialise or reset
--                                        a series' attributes.
--      get_series(name)               Returns the current attributes
--                                        of a series


-----------------------------------------------
-- FUNCTION: next_number(object Name)
--  RETURNS: The next number in the series.
--  PARAMETERS:
--    Name      Can be any Euphoria object. Each series has a unique
--              name of your choosing.
--  ACTIONS:
--  *If the series named does not exist, this creates a new series with
--   the default attributes. And if for some reason it cannot create a
--   new series, it returns immediately with an empty sequence.
--  *Calculates the next number.
--  *If the series is a 'wrapping' type, and the next number is beyond
--   the last number for the series, the next number is set to the
--   series' first number.
--
--  EXAMPLE:
--      -- Define the record layout for Customer.
--      constant CustID    = next_number("CustRecord"),
--               CustName  = next_number("CustRecord"),
--               CustAddr  = next_number("CustRecord"),
--               CustPhone = next_number("CustRecord"),
--               SIZEOF_Cust = current_number("CustRecord")
--
--      lNewRecord = repeat(0, SIZEOF_Cust)
--      lNewRecord[CustID] = next_number("custid")

-----------------------------------------------
-- PROCEDURE: define_series(object Name, sequence Values)
--  PARAMETERS:
--    Name      Can be any Euphoria object. Each series has a unique name
--              of your choosing.
--    Values    Is a list of zero or more attribute-value pairs.
--  ACTIONS:
--  *If the series named does not exist, this creates a new series with
--   the default attributes.
--  *Then for each attribute-value pair, it sets the series' attribute
--   to the value supplied. Invalid attributes and values are ignored.
--  The attributes of a series are:
--      SValue      ATOM: The next number to be returned. Default: 1.
--      SIncr       ATOM: The increment used to calculate the new next
--                        number. Can be negative. Default: 1.
--      SWrap       INTEGER: If the series is a wrapping type, this
--                        should be True. Default: False
--      SFirst      ATOM: The first number to be used in the series.
--                        Default: 1
--      SLast       ATOM: The last number to be used in the series.
--                        Default: 0
--      SRtnId      INTEGER: A routine_id of a callback routine or
--                        -1. Default: -1
--      SUserData   OBJECT: Not used by these routines. It is passed
--                        unchanged to the callback routine. Default: 0
--
--  Note, when you use this routine to set the Value attribute, the
--  value is not actually reset until the next call to next_number().
--
--  Callback Routine.
--      If defined for a series, the callback routine is invoked just
--      prior to returning from a next_number() or current_number() call.
--      The callback routine receives five parameters:
--       object: The series name
--       object: The type of callback. Either SCB_NextNum or SCB_CurrentNum
--       atom: For SCB_NextNum this is the next value in the series,
--             for SCB_CurrentNum this is the previous value returned.
--       integer: Wrapped flag. Only used for SCB_NextNum. If True,
--             it means that the value has come about because the
--             series has wrapped around from Last to First values.
--       object: The user data. This is passed unaltered from the
--             define_series() call that set it.
--  The callback routine must return something. Whatever it returns
--  is passed back unaltered to the application in place of the normal
--  value.
--
--
--  EXAMPLE:
--      -- Customer IDs start at 60001. Use a checkdigit routine to
--      -- adjust the returned value.
--      define_series("cust", { {SValue, 60001},
--                              {SRtnId, routine_id(GenCheckDigit)},
--                              {SUserData, 11} } )
--      NextCustID = next_number("cust")
--
--      define_series("row", { {SValue,1}, {SWrap,True},
--                             {SFirst,1}, {SLast,24} } )
--      define_series("col", { {SValue,1}, {SWrap,True},
--                             {SFirst,1}, {SLast,80} } )
--      . . .
--      while True do
--          k = GetKeyCode()
--          if k != prevcode then
--              if k = Up then
--                defines_series("row", { {SIncr, -1} } )
--                defines_series("col", { {SIncr, 0} } )
--              elsif k = Down then
--                defines_series("row", { {SIncr, 1} } )
--                defines_series("col", { {SIncr, 0} } )
--              elsif k = Left then
--                defines_series("col", { {SIncr, -1} } )
--                defines_series("row", { {SIncr, 0} } )
--              elsif k = Right then
--                defines_series("col", { {SIncr, 1} } )
--                defines_series("row", { {SIncr, 0} } )
--              end if
--              prevcode = k
--          end if
--
--          c = next_number("col")
--          r = next_number("row")
--          . . .
--      end while
--
--      define_series("angle", { {SValue,0}, {SFirst,0}, {SLast,2*PI},
--                               {sIncr,0.1}, {SWrap,True} } )
--      . . .
--      Plot (next_number("angle"))

-----------------------------------------------
-- FUNCTION: get_series(object Name)
--  RETURNS: A list of attribute-value pairs. If the series doesn't
--           exist, an empty sequence is returned.
--  PARAMETERS:
--    Name      Can be any Euphoria object. Each series has a unique
--              name of your choosing.
--  ACTIONS:
--      If the named series doesn't exist, return an empty sequence.
--      Build a list of attributes and their values.
--      Return the attribute-value pair list.

-----------------------------------------------
-- FUNCTION: current_number(object Name)
--  RETURNS: The previous number returned in the series.
--  PARAMETERS:
--    Name      Can be any Euphoria object. Each series has a unique
--              name of your choosing.
--  ACTIONS:
--  If the series named does not exist, this returns an empty sequence..
--  Returns the current value.
--
--  EXAMPLE:
--       procedure AddNewCustomer()
--           NextID = next_number("cust")
--            . . .
--       end procedure
--       . . .
--      AddNewCustomer()
--      -- Get the ID that was just used.
--      CustID = current_number("cust")


--/topic Series
--/info
--Some utility routines to manange series of numbers.
--
--A Series is just a set of numbers that you use when you need a set of sequential
-- values.
--
--Example:
--/code
--    constant fldA = next_number("My Series")
--    constant fldB = next_number("My Series")
--    constant fldC = next_number("My Series")
--    constant fldD = next_number("My Series")
--    constant fldE = next_number("My Series")
--    constant NumFlds = current_number("My Series")
--/endcode
-- This would give the constants fldA - fldE the values 1 to 5 respectively, and the NumFlds is set to
-- 5 as well.
--
--By default, a Series starts at 1 and increments by 1 with each call to /next_number().
-- However, you may define a special series to suit particular needs. You can change the
-- increment amount, the starting value, and whether the series wraps around when getting
-- to the end.
--
--Example:
--/code
--      -- Define a set of angles from 0 to 2PI, incrementing by 0.1.
--      -- And when the last angle is reached, start again at zero.
--      define_series("angle", { {SValue,0}, {SFirst,0}, {SLast,2*PI},
--                               {sIncr,0.1}, {SWrap,True} } )
--/endcode
--
--If you have very special requirements, you can even define a routine_id that
-- will be called when the user calls next_number and current_number. You can then
-- make decisions about the value returned to the user; for example you may need to
-- update a database whenever the user gets a new series value, or maybe you need to
-- encrypt it before the user gets it, or convert it text, etc...
--
--/code
--      define_series("special", { {sRtnId,routine_id("SeriesChecker")}, {SUserData,Tolerance} } )
--/endcode
--
--The routine mentioned here will be called with five (5) parameters:
--/li /i "object pName" : The name of the series.
--/li /i "integer pRequest" : Either SCB_CurrentNum or SCB_NextNum which is the type of request that
-- the user is asking for.
--/li /i "atom pValue" : The series' current value.
--/li /i "integer pHasWrapped" : Either 0 (false) or 1 (true) indicating whether or not the series /b just
-- wrapped around to the start again.
--/li /i "object pUserData" : The user data stored in the series by the last define_series() call to it.
--
-- The value returned by this routine will be passed directly to the user.

global constant
        SValue          = 'v',
        SIncr           = 'i',
        SWrap           = 'w',
        SFirst          = 'f',
        SLast           = 'l',
        SRtnId          = 'r',
        SUserData       = 'u',
        SCB_NextNum     = 'N',
        SCB_CurrentNum  = 'C'

constant
        kSFlds       = {  SIncr,SWrap,SFirst,SLast,SValue,SRtnId,SUserData},
        kEmptySeries = {0,    1,    0,     1,    0,    {},    -1,        0},
        kSValue      = 1, -- Always the first field
        kSResetValue = find(SValue,   kSFlds) + 1,
        kSIncr       = find(SIncr,    kSFlds) + 1,
        kSWrap       = find(SWrap,    kSFlds) + 1,
        kSFirst      = find(SFirst,   kSFlds) + 1,
        kSLast       = find(SLast,    kSFlds) + 1,
        kSRtnId      = find(SRtnId,   kSFlds) + 1,
        kSUserData   = find(SUserData,kSFlds) + 1

sequence vDefnSeries        -- Names of series
sequence vSeriesData        -- Attribute-set per series
vDefnSeries = {}
vSeriesData = {}

--/topic Series
--/proc define_series(object pName, sequence pAttributes)
--/desc Defines a new series.
--Normally one doesn't need to define a series as a default series is created
-- one the first call of /next_number(). However, if you have special requirements
-- this routine will help customize a series for you.
--
--/i pName is the user-defined name for this series.
--/i pAttributes is a set of zero or more attribute/value pairs to apply to this series.
--
--Valid attributes are : /n
--/li /b SValue : Only used when resetting a series to a defined value.
--/li /b SIncr : The amount to increment the series by. Default is 1.
--/li /b SWrap : Indicator that the series can wrap from last to first. Default is 0 (no wrap).
--/li /b SFirst : The first value in the series. Default is 1.
--/li /b SLast : The last value in the series. Default is 0. If wrapping, this is the value that triggers the wrap.
--/li /b SRtnId : A routine_id that is called when /next_number() and /current_number() are just about to
-- return a value to the user.
--/li /b SUserData : Any user data you wish to be passed back to the routine_id. Default is {}.
--Example:
--/code
--      -- Define a set of angles from 0 to 2PI, incrementing by 0.1.
--      -- And when the last angle is reached, start again at zero.
--      define_series("angle", { {SValue,0}, {SFirst,0}, {SLast,2*PI},
--                               {sIncr,0.1}, {SWrap,True} } )
--/endcode

-----------------------------------------------
global procedure define_series(object pName, sequence pValues)
-----------------------------------------------
    integer lID
    integer lFld

    -- Find the series asked for. If it doesn't exist, create it.
    lID = find(pName, vDefnSeries)
    if lID = 0 then
        vSeriesData = append(vSeriesData, kEmptySeries)
        vDefnSeries  = append(vDefnSeries, pName)
        lID = length(vDefnSeries)
    end if

    -- Apply the attribute values, ignoring any invalid ones.
    for i = 1 to length(pValues) do

        -- Only accept attr-value pairs: ie. must be a 2-element sequence.
        if sequence(pValues[i]) and length(pValues[i]) = 2 then

            -- Convert the attribute code into an offset into the series' data.
            -- I need to add one to skip over the Current Value field.
            lFld = find(pValues[i][1], kSFlds) + 1

            -- Only apply if valid attr type and the datatype is suitable.
            if lFld > 1 and (atom(pValues[i][2]) or (lFld = kSUserData)) then

                vSeriesData[lID][lFld] = pValues[i][2]
            end if
        end if
    end for

end procedure

--/topic Series
--/func next_number(object pName)
--/desc Increments the series and returns the next value in it.
--/ret ATOM: The next value in the series.
--
--Example:
--/code
--    constant CUSTREC      = next_number("Record Layouts")
--    constant C_Id         = next_number(CUSTREC)
--    constant C_GivenName  = next_number(CUSTREC)
--    constant C_FamilyName = next_number(CUSTREC)
--    constant C_Address    = next_number(CUSTREC)
--    constant C_Email      = next_number(CUSTREC)
--    constant CUSTREC_SIZEOF = current_number(CUSTREC)
--
--    constant INVOICE      = next_number("Record Layouts")
--    constant I_Id         = next_number(INVOICE)
--    constant I_Date       = next_number(INVOICE)
--    constant I_CustId     = next_number(INVOICE)
--    constant I_Terms      = next_number(INVOICE)
--    constant I_Address    = next_number(INVOICE)
--    constant INVOICE_SIZEOF = current_number(INVOICE)
--/endcode
-----------------------------------------------
global function next_number(object pName)
-----------------------------------------------
    integer lID
    atom lNextNum
    integer lWrapped


    -- Find the series asked for. If it doesn't exist, create it.
    lID = find(pName, vDefnSeries)
    if lID = 0 then
        define_series(pName,{})
        lID = find(pName, vDefnSeries)
        -- It should exist now. If not, then bail out.
        if lID = 0 then
            return {}
        end if
    end if

    lWrapped = False

    -- Has the next value been reset by a call to define_series()?
    if sequence(vSeriesData[lID][kSResetValue]) then
        -- No, do the normal case.
        lNextNum = vSeriesData[lID][kSValue] + vSeriesData[ lID ][ kSIncr ]
        -- Handle those series that wrap from last back to first.
        if vSeriesData[ lID ] [ kSWrap ] then
            if vSeriesData[ lID ][ kSIncr ] > 0 then
                if lNextNum > vSeriesData[ lID ][ kSLast ] then
                    lNextNum = vSeriesData[ lID ] [ kSFirst ]
                end if
            else
                if lNextNum < vSeriesData[ lID ][ kSLast ] then
                    lNextNum = vSeriesData[ lID ] [ kSFirst ]
                end if
            end if
        end if

    else
        -- Yes, use the reset value instead of calculating it.
        lNextNum = vSeriesData[lID][kSResetValue]
         vSeriesData[lID][kSResetValue] = {}
        -- Range-check those series that wrap.
        if vSeriesData[ lID ] [ kSWrap ] then
            if vSeriesData[ lID ][ kSIncr ] > 0  then
                if lNextNum > vSeriesData[ lID ][ kSLast ] or
                   lNextNum < vSeriesData[ lID ][ kSFirst ] then

                    lNextNum = vSeriesData[ lID ] [ kSFirst ]
                    lWrapped = True
                end if
            else
                if lNextNum < vSeriesData[ lID ][ kSLast ] or
                   lNextNum > vSeriesData[ lID ][ kSFirst ] then

                    lNextNum = vSeriesData[ lID ] [ kSFirst ]
                    lWrapped = True
                end if
            end if
        end if
    end if


    -- Save the value for the next call
    vSeriesData[ lID ] [ kSValue ] = lNextNum

    -- Check for any callback routine.
    if vSeriesData[ lID ] [ kSRtnId ] > -1 then
        return call_func(vSeriesData[ lID ] [ kSRtnId ],
                          {pName, SCB_NextNum, lNextNum, lWrapped,
                           vSeriesData[ lID ] [ kSUserData ]} )
    else
        return lNextNum
    end if

end function

--/topic Series
--/func current_number(object pName)
--/desc Returns the current value in the series but does /b not increment it.
--/ret ATOM: The current value in the series.
--
--Example:
--/code
--    constant CUSTREC      = next_number("Record Layouts")
--    constant C_Id         = next_number(CUSTREC)
--    constant C_GivenName  = next_number(CUSTREC)
--    constant C_FamilyName = next_number(CUSTREC)
--    constant C_Address    = next_number(CUSTREC)
--    constant C_Email      = next_number(CUSTREC)
--    constant CUSTREC_SIZEOF = current_number(CUSTREC)
--
--    constant INVOICE      = next_number("Record Layouts")
--    constant I_Id         = next_number(INVOICE)
--    constant I_Date       = next_number(INVOICE)
--    constant I_CustId     = next_number(INVOICE)
--    constant I_Terms      = next_number(INVOICE)
--    constant I_Address    = next_number(INVOICE)
--    constant INVOICE_SIZEOF = current_number(INVOICE)
--/endcode
-----------------------------------------------
global function current_number(object pName)
-----------------------------------------------
    integer lID

    -- Find the series asked for. If it doesn't exist, bail out.
    lID = find(pName, vDefnSeries)
    if lID = 0 then
        return {}
    end if

    -- Check for any callback routine.
    if vSeriesData[ lID ] [ kSRtnId ] > -1 then
        return call_func(vSeriesData[ lID ] [ kSRtnId ],
                          {pName, SCB_CurrentNum,
                           vSeriesData[lID][kSValue], False,
                           vSeriesData[ lID ] [ kSUserData ]} )
    else
        return vSeriesData[lID][kSValue]
    end if
end function

--/topic Series
--/func get_series(object pName)
--/desc Fetches an entire definition for a series.
--/ret SEQUENCE: A Series definition.
--
--The returned value could be used as input to /define_series() if you wish.
--
--The attributes are returned in this order as a set of attribute/value pairs: /n
--/li /b SValue : The current value of the series.
--/li /b SIncr : The amount to increment the series by.
--/li /b SWrap : Indicator that the series can wrap from last to first.
--/li /b SFirst : The first value in the series.
--/li /b SLast : The last value in the series.
--/li /b SRtnId : The stored routine_id, if any
--/li /b SUserData : Any user data you wish to be passed back to the routine_id.
--
--Example:
--/code
--      sequence lDef
--      lDef = get_series("Record Layouts")
--/endcode
-----------------------------------------------
global function get_series(object pName)
-----------------------------------------------
    -- Returns a series definition.
    integer lID
    integer lX

    -- Find the series asked for. If it doesn't exist, bail out.
    lID = find(pName, vDefnSeries)
    if lID = 0 then
        return {}
    end if

    -- Check for a pending value reset.
    if sequence(vSeriesData[ lID ][ kSResetValue]) then
        lX = kSValue
    else
        lX = kSResetValue
    end if

    -- Build the attribute-pair list. The attribute order is not significant.
    return
         {
            {SValue, vSeriesData[ lID ][ lX]},
            {SIncr, vSeriesData[ lID ][ kSIncr]},
            {SWrap, vSeriesData[ lID ][ kSWrap]},
            {SFirst, vSeriesData[ lID ][ kSFirst]},
            {SLast, vSeriesData[ lID ][ kSLast]},
            {SRtnId, vSeriesData[ lID ][ kSRtnId]},
            {SUserData, vSeriesData[ lID ][ kSUserData]}
         }

end function

--------------------NOTICE-------------------------------*
-- Software ID: w32def_series.ew
-- Version:     0.60
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*

-- This file defines some symbols needed by both w32constants.ew and w32memory.ew.
-- Future changes in the language may make this file obsolete.


constant Structures = next_number(0)

function w32CurrentStructure()
    return current_number(Structures)
end function

function w32NextStructure()
    return next_number(Structures)
end function

-----------------------------------------------------------------------------

--/topic Memory management
--/func w32define_union(sequence fields,integer selector, integer data_assess)
--/desc Defines a union structure: the structure is any of the ones given in /i fields.
--/ret (SEQUENCE) A structure id, which you can use almost like any other.
-- The /i selector argument is a routine_id. The associated routine must be a function that
-- takes an atom as sole argument. This atom is the memory address of the structure being queried.
-- The function must return an integer, the index in /i fields of the variant form that is stored
-- at that address. /n
-- /i data_assess is a routine_id of a function that takes an object (data to store in the union)
-- and returns, as above, which sort of variant of the union should be used.
--
-- Example:
--/code
-- -- The following function returns 1 if addr points to an submenu template entry, and 2 for an item/separator entry
--
-- integer isPopup, isDataPopup
-- function isAPopup(atom addr)
-- return w32iff(and_bits(peek(a)+peek(a+1)*256,MF_POPUP),1,2)
-- end function
-- isPopup = routine_id("isAPopup")
--
-- function isDataForPopup(object x)
-- return w32iff(atom(x),1,2)
-- end function
--
-- isDataPopup=routine_id("isDataForPopup")
--
-- -- Now define a menu item template entry as understood by the LoadMenuIndirect() API.
-- -- This has an option field (a word), an optional ID field (a word), and a wide char string.
--
-- constant
-- -- define a substructure that will store both option and ID
-- FULLMENUITEMTEMPLATE_flags = w32allot(Word),
-- FULLMENUITEMTEMPLATE_id = w32allot(Word),
-- SIZEOF_FULLMENUITEMTEMPLATE = w32allotted_size(),  -- 4
-- ID_FULLMENUITEMTEMPLATE = w32define_this_struct(),
--
-- -- define the start of an entry as either a word or an item entry
-- ID_STARTITEMTEMPLATE = w32define_union({Word,ID_FULLMENUITEMTEMPLATE},isPopup,isDataPopup),
--
-- -- Now here is the MENUITEMTEMPLATE entry structure
-- MENUITEMTEMPLATE_flags = w32allot(ID_STARTITEMTEMPLATE),
-- MENUITEMTEMPLATE_mtString = w32allot(Ustrz),
-- SIZEOF_MENUITEMTEMPLATE = w32allotted_size(),
--
-- -- You may wish to access the original fields of the structure:
-- -- define a specialised form of a STARTITEMTEMPLATE union
-- MENUITEMENTRY = w32specialise(ID_STARTITEMTEMPLATE,ID_FULLMENUITEMTEMPLATE),
--
-- -- Now define the subfields for access
-- MENUITEMTEMPLATE_mtOption = {MENUITEMENTRY,FULLMENUITEMTEMPLATE_flags},
-- MENUITEMTEMPLATE_mtID = {MENUITEMENTRY,FULLMENUITEMTEMPLATE_id}
--/endcode
global function w32define_union(sequence fields,integer selector,integer data_assess)
    unionVariants=append(unionVariants,fields)
    unionSelectors&=selector
    unionDataInfer&=data_assess
    vLayouts&=length(unionVariants)
    vStructSizes=append(vStructSizes,{})
    vFirstVirtualFields=append(vFirstVirtualFields,{})
    vNumAligns=append(vNumAligns,{})
    return {{w32CurrentStructure()}}
end function

--/topic Memory management
--/func w32specialise(sequence union,object variant)
--/desc Returns a structure field descriptor that can be translated into an actual variant of a union.
--/ret (SEQUENCE) A field descriptor.
-- /i union is a field descriptor whose is of an union type. The point of w32specialise() is
-- to give /w32store() a hint about what exactly is to be stored there. /n
-- /i variant is either a field descriptor or a number. If a field descriptor, it must
-- appear in the list of fields that /i union can have. If a number, it is the index of the
-- field to choose among those defining the union.
global function w32specialise(sequence union,object variant)
    object p

    p=vLayouts[union[strType]]
    if sequence(p) or union[unionSpec]!=0 then
        return union
    end if
    if integer(variant) then
        if variant<1 or variant>length(unionVariants[p]) then
            warnErr("Invalid union selector")
        else
            union[unionSpec]=variant
        end if
    else
        variant=find(variant,unionVariants[p])
        if variant=0 then
            warnErr("Invalid union selector")
        else
            union[unionSpec]=variant
        end if
    end if
    return union
end function

--/topic Memory Management
--/func w32allotted_handle(hDefn)
--/desc Returns the address of the supplied handle, but with fetch instructions
-- to get the address from the handle, rather than the handle itself. /n
-- An empty sequence is returned if the parameter was invalid.
--/ret SEQUENCE: Handle's "fieldOffset" into a structure.
--
-- Example:
--
-- /code
-- constant
--    hDemo            = /w32allot( Hndl ),
--    pDemo            = /w32allotted_handle( hDemo ),
--    SIZEOF_DEMO      = /w32allotted_size()
--     . . .
--    x = w32acquire_mem(w32new_memset(),SIZEOF_DEMO)
--    initDEMO(x)
--
--    h = w32fetch(x, hDemo)
--    a = w32fetch(x, pDemo)
--    -- 'h' will contain the handle, and 'a' the address from the handle.
-- /endcode

global function w32allotted_handle(sequence pHandle)
   sequence result

   result = {}
   if pHandle[fieldType] = Hndl then
      result = pHandle
      result[fieldType] = HndlAddr
   end if
   return result

end function

--/topic Memory Management
--/func w32allotted_length(hDefn)
--/desc Returns a modified field so as to /w32fetch() the length of the supplied buffer
--/ret INTEGER: Buffer length "fieldOffset" into a structure.
--w32fetch(), when given a field that represents an asBuffer or usBuffer, returns the string
-- in the buffer. Use this function on the field, and w32fetch() will return the buffer length instead
--  when using the returned field. This is similar to how /w32allotted_handle() works.
global function w32allotted_length(sequence pHandle)
   sequence result

   result = {}
   if pHandle[fieldType] = asBuffer or pHandle[fieldType] = usBuffer then
      result = pHandle
      result[fieldType] = Long
      result[fieldOffset]+=4
      result[unitSize]=4
   end if
   return result

end function

--/topic Memory Management
--/func w32allotted_buffer(hDefn)
--/desc Returns a modified field so as to /w32fetch() the address of the supplied buffer
--/ret SEQUENCE: Handle's "fieldOffset" into a structure.
--w32fetch(), when given a field that represents an asBuffer or usBuffer, returns the string
-- in the buffer. Use this function on the field, and w32fetch() will return the buffer address instead
--  when using the returned field. This is similar to how /w32allotted_handle() works.
global function w32allotted_buffer(sequence pHandle)
   sequence result

   result = {}
   if pHandle[fieldType] = asBuffer then
      result = pHandle
      result[fieldType] = Lpsz
      result[unitSize]=4
   elsif pHandle[fieldType] = usBuffer then
      result = pHandle
      result[fieldType] = Upsz
      result[unitSize]=4
   end if
   return result

end function

integer radd  -- routine_id for w32address()
--/topic Memory Management
--/func w32buffer_address(atom struct,sequence bDefn)
--/desc Returns the address of the buffer, while /w32fetch would return the string stored there.
--/ret (ATOM) The address of the buffer.
-- /i bDefn must be a field definition defining an Lpsz, Upsz, asBuffer or usBuffer field.
global function w32buffer_address(atom struct,sequence bDefn)
    if find(bDefn[fieldType],{asBuffer,usBuffer,Lpsz,Upsz}) then
        return l_SafePeek4u(call_func(radd,{struct,bDefn}))
    else
        return 0
    end if
end function

--/topic Memory Management
--/func w32buffer_length(atom struct,sequence bDefn)
--/desc Returns the stored length of the buffer.
--/ret (INTEGER) The length of the buffer.
-- /i bDefn must be a field definition defining an asBuffer or usBuffer field.
global function w32buffer_length(atom struct,sequence bDefn)
    if find(bDefn[fieldType],{asBuffer,usBuffer}) then
        return l_SafePeek4u(call_func(radd,{struct,bDefn})+4)
    else
        return 0
    end if
end function

--/topic Memory Management
--/func w32allotted_sofar()
--/desc Return size allotted sofar to the structure
--/ret INTEGER: Allotted size of structure.
--
-- Example:
--
-- /code
-- constant
--    rectLeft            = /w32allot( Long ),
--    rectTop             = /w32allot( Long ),
--    SIZEOF_LT           = /w32allotted_sofar()
--    rectRight           = /w32allot( Long ),
--    rectBottom          = /w32allot( Long ),
--    SIZEOF_RECT        = /w32allotted_size()
-- /endcode

global function w32allotted_sofar()

    -- returns allotted size

    return vAllotted

end function

integer raqm  -- routine_id for w32acquire_mem()

function virtualise_blank(object strtype)
-- record a sruct as virtual, setting a new container for relocation data.
-- Returns address from where any field in the fixed initial part can be poked safely.
-- Used by w32acquire_mem() to allocate memory for structures with vlms
    atom at
    sequence s,s0
    integer size,virtual

    if integer(strtype) then  -- index of a known structure
        size=vStructSizes[strtype]
        s=vLayouts[strtype]
    elsif length(strtype)=4 then -- descriptor for short structure
        size=strtype[2]
        s=vLayouts[strtype[1]][1..strtype[3]]
        strtype=strtype[1]
    else
        strtype=strtype[1][1]
        size=vStructSizes[strtype]
        s=vLayouts[strtype]
    end if
    virtual=vFirstVirtualFields[strtype]
    at = call_func(raqm,{0,size})  -- fixed part address

    -- initialise new reference to a virtual structure
    virtualStructs &= at
    virtualTypes = append(virtualTypes,strtype)
    virtualWasBlank &= 1
    virtualFields = append(virtualFields,s)
    s0=repeat(0,length(s))
    virtualAddresses = append(virtualAddresses,s0)
    virtualOrgAddresses = append(virtualOrgAddresses,s0)
    virtualIndAddresses = append(virtualIndAddresses,s0)
    virtualIndOrgAddresses = append(virtualIndOrgAddresses,s0)
    virtualStatus = append(virtualStatus,s0-2)   -- 0=fixed, -1=untouched, 1=relocated -2 = undefined
    virtualIndStatus = append(virtualIndStatus,s0-2)   -- 0=fixed, -1=untouched, 1=relocated
    virtualSizes = append(virtualSizes,s0)
    virtualIndSizes = append(virtualIndSizes,s0)
    virtualUnions = append(virtualUnions,s0)
    if virtual>1 then
        virtualStatus[length(virtualStatus)][1..virtual-1]=0
        for i=virtual to length(s) do
            s0 = s[i]
            if sequence(s0[arrayCount]) then -- $ has been avoided to accommodate pre Eu2.5 users
                virtualIndAddresses[length(virtualIndStatus)][i]={}
                virtualIndSizes[length(virtualIndStatus)][i]={}
                virtualIndStatus[length(virtualIndStatus)][i]={}
                virtualIndOrgAddresses[length(virtualIndOrgAddresses)][i]={}
            elsif equal(s0[fieldType],Align) then
                virtualStatus[length(virtualStatus)][i]=1
                virtualSizes[length(virtualSizes)][i]={s0[arrayCount]}
            elsif s0[isVirtual] and s0[arrayCount]>1 then
                virtualIndAddresses[length(virtualIndStatus)][i]=repeat(0,s0[arrayCount])
                virtualIndSizes[length(virtualIndStatus)][i]=repeat(0,s0[arrayCount])
                virtualIndStatus[length(virtualIndStatus)][i]=repeat(-2,s0[arrayCount])
            end if
        end for
    end if
    w32manage_mem(0,at)  -- this address becomes a memset of its own
    return at
end function

--/topic Memory Management
--/func w32acquire_mem( atom Owner, object structure )
--/desc Allocate memory for structure, and initialize to zero.
--/ret Address of allocated memory, or array of such addresses.
-- The memory allocated is linked to the /i Owner and all the
-- owner's memory can be released by one call. /n
-- /i owner may have been returned by /w32new_memset(), or it may be the address of a structure.
-- In both cases, releasing the owner will also release the acquired memory. /n
-- If /i structure is a string, it is copied to the memory
-- location along with a zero byte.
--
-- /i structure may also be a structure identifier
-- previously returned by /w32define_this_struct(). In this case, it is recommended to
-- /w32store() objects inside it rather than poke()ing them. If you attempt to poke a field
-- whose address is not known, or to /w32fetch() one that you didn't fill yet, an error
-- will occur.
--
-- If /i structure is an atom, it specifies that amount of memory to acquire
-- (a minimum of 4 bytes will always be acquired) and
-- the memory is set to all zeros. This atom may be a predefined size specifier.
-- Using aszText or uszText will cause 0 to be returned, since these field types have
-- an unknown data address until actually filled.
--
-- If the second argument has the form {{count,allocation_unit}}, and count is above 0 (0 will be returned if not greater),
-- then the memory specified by allocation_unit will be allocated count times. In case the allocation
-- unit has a variable length, the whole array of positions is returned. Each allocated unit can be freed individually. /n
-- Example:
-- /code
--      atom mset, pt, pstr
--
--      -- Establish a new memory set.
--      mset = /w32new_memset()
--      -- get enough memory to hold a UInt datatype
--      xy = w32acquire_mem( UInt )
--      -- allocate a point structure
--      pt = w32acquire_mem( mset, SIZEOF_POINT )
--      -- copy a Euphoria string to a 'C' string area.
--      pstr = /w32acquire_mem( mset, "My String Data" )
--      . . .
--      give all the memory area in 'mset' back
--      w32release_mem(mset)
-- /endcode
global function w32acquire_mem( atom pOwner, object pData )

        -- allocate space for a structure (mininum of 4 bytes)
        -- and initialize to zero

    atom at,a
    integer cnt,ldata
    sequence result

    cnt=1
    result={}
    if sequence(pData) and length(pData)=1 and sequence(pData[1]) and length(pData[1])=2 then -- {count,type}
        if not integer(pData[1][1]) or pData[1][1]<=0 then
            return 0
        end if
        cnt=pData[1][1]
        pData[1]=pData[1][2]
    end if
    if sequence(pData) then
        if length(pData)=1 and sequence(pData[1]) then -- w32define()d structure
            pData=pData[1]
            if length(pData)=1 then  -- maximal
                if vFirstVirtualFields[pData[descType]] then
                    result=repeat(0,cnt)
                    for i=1 to cnt do
                        at = virtualise_blank(pData)
                        if not at then
                            exit
                        else
                            result[i]=at
                        end if
                    end for
                else
                    at = l_MyAllocate( cnt*vStructSizes[pData[descType]])
                end if
            else -- not maximal, length=4
                if pData[descNumFields]>=vFirstVirtualFields[pData[1]] then
                    result=repeat(0,cnt)
                    for i=1 to cnt do
                        at = virtualise_blank(pData)
                        if not at then
                            exit
                        else
                            result[i]=at
                        end if
                    end for
                else  -- no virtual members
                    at = l_MyAllocate( cnt*pData[descSize] )
                end if
            end if
        else
            -- place string in memory
            ldata = 1 + length(pData)
            at = l_MyAllocate(cnt*ldata)
            if at != 0 then
                a=at
                for i=1 to cnt do
                    poke(a, pData)
                    a+=ldata
                    poke(a-1, 0)
                end for
            end if
        end if
    else
        -- Check for special datatypes in "names"
        if pData < 0 then
            pData = find(pData, vSizeNames)
            if pData > 0 then
                pData = vSizeLengs[pData]
            end if
        end if

        if pData<0 then -- vlm are not statically allocated
            return 0
        elsif pData < 4 then
            pData = 4
        end if

        at  = l_MyAllocate( cnt*pData )

    end if

    if at = 0 then  -- unexpected failure
        if vAbortRtn >= 0 then
            call_proc(vAbortRtn, { "Unable to allocate space."} )
            return 0 -- Just in case the abort does not crash program.
        else
            crash_message("w32acquire_mem() could not find memory to allocate.")
            ? 0/0 -- Force a crash
        end if
    elsif length(result) then
        w32manage_mem(pOwner, result)
        return result
    else
        w32manage_mem(pOwner, at)
        return at
    end if

end function
raqm = routine_id("w32acquire_mem")

--/topic Memory Management
--/func w32new_memset( )
--/desc Allocates a unique id for a memory set.
--/ret ATOM: An id for a new memory set (memset).
-- A memset id is actually a machine address of a 4-bytes location. You can
-- use this 4-byte area for anything you like, until you call /w32release_mem()
--
-- Example:
--
--/code
--      atom ss
--
--		ss = w32new_memset()
--      b = w32acquire_mem(ss, "All you need is love")
--		...
--      w32release_mem( ss )  -- Let go of set 'ss'
--/endcode
global function w32new_memset()
    return w32acquire_mem( 0, UInt )
end function
vPermMemSet_ = w32new_memset()

constant
    Err_GLOBALALLOC    = {"Unable to allocate memory",473},
    Err_GLOBALLOCK     = {"Unable to lock memory",474},
    Err_GLOBALUNLOCK   = {"Unable to unlock memory",475},
    Err_GLOBALFREE     = {"Unable to free memory ",476}

constant
    _GlobalAlloc = define_c_func(krnl32,"GlobalAlloc",{C_LONG,C_LONG},C_POINTER),
    _GlobalLock  = define_c_func(krnl32,"GlobalLock",{C_POINTER},C_UINT),
    _GlobalUnlock  = define_c_func(krnl32,"GlobalUnlock",{C_POINTER},C_UINT),
    _GlobalFree  = define_c_func(krnl32,"GlobalFree",{C_POINTER},C_UINT)



--/topic Memory Management
--/func w32acquire_handle(atom flags,integer size)
--/desc Gets a Windows memory handle to memory of the requested size.
--/ret (ATOM) Handle to memory.
-- This is a very low level routine. /n
-- To access the memory, you must call /w32handle_to_memory(returned_handle). When you are
-- done with the memory operation, call the /w32release_handle(returned_handle,free_also) procedure. /n
--/li <a href="..\win32_constants.htm#w32acquire_handle() flags">Here</a> are the known flags to or tohether as required.
global function w32acquire_handle(atom flags,integer size)
    atom result

    result = c_func(_GlobalAlloc,{flags,size})
    if not result then
        abortErr(Err_GLOBALALLOC)
    end if
    return result
end function

--/topic Memory Management
--/func w32handle_to_memory(atom handle)
--/desc Gives current task exclusive access to the referenced memory block.
--/ret (ATOM) Pointer to memory block.
-- The handle must have been acquired using w32acquire_handle(). /n
-- Writing data outside of the referenced memory block will very likely crash your application.
global function w32handle_to_memory(atom handle)
    atom result

    result = c_func(_GlobalLock,{handle})
    if not result then
        abortErr(Err_GLOBALLOCK)
    end if
    return result
end function

--/topic Memory Management
--/proc w32release_handle(atom handle,integer flag)
--/desc Releases the referenced memory block, and optionally frees it.
-- /i flag is 0 to keep the handle, and nonzero to free it. /n
-- The handle must have been acquired using /w32acquire_handle(). /n
global procedure w32release_handle(atom handle,integer flag)
    if c_func(_GlobalUnlock,{handle}) then
        abortErr(Err_GLOBALUNLOCK)
    end if
    if flag then
        if c_func(_GlobalFree,{handle}) then
            abortErr(Err_GLOBALFREE)
        end if
    end if
end procedure

--/topic Memory Management
--/func w32allot( object FldDefn )
--/desc Allocate space in structure for a new field.
--/ret SEQUENCE: Definition of allotted memory.
-- /i FldDefn is either:
--/li a number of bytes to allocate,
--/li one of the predefined datatypes (listed below),
--/li a structure identifier, predefined or returned by /w32define_this_struct(),
--/li a 2-element sequence containing a repeat count and any of the above.
--
-- The repeat count is either:
--/li a positive number;
--/li a field definition previously returned by this function. In that case, the length of the
-- array is assumed to equal the contents of the supplied field in the structure;
--/li a sequence holding a sequence of bytes. The length of the array is not known, and its end
-- is marked by this sequence of bytes. For instance, a C-string could be defined using w32allot({{{0}},Byte}).
--/li a sequence holding a sequence holding a sequence made of two routine_ids. The length
-- of the array is not known, and the routine_ids are respectively used to determine and mark
-- when an item is the last item.
-- If a number of bytes is supplied, the field is aligned to the next 32-bit
-- boundary before allocation. /n
-- If a {{{id_check_last,id_set_last}}} is supplied as a length, /i id_check_last is the
-- routine_id of a function that takes an atom and returns zero if not last item, nonzero for
-- last item (each item is examined in turn). /i id_set_last is the routine_id of a procedure
-- that takes a single atom as argument (the address of the item at which to apply some end mark).
--
-- The returned allotment definition is used by /w32store and /w32fetch. It has the
-- following structure. /n
-- The definition has seven items: /n
-- A /i "structure field", an /i fieldOffset, a /i datatype, a /i"repeat length", a
-- structure type, a flag (1 if member has variable length) and a /i "unit bytesize" /n
-- Allowable types are: /n
-- /li /b Byte: 8 bit value
-- /li /b Int8: Signed 8 bit integer, same as /b Byte.
-- /li /b Word: 16 bit value
-- /li /b Integer: 16 bit value, same as /b Word
-- /li /b Int16: 16 bit value, same as /b Word
-- /li /b Long: Signed 32 bit value
-- /li /b DWord: 32 bit value, same as /b Long
-- /li /b Int32: 32 bit value, same as /b Long
-- /li /b UInt: Unsigned 32 bit value.
-- /li /b Ptr: 32 bit value, same as /b UInt
-- /li /b ULong: 32 bit value, same as /b UInt
-- /li /b Hndl: 32 bit value,
-- /li /b HndlAddr: 32 bit value, a pointer to a pointer
-- /li /b Lpsz: Long pointer (32 bits) to zero delimited string
-- /li /b Strz: Fixed size buffer that holds a zero-delim string
-- /li /b Single: 32-bit IEEE floating point value
-- /li /b Float: Same as Single
-- /li /b Double: 64-bit IEEE floating point value
-- /li /b Upsz: Long pointer to 0000 delimited UTF-16 encoded string
-- /li /b Ustrz: Fixed size buffer that holds a 0000 delimited DBCS encoded string
-- /li /b aszText: An /b/i actual 0 terminated string
-- /li /b uszText: An /b/i actual 0000 terminated UTF-16 encoded string
--/li /b asBuffer: A pointer to an UTF-8 encoded string, followed by a dword storing its length
--/li /b usBuffer: A pointer to an UTF-16 encoded string, followed by a dword storing its length in TCHARs
--/li /b Align: A pseudo field that forces the next field address to be aligned on a
-- multiple of the size passed. If no size is provided, 8 is assumed.
--/li /b AlignRel: A pseudo field that forces the next field offset to be aligned on a
-- multiple of the size passed. If no size is provided, 4 is assumed.
--/li /b ByteFill: An unaccessible byte. If no size is specified, 1 is assumed. /n
-- You cannot fetch/store the contents of an Align, AlignRel or ByteFill field. /n
-- Arrays of Strz or Ustrz are not currently supported.
--
-- Example:
--
-- /code
-- constant
--    msLeft           = w32allot( Long ),
--    msTop            = w32allot( Long ),
--    msRight          = w32allot( Long ),
--    msBottom         = w32allot( Long ),
--    ID_BARERECT      = /w32define_this_struct()
--    msVelocity       = w32allot( Single ),
--    msXYZ            = w32allot( {4, DWord} ),
--    msReserved       = w32allot( 5 ),
--    msName           = w32allot( Lpsz ),
--    msBuffer         = w32allot( {128, Strz} ),
--    SIZEOF_MYSTRUCT  = /w32allotted_size(),
--    ID_MYSTRUCT      = /w32define_this_struct()
-- /endcode

global function w32allot( object pDataType )

    integer soFar, size,predef,fieldv
    sequence result
    object i, lCnt, spec

    predef = 0
    fieldv=0
    if equal(pDataType,Align) then
        pDataType={8,Align}
    elsif equal(pDataType,ByteFill) then
        pDataType = {1,ByteFill}
    elsif equal(pDataType,AlignRel) then
        pDataType={4,AlignRel}
    end if
    if sequence(pDataType) then
        if integer(pDataType[1]) then  -- {number,type}
            lCnt = pDataType[1]
            i =   pDataType[2]
        else -- a predefined datatype or a structure id
            lCnt = 1
            i =   pDataType
        end if
        if sequence(i) then -- user defined
            if not length(i) then
                return 0
            elsif atom(i[1]) then -- ???
--                 size=-1
--                 fieldv=1
                return 0
            else
                predef = i[1][descType]
                if length(i[1])=1 then
                    if vFirstVirtualFields[predef] then
                        fieldv=1
                        size=-1
                    else
                        size=vStructSizes[predef]
                    end if
                else
                    if vFirstVirtualFields[predef] and i[1][descNumFields] >= vFirstVirtualFields[predef] then
                        fieldv=1
                        size=-1
                    else
                        size = i[1][descSize]
                    end if
                end if
            end if
        end if
    else
        lCnt = 1
        i = pDataType
        fieldv=sequence(lCnt)
    end if

    -- save position
    soFar = vAllotted

    -- assess size if not done already
    if integer(i) then
        size = w32lookup(i, vSizeNames, vSizeLengs&0)
        if size = 0 then
            if i > 0 then
                soFar=w32round(soFar,4,w32RoundUp)
            -- size is actual size
                size = i
            end if
        end if
        spec=-1
    else
        if atom(vLayouts[i[1][descType]]) then
            spec=0  -- unspecialised union
        else
            spec=-1 -- not a union
        end if
    end if
    vNumField+=1

    if integer(i) and i<0 and vIsVirtual[-i] then
        fieldv=1
        if i=AlignRel then -- convert to fixed size, since it is known
            fieldv = (vNumVirtual > 0)
            if not fieldv then
                i=remainder(vAllotted,lCnt)
                if i then
                    lCnt -= i
                else
                    lCnt=0
                end if
                i=ByteFill
            end if
        end if
        if find(i,vFillers) then
            vNumAlign+=1
        end if
    end if

    -- w32allot space if thee is some real space there
    if size>0 then
        size *= lCnt
        vAllotted += size
    end if

    -- record data
    result = {vNumField,soFar, i,lCnt,w32CurrentStructure(), fieldv,  size, spec }
    if vNumVirtual then
        result[fieldOffset] = {}
    end if

    -- update first virtual
    if fieldv and not vNumVirtual then
        vNumVirtual = vNumField
    elsif vNumVirtual and not fieldv then -- a fixed size field which occurs past a vlm, hence its address is unknown
        result[isVirtual]=-1
    end if

    vLayout=append(vLayout,result)
    return result
end function


-----------------------------------------------------------------------------
--/topic Memory Management
--/func w32allotted_size()
--/desc Return allocate size of structure, and reset for new structure.
--/ret INTEGER: Allotted size of structure.
--
-- Example:
--
-- /code
-- constant
--    rectLeft            = /w32allot( Long ),
--    rectTop             = /w32allot( Long ),
--    rectRight           = /w32allot( Long ),
--    rectBottom          = /w32allot( Long ),
--    SIZEOF_RECT        = /w32allotted_size()
-- /endcode

global function w32allotted_size()

    -- returns allotted size, and clears size

    integer soFar

    soFar = w32allotted_sofar()

    -- record current structure
    vStructSizes &= soFar
    vAllotted = w32NextStructure()  -- ignore return value
    vFirstVirtualFields &= vNumVirtual
    vLayouts = append(vLayouts,vLayout)
    vNumAligns=append(vNumAligns,vNumAlign)
    vPreprocessDataIn &= -1
    vStartWithSize &= 0

    -- get ready for next template
    vAllotted = 0
    vLayout={}
    vNumField=0
    vNumVirtual=0
    vNumAlign=0
    return soFar

end function

--/topic Memory management
--/func w32define_this_struct()
--/desc Returns an identifier for the currently defined structure at the current point.
--/ret (SEQUENCE) A structure identifier.
-- {{struct number}} is returned if not currently defining a structure.
-- Use /w32acquire_mem() to create an instance of the structure.
global function w32define_this_struct()
    if not vNumField then -- no structure is being defined
        return {{w32CurrentStructure()}}
    end if
    -- this is part of a larger struct, return short struct descriptor
    return {{w32CurrentStructure()+1,vAllotted,vNumField,vNumAlign}}
end function

-----------------------------------------------------------------------------

function stdElemAddr(atom struct,sequence s)
-- Returns the address of a field with no vlm preceding it. 0 is returned on invalid array position.
-- Helper for w32address().
    atom offset

    if length(s) > stdFieldEntry then
        if check_array(s) then
            offset = (s[arrayPos]-1) * s[unitSize]
        else -- not a valid array spec
            return 0
        end if
    else
        offset = 0
    end if

    return struct + s[fieldOffset] + offset
end function

integer fcsz -- routine_id for fetch_size()
function inner_fetch(atom struct,atom at,object size,integer cnt)
-- performs the actual fetching of cnt fields of size size in a structure struct at addr at
-- mutually calls fetchSize()
    object result,item
    sequence s,s0

    if sequence(size) then
    -- this is a user defined structure
    -- result is a sequence of field values
        size=size[1]
        if atom(size) then
            return 0
        end if
        if length(size)>1 then
            s=vLayouts[size[descType]][1..size[descNumFields]]
        else
            s=vLayouts[size[descType]]
        end if
        result=repeat(0,cnt)
        for i=1 to cnt do
            s0=s
            for j=1 to length(s0) do
                item=call_func(fcsz,{struct,at,s[j],1}) -- size nd contents
                -- advance pointer
                if atom(item) then
                    at+=item
                elsif sequence(item[1]) then
                    at+=item[1][3]
                else
                    at+=item[1]
                end if
                -- adjust field contents
                if not find(s[j][fieldType],vFillers) then
                    s0[j]=item[2]
                else
                    s0[j]={}
                end if
            end for
            -- i-th structure value fetched
            result[i]=s0
        end for
        if cnt=1 then
            return result
        else
            return result[1]
        end if
    -- read, based on size
    elsif      size = Byte then
        -- return byte
        if cnt > 1 then
            return (l_SafePeek( {at, cnt}) )
        else
            return l_SafePeek( at )
        end if

    elsif   size = Word then
        if cnt = 1 then
            -- return word
            return bytes_to_int( l_SafePeek({at, 2}) & {0, 0} )
        else
            return w32peek2({at,cnt})
        end if

    elsif   size = Long then
        if cnt = 1 then
            -- return signed long
            return l_SafePeek4s( at )
        else
            s = l_SafePeek4s({at, cnt} )
            return s
        end if

    elsif   size = UInt then
        if cnt = 1 then
            -- return unsigned long
            return l_SafePeek4u( at )
        else
            s = l_SafePeek4u({at, cnt} )
            return s
        end if

    elsif   size = Lpsz then
        -- get the pointer
        at = l_SafePeek4u(at)
        if cnt=1 then
            -- return the string
            return w32peek_string( at ) -- at will be checked to be valid
        else
            result=repeat(0,cnt)
            for i=1 to cnt do
                struct = l_SafePeek4u(at)
                result[i] = w32peek_string( struct )
                at+=4
            end for
            return result
        end if

    elsif   size = Upsz then
        -- get the pointer
        at = l_SafePeek4u(at)
        if cnt=1 then
            -- return the string
            return w32peek_string16( at ) -- at will be checked to be valid
        else
            result=repeat(0,cnt)
            for i=1 to cnt do
                struct = l_SafePeek4u(at)
                result[i] = w32peek_string16( struct )
                at+=4
            end for
            return result
        end if

    elsif   size = Hndl then
        if cnt = 1 then
            -- return handle
            return l_SafePeek4u( at )
        else
            return l_SafePeek4u({at,cnt})
        end if

    elsif   size = HndlAddr then
        -- return a handle's address
        if cnt=1 then
            return l_SafePeek4u( l_SafePeek4u( at ) )
        else
            result=repeat(0,cnt)
            for i=1 to cnt do
                result[i] = l_SafePeek4u( l_SafePeek4u( at ) )
                at+=4
            end for
            return result
        end if
    elsif size = Strz then -- assumes cnt=1
        return w32peek_string(at)
    elsif size = Ustrz then -- assumes cnt=1
        return w32peek_string16(at)
    elsif size = Single then
        if cnt=1 then
            return float32_to_atom(l_SafePeek({at, 4}))
        else
            result = repeat(0,cnt)
            for i = 1 to cnt do
                s = l_SafePeek({at, 4} )
                at += 4
                result[i] = float32_to_atom(s)
            end for
            return result
        end if

    elsif size = Double then
        if cnt=1 then
            return float64_to_atom(l_SafePeek({at, 8}))
        else
            result = repeat(0,cnt)
            for i = 1 to cnt do
                s = l_SafePeek({at, 8} )
                at += 8
                result[i] = float64_to_atom(s)
            end for
            return result
        end if

    elsif size = aszText then  -- assumes cnt=1
        return w32peek_string(at)
    elsif size = uszText then  -- assumes cnt=1
        return w32peek_string16(at)
    elsif size = asBuffer then
        if peek4s(at+4)<=0 then
            return 0
        end if
        if cnt=1 then
            return w32peek_string(peek4u(at))
        else
            result=repeat(0,cnt)
            for i=1 to cnt do
                if peek4u(at)=0 then
                    result[i]=""
                else
                    result[i]=w32peek_string(peek4u(at))
                end if
                at+=8
            end for
            return result
        end if
    elsif size = usBuffer then
        if peek4u(at)=0 then
            return ""
        end if
        if cnt=1 then
            cnt=peek4u(at+4)
            if cnt=0 then
                return ""
            end if
            result=w32peek_string16(peek4u(at))
            size=1
            for i=1 to 2*cnt by 2 do
                result[size]=result[i]+256*result[i+1]
                size+=1
            end for
            return result[1..cnt]
        else
            result=repeat(0,cnt)
            for i=1 to cnt do
                if peek4u(at)=0 then
                    result[i]=""
                else
                    size=peek4u(at+4)
                    if size then
                        s=w32peek_string16(peek4u(at))
                        cnt=1
                        for j=1 to length(s) by 2 do
                            s[cnt]=s[i]+256*s[i+1]
                            cnt+=1
                        end for
                        result[i]=s[1..size]
                    else
                        result[i]=""
                    end if
                    at+=8
                end if
            end for
            return result
        end if

    elsif size = Rect then
        if cnt = 1 then
            return l_SafePeek4u({at,4})
        else
            result = repeat(0,cnt)
            s = l_SafePeek4u({at,4*cnt})
            size = 1
            for i = 1 to cnt do
                result[i] = s[size..size+3]
                size+=4
            end for
            return result
        end if
    elsif size = Point then
        if cnt = 1 then
            return l_SafePeek4u({at,2})
        else
            result = repeat(0,cnt)
            s = l_SafePeek4u({at,2*cnt})
            size = 1
            for i = 1 to cnt do
                result[i] = s[size..size+1]
                size+=2
            end for
            return result
        end if
    elsif size > 0 then
        -- return the 8-bit string or memory block
        return l_SafePeek( {at, size} )
    else
        return {}
    end if
end function

function fetchArray(atom struct,atom at,sequence s,integer flag)
-- Returns the actual count of a terminated array
-- helper for fetchSize(), which it calls.
-- Returns like fetchSize().
    integer totalsize,lterm,size,is_seq
    sequence term
    sequence sizes,addresses,contents
    object x

    term=s[arrayCount][1]
    is_seq = atom(s[1])
    if is_seq then -- either length of terminating sequence, or routine_id for termination predicate
        lterm=length(term)
    else
        lterm=s[1][1]
    end if
    s[arrayCount]=1
    totalsize=0
    sizes={}
    addresses={}
    contents={}
    while 1 do
        x=call_func(fcsz,{struct,at,s&1,flag})  -- fetch size/contents of next element
        if atom(x) then
            size=x
        else
            if length(x)=2 then
                size=x[2]
                contents=append(contents,x[2])
                x=x[1]
                if atom(x) then
                    size=x
                else
                    sizes=append(sizes,x[1])
                    addresses=append(addresses,x[2])
                    size=x[3]
                end if
            else
                sizes=append(sizes,x[1])
                addresses=append(addresses,x[2])
                size=x[3]
            end if
        end if
        totalsize+=size
        if not is_seq then
            if call_func(lterm,{at}) then -- item identified as last
                exit
            end if
        end if
        at+=size
        if is_seq and equal(term,peek({at,lterm})) then -- terminating sequence recognised
            exit
        end if
    end while
    if flag=1 then
        if length(contents)=1 then
            return {totalsize,contents[1]}
        else
            return {{sizes,addresses,totalsize},contents}
        end if
    elsif flag=-1 then
        return totalsize
    else
        return {sizes,addresses,totalsize}
    end if
end function

integer rsto,rfet -- routine_ids for w32store() and w32fetch()
function fetchSize(atom struct,atom at,sequence s,integer flag)
-- if flag=-1, return total size; if flag=0, return also ind sizes and addresses if applicable
-- If flag=1, also return contents.
    integer size
    integer totalsize
    integer count
    sequence strings
    sequence sizes
    sequence addresses
    integer strlen
    integer wsize

    while sequence(s[arrayCount]) do
        if sequence(s[arrayCount][1]) then -- terminated array
            return fetchArray(struct,at,s,flag)
        else -- array has indirectly accessed length
            s[arrayCount]=call_func(rfet,{struct,s[arrayCount]})
        end if
    end while
    if s[unitSize]>0 then -- fixed size members
        count=check_array(s)
        if not count then
            return {}
        end if
        size = s[unitSize]*count
        if length(s)<arrayPos then
            s&=0
        else
            s[arrayPos..length(s)]-=1
        end if
        if flag=1 then
            return {size,inner_fetch(struct,at+s[unitSize]*s[arrayPos],s[fieldType],count)}
        else
            return size
        end if
    elsif sequence(s[fieldType]) then -- type is a structure
        sizes=s[fieldType]
        if flag!=1 then
            if (length(sizes)=1 and not vFirstVirtualFields[sizes[1]]) then
                return vStructSizes[sizes[descType]]
            elsif length(sizes)>1 and (vFirstVirtualFields[sizes[descType]]=0 or sizes[descNumFields]<vFirstVirtualFields[sizes[descType]]) then
                return sizes[descSize]
            else -- should not happen
                ?1/0
            end if
        else -- should not happen
            ?1/0
        end if
    elsif s[fieldType]=Align then -- no contents
        size=remainder(at,s[arrayCount])
        if size then
            size=s[arrayCount]-size
        end if
        return size
    elsif s[fieldType]=ByteFill then  -- no contents
        return s[arrayCount]
    elsif s[fieldType]=AlignRel then
        size=remainder(at-struct,s[arrayCount])
        if size then
            size=s[arrayCount]-size
        end if
        return size
    else -- other variable length - aszText or uszText
        if length(s)<=stdFieldEntry then
            s&=1
        else
            s=s[1..arrayPos]
        end if
        count=s[arrayCount]
        sizes=repeat(0,count)
        addresses=repeat(0,count)
        strings=repeat(0,count)
        totalsize=0
        if s[fieldType]=aszText then
            wsize=1
            strlen=_lstrlen
            s[fieldType]=Strz
        else
            wsize=2
            strlen=_lstrlenw
            s[fieldType]=Ustrz
        end if
        for i=1 to count do
            size=c_func(strlen,{at})+wsize
            size*=wsize
            if flag=-1 then
            else
                sizes[i]=size
                addresses[i]=at
                if flag=0 then
                    strings[i]=inner_fetch(struct,at,s,1)
                end if
            end if
            totalsize += size
            at += size
            s[arrayPos]+=1
        end for
        if flag=1 then
            if length(strings)=1 then
                return {totalsize,strings[1]}
            else
                return {{sizes,addresses,totalsize},strings}
            end if
        elsif flag=-1 then
            return totalsize
        else
            return {sizes,addresses,totalsize}
        end if
    end if
end function
fcsz=routine_id("fetchSize")

integer rElemAddr

function addVirtualField(atom struct,sequence s)
-- call only for structures that have a realisation
-- called by w32fetch(),w32store() and w32ElemAddr()
    atom at
    integer p,orgstatus,q,sel,var
    object x

    p=find(struct,virtualStructs) -- not zero -- DbC would be sooooo useful, but it will be deemed as complicated
    if sequence(s[fieldOffset]) then
        if not virtualWasBlank[p] then
            q = find(s[numField]-1,virtualFields[p])  -- address of previous field known
            if q=0 then -- no, add it first and so on till we know
                q = addVirtualField(struct,vLayouts[s[strType]][s[numField]-1])
                at = virtualAddresses[p][q] + virtualSizes[p][q]
            else
                at = virtualAddresses[p][q]
            end if
        else
            return 0  -- should not happen
        end if
    else
        at = struct + s[fieldOffset]
    end if
    virtualFields[p]=append(virtualFields[p],s)
    orgstatus = w32iff(s[isVirtual]=1,-1,0)
    virtualStatus[p] &= orgstatus
    virtualIndStatus[p] &= orgstatus
    if s[unionSpec]!=0 then
        virtualUnions[p]&=s[unionSpec]
        if s[unionSpec]>0 then --set type to supplied specialisation
            s[fieldType]=unionVariants[vLayouts[s[fieldType][strType]]][s[unionSpec]]
        end if
    else -- determine the variant stored there
        sel=vLayouts[s[fieldType][descType]]
        var=call_func(unionSelectors[sel],{at})
        virtualUnions[p]&=var
        s[fieldType]=unionVariants[sel][var]
    end if
    -- assume now that s[fieldType] isn't a union

    x = fetchSize(struct,at,s,0)
    if atom(x) then
        virtualSizes[p] &= x
        virtualIndSizes[p] &= x
        virtualOrgAddresses[p] &= at
        virtualIndOrgAddresses[p] &= at
        virtualAddresses[p] &= at
        virtualIndAddresses[p] &= at
        virtualIndAddresses[p] &= at
    else
        virtualSizes[p] &= x[3]
        virtualIndSizes[p] = append(virtualIndSizes[p],x[1])
        virtualOrgAddresses[p] &= at
        virtualIndOrgAddresses[p] = append(virtualIndOrgAddresses[p],x[2])
        virtualAddresses[p] &= at
        virtualIndAddresses[p] = append(virtualIndAddresses[p],x[2])
        virtualIndStatus[p] = append(virtualIndStatus[p],repeat(orgstatus,length(x[1])))
    end if
    return length(virtualOrgAddresses[p])
end function

function virtualise(atom struct,sequence s)
-- record a struct as virtual, setting a new container for relocation data
    integer p,q

    p=find(struct,virtualStructs)
    if not p then
        virtualStructs &= struct
        virtualTypes &= s[strType]
        virtualWasBlank &= 0
        virtualFields = append(virtualFields,{})
        virtualAddresses = append(virtualAddresses,{})
        virtualOrgAddresses = append(virtualOrgAddresses,{})
        virtualIndAddresses = append(virtualIndAddresses,{})
        virtualIndOrgAddresses = append(virtualIndOrgAddresses,{})
        virtualStatus = append(virtualStatus,{})   -- 0=fixed, -1=untouched, 1=relocated
        virtualIndStatus = append(virtualIndStatus,{})   -- 0=fixed, -1=untouched, 1=relocated
        virtualSizes = append(virtualSizes,{})
        virtualIndSizes = append(virtualIndSizes,{})
        virtualUnions = append(virtualUnions,{})
        p=length(virtualStructs)
        q=0
    else
        q=find(s[1..stdFieldEntry],virtualFields[p])
    end if
    return {p,q}
end function

function getArrayCount(atom struct,sequence s)
-- gets the size of a dynamic array
    integer n,size,rid
    atom base_addr
    sequence s0

    if atom(s[arrayCount][1]) then
        return call_func(rfet,{struct,s[arrayCount]})
    elsif atom(s[arrayCount][1][1]) then -- termination is assessed by calling a routine
        base_addr=struct
        struct=call_func(radd,{struct,s})
        s0=s[arrayCount][1]
        n=0
        s[arrayCount]=1
        while compare(s0,peek({struct,length(s0)})) do
            n+=1
            size=fetchSize(base_addr,struct,s,-1)
            struct+=size
        end while
        return n
    else -- termination is assessed by checking for a specific sequence
        base_addr=struct
        struct=call_func(radd,{struct,s})
        rid=s[arrayCount][1][1][1]
        n=1
        s[arrayCount]=1
        while not call_func(rid,{struct}) do
            n+=1
            size=fetchSize(base_addr,struct,s,-1)
            struct+=size
        end while
        return n
    end if
end function

function w32ElemAddr(atom struct,sequence s)
-- returns The RAM address of /i field within the /i struct
    integer p
    integer q
    sequence s0

    if not s[isVirtual] then
        return stdElemAddr(struct,s)
    end if
    s0=virtualise(struct,s)
    p=s0[1]
    q=s0[2]
    s0=s[1..stdFieldEntry]
    if not q then  -- unknown field for this struct, add to database
        if virtualWasBlank[p] then -- should not happen
            return 0
        end if
        q=addVirtualField(struct,s0)
    end if
    if sequence(s[arrayCount]) and s[arrayPos] then
        s[arrayCount]=getArrayCount(struct,s)
    end if
    if not check_array(s) then
        return 0
    elsif length(s)=stdFieldEntry then
        s&=1
    end if
    if s[unitSize]>0 then
        return virtualAddresses[p][q]+s[unitSize]*(s[arrayPos]-1)
    elsif s[arrayPos]=1 then
        return virtualAddresses[p][q]
    else
        return virtualIndAddresses[p][q][s[arrayPos]]
    end if

end function
rElemAddr = routine_id("w32ElemAddr")

-----------------------------------------------------------------------------
--/topic Memory Management
--/func w32address( structure address, field )
--/desc Get address of /i field in structure.
--/ret ATOM: Address of the field in the structure.
-- This is typically used if the structure contains an array.
--
-- In this snippet, the /b memBitmapInfo structure contains an array
-- of /b RGBQUAD colors. The array is populated with the values in
-- the pal:
--
-- /code
--    -- get the start of the rgbQuad array
--    rgbQuad = w32address( memBitmapInfo, bmiColors )
--
--    -- copy the pal to memory
--    for i = 1 to colors do
--
--        -- store values
--        /w32store( rgbQuad, rgbRed,      pal[i][1] )
--        /w32store( rgbQuad, rgbGreen,    pal[i][2] )
--        /w32store( rgbQuad, rgbBlue,     pal[i][3] )
--        /w32store( rgbQuad, rgbReserved, 0 )
--
--        -- move to next quad
--        rgbQuad += SIZEOF_RGBQUAD
--
--    end for
--
-- /endcode

global function w32address( atom addr, object offset )
    -- return address in structure
    if atom( offset ) then
        return addr + offset
    elsif equal(offset,{}) then
        return 0
    else
        while sequence(offset[1]) do -- nested field
            for i=1 to length(offset)-1 do
                addr = w32address(addr,offset[i])
            end for
            offset=offset[length(offset)]
        end while
        return w32ElemAddr(addr,offset)
    end if
end function
radd=routine_id("w32address")

------ Storing -----

--/topic Memory management
--/proc w32copy_field(atom struct,sequence s,atom origin)
--/desc Copies contents of the field of the structure at /i origin described by /i s to /i struct.
global procedure w32copy_field(atom struct,sequence s,atom origin)
    integer sel,var,units
    atom addr

    while sequence(s[1]) do  -- nested fields
        for i=1 to length(s)-1 do
            origin = w32address(origin,s[i])
        end for
        s=s[length(s)]
    end while
    if find(s[fieldType],vFillers) then -- can't store to fillers
        return
    end if
    if sequence(s[arrayCount]) then -- what's the source array length?
        s[arrayCount]=getArrayCount(origin,s)
    end if
    units = check_array(s)
    if not units then
        return
    end if
    if s[unionSpec]=0 then -- source field is a union, which variant?
        sel=vLayouts[s[fieldType][descType]]
        var=call_func(unionSelectors[sel],{addr})
        s[fieldType]=unionVariants[sel][var]
    elsif s[unionSpec]>0 then
        s[fieldType]=unionVariants[vLayouts[s[fieldType][descType]]][s[unionSpec]]
    end if
    if s[unitSize]>0 and not s[isVirtual] then -- use raw emory copy
        addr=w32address(origin,s)
        mem_copy(struct,addr,s[unitSize]*units)
    else -- more complicated, fetch source value and then store it to new location
        call_proc(rsto,{struct,s,call_func(rfet,{origin,s})})
    end if
end procedure

--/topic Memory Management
--/proc w32copy_struct(atom struct,sequence id,atom origin)
--/desc Copies the structure whose base address is /i origin to /i struct, its type being /i id.
-- Assumes there is enough room at /i struct to store the structure
global procedure w32copy_struct(atom struct,sequence id,atom origin)
    integer fixed_size,is_v
    sequence layout

    id=id[1]
    is_v=vFirstVirtualFields[id[descType]]
    if length(id)=1 then
        fixed_size = vStructSizes[id[descType]]
    else
        fixed_size = id[descSize]
        if is_v > id[descNumFields] then
            is_v = 0
        end if
    end if
    -- copy fixed part
    mem_copy(struct,origin,fixed_size)
    -- anything left?
    if is_v then
        layout = vLayouts[id[descType]]
        if length(id)>1 then
            layout = layout[1..id[descNumFields]]
        end if
        -- copy following fields, whose position/length isn't fixed
        for i=is_v to length(layout) do
            call_proc(rsto,{struct,layout[i],call_func(rfet,{origin,layout[i]})})
        end for
    end if
end procedure

--/topic Memory management
--/proc w32poke_words(atom at,object words)
--/desc Poke one or more words at /i at.
-- /i words is either a single word or a sequence of them. All low words are then stored.
-- The caller is responsible to poke into memory s/he owns.
global procedure w32poke_words(atom at,object words)
    integer p,oddlen
    sequence data

    p=compare(words,{})
    if p=0 then
        return
    elsif p=-1 then
        words={words}
    end if
    words=floor(remainder(words,65536)) -- sanity check
    oddlen=and_bits(length(words),1)

    -- pack words into dwords
    data=repeat(0,(length(words)-oddlen)/2) -- first word poked apart if odd length
    p=1+oddlen
    for i=1 to length(data) do
        data[i]=words[p]+65536*words[p+1]
        p+=2
    end for

    -- store values
    if oddlen then
        l_SafePoke4(at+2,data)
        p=words[1]
        l_SafePoke(at,{p,floor(p/256)})
    else
        l_SafePoke4(at,data)
    end if

end procedure

procedure internal_store( atom struct, sequence s, object o,integer flag )

    -- Store the data based on its type. Doesn't handle virtual members in initially blank structs
    atom ram_addr
    object datatype
    integer lCnt,k,aligns
    atom    at
    sequence bytes

    if not flag then
        ram_addr = w32ElemAddr(struct, s)
    else
        ram_addr = struct
    end if
    datatype = s[fieldType]
    lCnt     = s[arrayCount]
    -- For sequences, make sure no more than lCnt elements are stored.
    if sequence(o) and integer(datatype) then
        if length(o) < lCnt then
            lCnt = length(o)
        end if
    end if

    -- write, based on datatype
    if sequence(datatype) then -- it was checked right by w32store()
        datatype=datatype[1]
        if length(datatype)=4 then
            bytes=vLayouts[datatype[descType]][1..datatype[descNumFields]]
            aligns=datatype[descNumAligns]
        else
            bytes=vLayouts[datatype[descType]]
            aligns=vNumAligns[datatype[descType]]
        end if
        if atom(o) then
            if length(datatype)=4 then
                lCnt=datatype[descSize]
            else
                lCnt=vStructSizes[datatype[descType]]
            end if
            mem_copy(ram_addr,o,lCnt)
            return
        elsif length(o)+aligns!=length(bytes) then
            return
        end if
        k=0
        for i=1 to length(bytes) do
            if not find(bytes[i][fieldType],vFillers) then
                call_proc(rsto,{struct,bytes[i],o[i-k]})
            else
                k+=1
            end if
        end for
    elsif datatype = Byte then
        -- poke a byte
        if atom(o) then
            l_SafePoke( ram_addr, o )
        else
            l_SafePoke(ram_addr, o[1 .. lCnt])
        end if
    elsif   datatype = Word then
        -- poke a word
        if atom(o) then
            l_SafePoke(ram_addr,{o,floor(o/256)})
        else
            w32poke_words(ram_addr,o)
        end if

    elsif   datatype = Long then
        -- poke long(s)
        if atom(o) then
            l_SafePoke4( ram_addr, o )
        else
            l_SafePoke4(ram_addr, o[1 .. lCnt])
        end if
    elsif   datatype = UInt then
        -- poke long(s)
        if atom(o) then
            l_SafePoke4( ram_addr, o )
        else
            l_SafePoke4(ram_addr, o[1 .. lCnt])
        end if

    elsif   datatype = Lpsz then
        -- if atom, treat as long
        if atom( o ) then
            l_SafePoke4( ram_addr, o )
        else
            -- poke the address of the allotted string
            l_SafePoke4( ram_addr, w32acquire_mem( struct, o  ) )
        end if

    elsif   datatype = Hndl then
        -- poke handle(s)
        if atom(o) then
            l_SafePoke4( ram_addr, o )
        else
            l_SafePoke4(ram_addr, o[1 .. lCnt])
        end if

    elsif   datatype = HndlAddr then
        -- poke a handle's address
        at = w32acquire_mem(struct, 4)
        l_SafePoke4( at, o)
        l_SafePoke4( ram_addr, at )

    elsif  datatype = Strz then
        -- poke a zero-terminated string
        bytes = o & 0
        if lCnt < s[arrayCount] then
            lCnt += 1
        end if
        l_SafePoke(ram_addr, bytes[1 .. lCnt])

    elsif  datatype = Single then
        if atom(o) then
            o = {o}
        end if
        if lCnt > length(o) then
            lCnt = length(o)
        end if
        for i = 1 to lCnt do
            l_SafePoke(ram_addr, atom_to_float32(o[i]))
            ram_addr += 4
        end for

    elsif  datatype = Double then
        if atom(o) then
            o = {o}
        end if
        if lCnt > length(o) then
            lCnt = length(o)
        end if
        for i = 1 to length(o) do
            l_SafePoke(ram_addr, atom_to_float64(o[i]))
            ram_addr += 8
        end for
    -- added CChris <oedoc@free.fr> Jan 2, 2007
    -- support for DBCS encoded strings
    elsif datatype=Upsz then
    -- store UTF-8 string as UTF-16
        if atom( o ) then
            l_SafePoke4( ram_addr, o )
        else
            bytes=repeat(0,2*length(o)+2)
            lCnt=1
            for i=1 to length(o) do
                bytes[lCnt]=o[i]
                lCnt+=2
            end for
            l_SafePoke4(ram_addr,w32acquire_mem(struct,bytes))
        end if
    elsif datatype = aszText then
        if atom( o ) then
            l_SafePoke4( ram_addr, o )
        else
            l_SafePoke4(ram_addr, w32acquire_mem(struct,o))
        end if
    elsif datatype = uszText then
        if atom( o ) then
            l_SafePoke4( ram_addr, o )
        else
            bytes=repeat(0,2*length(o)+2)
            lCnt=1
            for i=1 to length(o) do
                bytes[lCnt]=o[i]
                lCnt+=2
            end for
            l_SafePoke4(ram_addr,w32acquire_mem(struct,bytes))
        end if
    elsif datatype=asBuffer then
        if lCnt=1 then
            if sequence(o) then
                if equal(o[1],{}) then
                    l_SafePoke4(ram_addr,o[2])
                else
                    at=w32acquire_mem(struct,o)
                    l_SafePoke4(ram_addr,{at,length(o)})
                end if
            elsif o=0 then
                l_SafePoke4(ram_addr,{0,0})
            else -- for compatibility with old code which was setting address and length separately
                l_SafePoke4(ram_addr,o)
            end if
        else
            for i=1 to lCnt do
                if sequence(o[i]) then
                    if equal(o[i][1],{}) then
                        l_SafePoke4(ram_addr,o[i][2])
                    else
                        at=w32acquire_mem(struct,o[i])
                        l_SafePoke4(ram_addr,{at,length(o[i])})
                    end if
                else
                    l_SafePoke4(ram_addr,{0,0})
                end if
                ram_addr+=8
            end for
        end if
    elsif datatype=usBuffer then
        if lCnt=1 then
            if sequence(o) then
                if equal(o[1],{}) then
                    l_SafePoke4(ram_addr,o[2])
                else
                    at = w32acquire_mem(struct,length(o)*2)
                    w32poke_words(at,o)
                    l_SafePoke4(ram_addr,{at,length(o)})
                end if
            else
                l_SafePoke4(ram_addr,{0,0})
            end if
        else
            for i=1 to lCnt do
                if sequence(o[i]) then
                    if equal(o[i][1],{}) then
                        l_SafePoke4(ram_addr,o[i][2])
                    else
                        bytes = o[i]
                        at = w32acquire_mem(struct,length(bytes)*2)
                        w32poke_words(at,bytes)
                        l_SafePoke4(ram_addr,{at,length(bytes)})
                    end if
                else
                    l_SafePoke4(ram_addr,{0,0})
                end if
                ram_addr+=8
            end for
        end if
    elsif datatype = Rect then
        if lCnt = 1 then
            l_SafePoke4(ram_addr,o)
        else
            bytes = repeat(0,4*lCnt)
            k = 1
            for i =1 to lCnt do
                bytes[k..k+3]=o[i]
                k+=4
            end for
            l_SafePoke4(ram_addr,bytes)
        end if
    elsif datatype = Point then
        if lCnt = 1 then
            l_SafePoke4(ram_addr,o)
        else
            bytes = repeat(0,2*lCnt)
            k = 1
            for i =1 to lCnt do
                bytes[k..k+1]=o[i]
                k+=2
            end for
            l_SafePoke4(ram_addr,bytes)
        end if
    else
        -- poke a string
        l_SafePoke( ram_addr, o[1 .. lCnt] )
    -- else do nothing
    end if

end procedure

--/topic Memory Management
--/proc w32store( structure, field, value )
--/desc Store a value into a structure.
-- Type conversion is automatic. For example, if an /b Lpsz field is
-- used, the value is automatically converted from a sequence to a
-- C-style string, and the address of that string is stored in the
-- structure. /n
-- If /i field is a union, it must be specialised, so that w32store() knows how to store /i data.
-- If it is not, then the last known specialisation is used. Otherwise, you should call
-- /w32specialise() so as to get a specialised union which w32store() can handle.
--
-- Special rules apply to the asBuffer and usBuffer types. Normally, you'd store a string
-- in such a field. However:
--/li Using an atom stores the values 0 and 0;
--/li Storing a pair {{},{u,v}}, where u and v are atoms, store these values without any
-- reference to a string.  /n
-- Example:
--
--/code
--      -- allocate RECT structure, and populate it
--      atom rect
--
--      -- allocate the structure
--      rect = /w32acquire_mem(w32new_memset(), SIZEOF_RECT )
--
--      -- store values into the structure
--      /w32store( rect, rectLeft,   x1 )
--      /w32store( rect, rectTop,    y1 )
--      /w32store( rect, rectRight,  x2 )
--      /w32store( rect, rectBottom, y2 )
--
--      -- Here we store individual elements to an /w32allot array.
--      constant bCoords = w32allot( {4, Long} )
--      . . .
--      /w32store( rect, bCoords & 1, Col)
--      /w32store( rect, bCoords & 2, Row)
--/endcode

global procedure w32store(atom struct,sequence s,object x)
    integer p,q,item,len,arcount,u_index
    sequence s0,s1

    if equal(s,{}) then
        return
    end if
    while sequence(s[1]) do  -- this is a sequence of nested fields
        p=length(s)
        for i=1 to p-1 do
            struct=w32address(struct,s[i])
        end for
        s=s[p]
    end while
    if not s[isVirtual] then -- well known field, internal_store() can handle it
        internal_store(struct,s,x,0)
        return
    elsif find(s[fieldType],vFillers) then  -- can't store there
        return
    end if
    s0=virtualise(struct,s)
    p=s0[1]
    q=s0[2]
    s0=s[1..stdFieldEntry]
    if not q then
        if not virtualWasBlank[p] then
            q = addVirtualField(struct,s0)
        else -- should not happen
            return
        end if
    end if
    if sequence(s[fieldType]) and atom(vLayouts[s[fieldType][descType]]) then -- store to union
        u_index = vLayouts[s[fieldType][descType]]
        s1=unionVariants[u_index]
        if s[unionSpec]>0 then
            virtualUnions[p][q]=s[unionSpec]
            s[fieldType]=s1[s[unionSpec]]
        elsif s[unionSpec]=0 then -- union variant not specified
            item=call_func(unionDataInfer[u_index],{x})
            if item<1 or item>length(s1) then -- still don't know
                if virtualUnions[p][q] then -- perhaps previous type is just the best guess
                    s[fieldType]=s1[virtualUnions[p][q]]
                else
                    warnErr("Please specialise union fields when the inference routine cannot deect the variant correctly")
                    return
                end if
            else -- found it
                s[fieldType]=s1[item]
            end if
        end if
    end if
    if not s[isVirtual] then -- we have an address, use standard process
        s[fieldOffset] = virtualAddresses[p][q]
        internal_store(struct,s,x,1)
    elsif sequence(s[fieldType]) then -- structure type
        if atom(x) then
            w32copy_struct(struct,s[fieldType],x)
        else
            internal_store(virtualAddresses[p][q],s[fieldType],x,1)
        end if
    else
        if sequence(virtualIndSizes[p][q]) then
            if length(s)=stdFieldEntry then
                item=1
            else
                item=s[arrayPos]
            end if
            -- get array count
            if virtualStatus[p][q]=-2 then
                arcount=item
            elsif sequence(s[arrayCount]) then
                arcount=getArrayCount(struct,s)
            else
                arcount=s[arrayCount]
            end if
            len = length(virtualIndStatus[p][q])
            if item > len then -- dynamic size array originally blank
                virtualIndSizes[p][q] &= repeat(0,item-len)
                virtualIndStatus[p][q] &= repeat(-2,item-len-1)
                virtualIndStatus[p][q] &= 1
                virtualIndAddresses[p][q]&= repeat(0,item-len)
                if sequence(s[arrayCount]) and atom(s[arrayCount][1]) then
                    w32store(struct,s[arrayCount],item)
                end if
            end if
            virtualSizes[p][q]-=(virtualIndSizes[p][q][item]-length(x))
            virtualIndSizes[p][q][item] = length(x)+1+(s[fieldType]=uszText)  -- problem: s[fieldType] may be a sequence
            virtualIndStatus[p][q][item] = 1
            virtualIndAddresses[p][q][item] = w32acquire_mem(struct,x)
        else
            virtualSizes[p][q] = length(x)+1+(s[fieldType]=uszText)
            virtualAddresses[p][q] = w32acquire_mem(struct,x)
        end if
        virtualStatus[p][q] = 1
    end if
end procedure
rsto=routine_id("w32store")

------- Fetching --------

function internal_fetch( atom struct, sequence s )
    -- fetch the data based on the type
    integer cnt
    atom at

    cnt = check_array(s)
    if not cnt then
        return 0
    end if

    -- address is struct + fieldOffset
    if atom(s[fieldOffset]) and not s[isVirtual] then
        if length(s)<=stdFieldEntry then
            at = s[fieldOffset] + struct
        else
            at = s[fieldOffset] + struct + (s[arrayPos]-1) * s[unitSize]
        end if
    elsif cnt=1 then
        at = w32address(struct,s)
    else
        -- doesn't happen as w32fetch() has handled this case itself
        return 0
    end if
    return inner_fetch(struct,at,s[fieldType],cnt)
end function

integer rfrm  -- routine_id for w32from_memoryEx

--/topic Memory Management
--/func w32fetch( structure address, field )
--/desc Fetch field from structure.
--/ret OBJECT: Field from a structure.
-- Data conversion is automatic. For example, if the field is
-- an /b Lpsz, a sequence containing the string will automatically
-- be returned.
--
-- Example:
-- /code
--      -- fetch the average character width from the text metrics structure
--      width = /w32fetch( tm, tmAveCharWidth )
--
--      -- Here we get individual elements from an /w32allot array.
--      constant bCoords = w32allot( {4, Long} )
--      . . .
--      x = /w32fetch( rect, bCoords & 1)
--      y = /w32fetch( rect, bCoords & 2)
--
--      -- To get all the values at once
--      sequence coords
--      coords = /w32fetch( rect, bCoords)
--
-- /endcode

global function w32fetch(atom struct,sequence s)
    integer p,q,units
    sequence s0,result
    atom at

    while sequence(s[1]) do -- nested fields
        p=length(s)
        for i=1 to p-1 do
            struct=w32address(struct,s[i])
        end for
        s=s[p]
    end while
    if not s[isVirtual] then  --- standard processing
        return internal_fetch(struct,s)
    elsif sequence(s[fieldType]) then -- fall back on w32from_memoryEx()
        return call_func(rfrm,{w32address(struct,s),s[fieldType]})
    elsif find(s[fieldType],vFillers) then -- return dummy data
        return 0
    end if
    s0=virtualise(struct,s)
    p=s0[1]
    q=s0[2]
    s0=s[1..stdFieldEntry]
    if not q then
        if virtualWasBlank[p] then
            abortErr("Attempt to fetch a structure field that was not w32store()d first")
            return 0
        else
            q=addVirtualField(struct,s0)
        end if
    end if
    -- resolve unions
    if s[unionSpec]>0 then
        if s[unionSpec]=virtualUnions[p][q] then
            s[fieldType]=unionVariants[vLayouts[s[fieldType][strType]]][s[unionSpec]]
        else
            warnErr("Mismatch between stated and observed state of a union")
            return 0
        end if
    elsif s[unionSpec]=0 then
        s[fieldType]=unionVariants[vLayouts[s[fieldType][strType]]][virtualUnions[p][q]]
    end if
    -- resolve arrays (non arrays are arrays of length 1)
    -- then inner_fetch() will handle the job
    at = virtualAddresses[p][q]
    if sequence(s[arrayCount]) then
        s[arrayCount]=length(virtualIndAddresses[p][q])
    end if
    units=check_array(s)
    if not units then -- invalid array spec
        return 0
    elsif units=1 then
        return inner_fetch(struct,virtualIndAddresses[p][q][s[arrayPos]],s[fieldType],1)
    else
        result=repeat(0,units)
        units-=1
        for i=s[arrayPos] to s[arrayPos]+units do
            result[i-units]=inner_fetch(struct,virtualIndAddresses[p][q][i],s[fieldType],1)
        end for
        return result
    end if

end function
rfet=routine_id("w32fetch")

--------- Stitching together ---------

procedure devirtualise(integer p)
-- removes a structure from the virtual data system
    virtualStructs = w32removeIndex(p,virtualStructs)
    virtualTypes = w32removeIndex(p,virtualTypes)
    virtualFields = w32removeIndex(p,virtualFields)
    virtualAddresses = w32removeIndex(p,virtualAddresses)
    virtualStatus = w32removeIndex(p,virtualStatus)
    virtualOrgAddresses = w32removeIndex(p,virtualOrgAddresses)
    virtualSizes = w32removeIndex(p,virtualSizes)
    virtualIndAddresses = w32removeIndex(p,virtualIndAddresses)
    virtualIndStatus = w32removeIndex(p,virtualIndStatus)
    virtualIndOrgAddresses = w32removeIndex(p,virtualIndOrgAddresses)
    virtualIndSizes = w32removeIndex(p,virtualIndSizes)
    virtualWasBlank = w32removeIndex(p,virtualWasBlank)
    virtualUnions = w32removeIndex(p,virtualUnions)
end procedure

--/topic Memory management
--/func w32realise(atom struct,integer flag)
--/desc Rebuilds a contiguous memory structure, possibly discarding virtual info
--/ret (SEQUENCE) {Address of rebuilt structure,size of the structure}.
-- If you ever used w32store() on a variable length field in a structure, the targeted
-- member was most likely relocated. Since external code expects the structure to
-- occupy a contiguous space in memory, you have to call w32realise() to get the
-- address of a structure with the same data, but made   contiguous again.
-- /i struct is the address of the structure to rebuild;
-- /i memset is a memory set where to rebuild the structure;
-- /i flag is zero if you don't plan to reuse the structure again, so that the old
-- one and the support data are recycled.
-- As always, you are responsible for freeing the returned structure.
-- Note that, if the structure has Align fields, the created structure will use a slightly oversize
-- memory block. The amount of slack past the end of the structure is not greater than the sum of
-- the widths of the Align fields minus their number - usually only a few bytes.
global function w32realise(atom struct,integer flag)
-- general problem: compute the size of align fields while the address is not known
    integer p,totalsize,curr_len,q
    atom new_a,ptr
    sequence index,blocklist,sorted,s

    p=find(struct,virtualStructs)
    if p=0 or not find(1,virtualStatus[p]) then -- structure doesn't need realisation
        if p and flag then
            devirtualise(p)
        end if
        return struct
    end if
    -- some virtual fields were relocated

    if virtualWasBlank[p] then
        if find(-2,virtualStatus[p]) then
            warnErr("Some field(s) of a structure with variable length members were not assigned")
            return 0
        end if
        for i=1 to length(virtualFields[p]) do
            if sequence(virtualIndAddresses[p]) and find(-2,virtualIndAddresses[p]) then
                warnErr("Some field(s) of a structure with variable length members were not assigned")
                return 0
            end if
        end for
    end if
    -- can realise the struct, as all fields are defined somehow.

    -- get a {start,len} list for the known virtual part
    index = w32index_by(virtualFields[p],numField)
    ptr = struct
    blocklist = {}
    curr_len = 0
    for i=1 to length(index) do
        s=virtualFields[p][index[i]]
        if virtualStatus[p][index[i]]<1 then
            curr_len += virtualSizes[p][index[i]]
        elsif equal(s[fieldType],ByteFill) then
            curr_len += s[arrayCount]
        elsif equal(s[fieldType],Align) then
            if curr_len then
                blocklist=append(blocklist,{ptr,curr_len})
            end if
            blocklist=append(blocklist,{0,s[arrayCount]})
            ptr+=s[arrayCount]
            curr_len=0
        elsif equal(s[fieldType],AlignRel) then
            if curr_len then
                blocklist=append(blocklist,{ptr-struct,curr_len})
            end if
            blocklist=append(blocklist,{0,s[arrayCount]})
            ptr+=s[arrayCount]
            curr_len=0
        elsif atom(virtualIndSizes[p][index[i]]) then -- not an array
            if curr_len then
                blocklist=append(blocklist,{ptr,curr_len})
            end if
            blocklist=append(blocklist,{virtualAddresses[p][index[i]],virtualSizes[p][index[i]]})
            ptr+=(curr_len+virtualIndSizes[p][index[i]])
            curr_len=0
        else
            q=length(virtualIndAddresses[p][index[i]])
            for j=1 to q do
                if j=q and sequence(s[arrayCount]) and sequence(s[arrayCount][1]) and sequence(s[arrayCount][1][1]) then
                    -- mark the end of the array
                    call_proc(s[arrayCount][1][1][2],{virtualIndAddresses[p][index[i]][q]})
                end if
                if virtualIndStatus[p][index[i]][j]=-1 then
                    curr_len += virtualIndSizes[p][index[i]][j]
                else
                    if curr_len then
                        blocklist=append(blocklist,{ptr,curr_len})
                    end if
                    blocklist=append(blocklist,{virtualIndAddresses[p][index[i]][j],virtualIndSizes[p][index[i]][j]})
                    ptr+=(curr_len+virtualIndSizes[p][index[i]][j])
                    curr_len=0
                end if
            end for
            if sequence(virtualFields[p][index[i]]) then
                if sequence(s[1]) then
                    if curr_len then
                        blocklist=append(blocklist,{ptr,curr_len})
                    end if
                    q=length(s[1])
                    new_a=w32acquire_mem(struct,q)
                    poke(new_a,s[1])
                    blocklist=append(blocklist,{new_a,q})
                    ptr+=(curr_len+q)
                    curr_len=0
                end if
            end if
        end if
        if sequence(s[arrayCount]) and sequence(s[arrayCount][1]) then  -- poke array terminator
            if curr_len then
                blocklist=append(blocklist,{ptr,curr_len})
            end if
            q=length(s[arrayCount][1])
            new_a=w32acquire_mem(struct,q)
            poke(new_a,s[arrayCount][1])
            blocklist=append(blocklist,{new_a,q})
            ptr+=(curr_len+q)
            curr_len=0
        end if
    end for

    -- get the unknown end part
    if not virtualWasBlank[p] then -- otherwise, there is no end part
        index=virtualFields[p][index[length(index)]]
        sorted = vLayouts[virtualTypes[p]]
        s=sorted[index[numField]+1..length(sorted)]
        new_a = ptr
        for i=1 to length(s) do
            totalsize=fetchSize(struct,new_a,s[i],-1)
            curr_len+=totalsize
            new_a+=totalsize
        end for
        if curr_len then
            blocklist=append(blocklist,{ptr,curr_len})
        end if
    end if

    -- get info about fixed part
    curr_len=vStructSizes[virtualFields[p][1][strType]]

    -- create and copy
    totalsize=blocklist[1][2] -- this contains fixed part
    for i=2 to length(blocklist) do
        totalsize+=blocklist[i][2]
    end for
    new_a = w32acquire_mem(struct,totalsize+curr_len)
    -- copy fixed part
    mem_copy(new_a,struct,curr_len)
    ptr = new_a + curr_len
    -- copy all blocks in list
    for i=1 to length(blocklist) do
        if blocklist[i][1] then
            mem_copy(ptr,blocklist[i][1],blocklist[i][2])
            ptr+=blocklist[i][2]
        else -- alignment field
            q=remainder(ptr,blocklist[i][2])
            if q then
                ptr+=(q-blocklist[i][2])
            end if
        end if
    end for
    if flag then
        devirtualise(p)
    end if
    return {new_a,totalsize}
end function

--/topic Memory Management
--/func w32from_memoryEx(atom struct,sequence s,integer level)
--/desc Returns the fields of a structure.
--/ret (SEQUENCE) List of field values.
-- If a field is itself a structure, its address is returned if /i level is 0.
-- Use a positive value in /i level to define a maximum degree of recursion. Use -1 to resolve
-- at any depth (ie replacing an embedded structure address by a list of field values).
global function w32from_memoryEx(atom struct,sequence s,integer level)
    integer p,k
    sequence result

    if atom(s[1]) or sequence(s[1][1]) then
        return {}
    end if
    s=s[1]
    p=s[descType]
    if length(s)=1 then
        s=vLayouts[p]
        result=repeat(0,length(s)-vNumAligns[p])
    else
        s=s[1..s[descNumFields]]
        result=repeat(0,s[descNumFields]-s[descNumAligns])
    end if
    k=0
    for i=1 to length(s) do
        if find(s[i][fieldType],vFillers) then
            k+=1
        elsif atom(s[i][fieldType]) then
            result[i-k]=w32fetch(struct,s[i])
        elsif level=0 then
            result[i-k]=w32address(struct,s[i])
        else
            result[i-k]=w32from_memoryEx(w32address(struct,s[i]),s[i][fieldType],level-1)
        end if
    end for
    return result
end function
rfrm=routine_id("w32from_memoryEx")

--/topic Memory Management
--/func w32from_memory(atom struct,sequence s)
--/desc Returns the fields of a structure.
--/ret (SEQUENCE) List of field values.
-- If a field is itself a structure, its address is returned. If you need actual data, use /w32from_memoryEx(),
-- which this function wraps.
-- No values are returned for filler fields: Align, AlignRel and ByteFill.
global function w32from_memory(atom struct,sequence s)
    return w32from_memoryEx(struct,s,0)
end function

--/topic Memory Management
--/proc w32set_memory(atom struct,sequence id,sequence data)
--/desc Performs the same function as /w32to_memory(), but stores data at address /i struct.
-- No realisation is attempted at /i addr.
global procedure w32set_memory(atom struct,sequence id,sequence data)
    integer num_fields,num_aligns
    sequence layout

    id=id[1]
    layout=vLayouts[id[descType]]
    if length(id)=1 then
        num_fields=length(layout)
    else
        num_fields=id[descNumFields]
    end if
    num_aligns=0
    for i=1 to num_fields do
        if i-num_aligns>length(data) then
            exit
        elsif find(layout[i][fieldType],vFillers) then
            num_aligns+=1
        else
            w32store(struct,layout[i],data[i-num_aligns])
        end if
    end for
end procedure

--/topic Memory Management
--/func w32to_memoryEx(atom mem,sequence id,sequence data,integer flag)
--/desc Initialises memory structiure of given type with supplied data.
--/ret (ATOM) Address of initialised structure.
-- /i mem is the memory set to allocate from, /i id is a structure identifier, /i data is a sequence of field contents.
-- If /i flag is zero, a realised structure (see /w32realise()) will be created, otherwise,
-- a virtual structure addresss will be returned. The flag is ignored if there are no
-- variable length/position members. /w32to_memory() wraps this function with /i flag=0. /n
-- If supplied /i data is shorter than expected, trailing zeroes are automatically stored in
--  the corresponding fields. /n
global function w32to_memoryEx(atom mem,sequence id,object data,integer flag)
    atom addr
    integer strtype

    id=id[1]
    strtype=id[descType]
    if length(id)=1 then
        addr=w32acquire_mem(mem,vStructSizes[strtype])
    else
        addr=w32acquire_mem(mem,id[descSize])
    end if
    if not addr then
        return 0
    end if
    if vPreprocessDataIn[strtype]!=-1 then
        data=call_func(vPreprocessDataIn[strtype],{data})
    end if
    if atom(data) then
        if vStartWithSize[strtype] then
            poke4(addr,vStructSizes[strtype])
        end if
        return addr
    end if
    if vStartWithSize[strtype] then
        data=prepend(data,vStructSizes[strtype])
    end if

    w32set_memory(addr,{id},data)

    if flag then
        return addr
    else
        return w32realise(addr,0)
    end if
end function

--/topic Memory Management
--/func w32to_memory(sequence id,sequence data)
--/desc Initialises memory structiure of given type with supplied data.
--/ret (ATOM) Address of initialised structure.
-- /i id is a structure identifier, /i data is a sequence of field contents.
-- If there are variable length/position members, use /w32to_memoryEx() instead. /n
-- If supplied /i data is shorter than expected, trailing zeroes are automatically stored in
--  the corresponding fields. /n
-- This function supersedes most of the struct_XXX() functions, at least those which don't
-- process their arguments.
-- When structures start with the structure size, this value is automatically prepended to
-- /i data, so that you need not bother with it.
-- Align, ByteFill and AlignRel fields are ignored, you should not to supply filler values.
global function w32to_memory(atom mem,sequence id,object data)
    return w32to_memoryEx(mem,id,data,0)
end function

--/topic Memory Management
--/proc setPreProcessDataIn(sequence id,integer rid)
--/desc Sets up a routine to preprocess data fed to /w32to_memory() for a given type of structure.
-- The preprocess routine must take a sequence and return a sequence.
-- Preprocess routines apply to all short structures derived from/from which derives /i id.
global procedure setPreprocessDataIn(sequence id,integer rid)
    vPreprocessDataIn[id[1][descType]]=rid
end procedure

--/topic Memory Management
--/proc setStartWithSize(sequence struct_id)
--/desc Indicates to w32to_memory() that, when filling a structure of this type, its size should be plugged in as the first field.
-- Once taken, this decision cannot be rolled back. It simply avoids repetitively specifying the size as the first data item./n
-- The following structure identifiers are already marked for this optimisation:
--/li ID_OSVERSIONINFOEX
--/li ID_INITCOMMONCONTROLSEX
--/li ID_WINDOWINFO
--/li ID_MENUITEMINFO
--/li ID_WNDCLASSEX
--/li ID_SCROLLINFO
--/li ID_COLORDLG
--/li ID_DOCINFO
--/li ID_DRAWTEXTPARAMS
--/li ID_OPENFILENAME
--/li ID_BITMAPINFOHEADER
--/li ID_PAGESETUPDLG
--/li ID_CHARFORMAT
--/li ID_TOOLINFO
--/li ID_REBARBANDINFO
--/li ID_OUTLINETEXTMETRIC
--/li ID_PARAFORMAT

global  procedure setStartWithSize(sequence struct_id)
    vStartWithSize[struct_id[1][descType]]=1
end procedure

--/topic Memory Management
--/func isFieldOf(sequence field,sequence struct_type)
--/desc Determines whether /i field is a field of the /i struct_type structure type.
--/ret (INTEGER) w32True if the field belongs to the structure, else w32False.
-- /i field may be a nested field, in which case the leading field only is tested./n
-- /i struct_type is a structure identifier, an ID_* constant or anything created by /w32define_this_struct().
global function isFieldOf(sequence field,sequence struct_type)
    integer pos

    if sequence(field[1]) then
        field=field[1]
    end if
    struct_type = struct_type[1]
    if length(field)<stdFieldEntry then
        return w32False -- bad field
    else  -- remove all array and union stuff
        field = field[1..stdFieldEntry]
        if field[unionSpec]>0 then
            field[unionSpec]=0
        end if
    end if
    pos=find(field,vLayouts[struct_type[descType]])
    if not pos then
        return w32False -- field not found
    elsif length(struct_type)>1 and pos>struct_type[descNumFields] then
        return w32False -- field belongs to parent structure(s) only
    else
        return w32True
    end if
end function

-- w32DLL.ew

-- w32DLL.ew
-- This implements a strategy for delayed loading of DLL routines.
--

constant
   Err_LINKDLL = {"Couldn't find DLL '%s'", 465},
   Err_LINKFUNC = {"Couldn't link to C function '%s'", 464},
   Err_LINKPROC = {"Couldn't link to C procedure '%s'", 463},
   Err_BADFUNCID = {"An unknown GUI function ID used.", 425}

-- DLL Links
sequence vw32Libraries
vw32Libraries = {}

sequence vw32Routines
vw32Routines = repeat({}, 400)

integer vNextRtn
vNextRtn = 1

constant kMagicRtnID = #80000

--/topic Low Level Routines
--/func registerw32Library(sequence name)
--/desc Associates an internal id number with the library name.
--ret (INTEGER) An identifier for the library, to be used in /registerw32Function or /registerw32Procedure.
-- /i name is either a DLL name or a list of DLL names. If a list, then they
-- are tried from left to right until one is linked.
--
-- The library is not actually opened until it's first usage.
--
--Example
--/code
--     atom libRichEdit, libUser
--     -- Use riched20 if possible else use riched32
--     libRichEdit = registerw32Library({"riched20.dll", "riched32.dll"} )
--
--     libUser = registerw32Library("user32.dll")
--
--/endcode
global function registerw32Library(sequence libname)

    vw32Libraries &= {{{0,0}, libname}}
    return length(vw32Libraries)
end function

--/topic Low Level Routines
--/func registerw32Function( dll, name, args, result )
--/desc Associates an internal id number with the function name.
--/ret (INTEGER) An identifier for the function, to be used in /w32Func
--
--The library function is not actually linked until its first usage.
--
-- Example:
--/code
--      xLoadIcon = registerw32Function(user32, "LoadIconA", {C_POINTER, C_POINTER}, C_POINTER)
--/endcode
global function registerw32Function(integer libid, sequence name,
	    	        sequence signature, integer returntype)
    integer rid
    if vNextRtn > length(vw32Routines) then
        vw32Routines &= repeat({}, 10)
    end if

    vw32Routines[vNextRtn] = { -libid, name, signature, returntype}
    rid = vNextRtn + kMagicRtnID
    vNextRtn += 1
    return rid

end function

--/topic Low Level Routines
--/func registerw32Procedure( dll, name, args )
--/desc Associates an internal id number with the procedure name.
--/ret (INTEGER) An identifier for the procedure, to be used in /w32Proc
--
--The library procedure is not actually linked until its first usage.
--
-- Example:
--/code
--      constant xKillTimer = registerw32Procedure(user32, "KillTimer", {C_POINTER, C_UINT})
--/endcode

global function registerw32Procedure(integer libid, sequence name,
	    	        sequence signature)
    integer rid
    if vNextRtn > length(vw32Routines) then
        vw32Routines &= repeat({}, 10)
    end if

    vw32Routines[vNextRtn] = { -libid, name, signature}
    rid = vNextRtn + kMagicRtnID
    vNextRtn += 1
    return rid

end function

-----------------------------------------------------------------------------
function linkDLL(sequence name)

    -- dynamically link a DLL
    object handle

    handle = {0,0}

    if atom(name[1]) then
        name = {name}
    end if

    -- open the dll
    for i = 1 to length(name) do
        handle[2] = open_dll( name[i] )
        if handle[2] != NULL then
            handle[1] = i
            exit
        end if
    end for

    if handle[2] = NULL then
        abortErr( append(Err_LINKDLL , {name[1]}))
    end if
    return handle

end function


-----------------------------------------------------------------------------

function linkFunc(atom dll, sequence name, sequence args, atom result)

    -- dynamically link a C routine as a Euphoria function
    integer handle

    handle = define_c_func(dll, name, args, result)
    if handle = -1 then
    abortErr( append(Err_LINKFUNC, {name}))
    end if
    return handle
end function

-----------------------------------------------------------------------------
function linkProc(atom dll, sequence name, sequence args)

    integer handle

    handle = define_c_proc(dll, name, args)
    if handle = -1 then
    -- give error and abort
    abortErr( append(Err_LINKPROC, {name}) )
    end if
    return handle
end function

--/topic Low Level Routines
--/func w32Func(atom funcid, sequence parms)
--/desc Invoke a Windows function.
--/ret (ATOM) The value from the windows function is returned.
--The function to invoke is supplied in /i funcid. This can either be an
--identifier returned by /registerw32Function() or one returned by define_c_func().
--
-- The parameters for the function are contained in the sequence /i parms.
--
--Example:
--/code
--    -- Get the width of the screen.
--    screenCX = w32Func(xGetSystemMetrics, {SM_CXSCREEN})
--/endcode

global function w32Func(atom funcid, sequence parms)
    object lRC
    atom libfunc
    object lFuncDef
    object linked
    atom memset

    memset = 0
    for i = 1 to length(parms) do
        if sequence(parms[i]) then
            if memset = 0 then
                memset = w32new_memset()
            end if
            parms[i] = w32acquire_mem(memset, parms[i])
        end if
    end for

    if funcid > kMagicRtnID then
    funcid -= kMagicRtnID
    if funcid <= length(vw32Routines) then
        lFuncDef = vw32Routines[funcid]

        if sequence(lFuncDef) then
	    if lFuncDef[1] < 0 then
	        lFuncDef[1] = -lFuncDef[1]
	        if vw32Libraries[lFuncDef[1]][1][1] = 0 then
	        vw32Libraries[lFuncDef[1]][1] =
	    	    linkDLL(vw32Libraries[lFuncDef[1]][2])
	        end if
	        lFuncDef[1] = vw32Libraries[lFuncDef[1]][1][2]
	    end if

	    lFuncDef = linkFunc(lFuncDef[1], -- library
	    	          lFuncDef[2], -- function name
	    	          lFuncDef[3], -- param signature
	    	          lFuncDef[4] -- return type
	    	          )
	    vw32Routines[funcid] = lFuncDef
        end if

        lRC = c_func(lFuncDef, parms)
    else
        abortErr(Err_BADFUNCID)
    end if
    else
    if funcid > 0 then
        lRC = c_func(funcid, parms)
    else
        abortErr(Err_BADFUNCID)
    end if
    end if

    if memset != 0 then
        w32release_mem(memset)
    end if

    return lRC
end function

--/topic Low Level Routines
--/proc w32Proc(atom procid, sequence parms)
--/desc Invoke a Windows procedure.
--The procedure to invoke is supplied in /i procid. This can either be an
--identifier returned by /registerw32Procedure() or one returned by define_c_proc().
--
-- The parameters for the procedure are contained in the sequence /i parms.
--
--Example:
--/code
--    -- Force the window to be updated now.
--    w32Func(xUpdateWindow, {getHandle(myWin)})
--/endcode
global procedure w32Proc(atom funcid, sequence parms)
    atom libfunc
    object lFuncDef

    atom memset

    memset = 0
    for i = 1 to length(parms) do
        if sequence(parms[i]) then
            if memset = 0 then
                memset = w32new_memset()
            end if
            parms[i] = w32acquire_mem(memset, parms[i])
        end if
    end for


    if funcid > kMagicRtnID then
    funcid -= kMagicRtnID
    if funcid <= length(vw32Routines) then
        lFuncDef = vw32Routines[funcid]

        if sequence(lFuncDef) then
	    if lFuncDef[1] < 0 then
	        lFuncDef[1] = -lFuncDef[1]
	        if vw32Libraries[lFuncDef[1]][1][1] = 0 then
	        vw32Libraries[lFuncDef[1]][1] =
	    	    linkDLL(vw32Libraries[lFuncDef[1]][2])
	        end if
	        lFuncDef[1] = vw32Libraries[lFuncDef[1]][1][2]
	    end if

	    lFuncDef = linkProc(    lFuncDef[1], -- library
	    	          lFuncDef[2], -- function name
	    	          lFuncDef[3] -- param signature
	    	          )
	    vw32Routines[funcid] = lFuncDef
        end if

        c_proc(lFuncDef, parms)
    else
        abortErr(Err_BADFUNCID)
    end if
    else
    if funcid > 0 then
        c_proc(funcid, parms)
    else
        abortErr(Err_BADFUNCID)
    end if
    end if


    if memset != 0 then
        w32release_mem(memset)
    end if

end procedure


--/topic Constant
--/const riched32
--/desc Windows Library: Rich Edit Control

global constant
     riched32    =
registerw32Library({"Msftedit.dll","riched20.dll","riched32.dll"}),
    -- Rich Edit control
     WC_RICHEDIT10       = "RICHEDIT",
     WC_RICHEDIT20       = "RichEdit20A",
     WC_RICHEDIT50       = "RICHEDIT50W"
global sequence WC_RICHEDIT

vw32Libraries[riched32][1] = linkDLL(vw32Libraries[riched32][2])
if vw32Libraries[riched32][1][1] = 1 then
     WC_RICHEDIT = WC_RICHEDIT50

elsif vw32Libraries[riched32][1][1] = 2 then
     WC_RICHEDIT = WC_RICHEDIT20

else
     WC_RICHEDIT = WC_RICHEDIT10
end if

-- w32comctl.ew

--/topic Constant
--/const comctl32
--/desc Windows Library: Common Controls

global constant
--    comctl32            = registerw32Library("C:\\WINDOWS\\I386\\ASMS\\6000\\MSFT\\WINDOWS\\COMMON\\CONTROLS\\COMCTL32.DLL"),  -- common controls
   comctl32            = registerw32Library("comctl32.dll"),  -- common controls

    xInitCommonControls = registerw32Procedure(comctl32,"InitCommonControls",{}),
    xInitCommonControlsEx = registerw32Function(comctl32,"InitCommonControlsEx",{C_LONG}, C_INT),
    ImageList_Create    = registerw32Function( comctl32, "ImageList_Create", {C_INT, C_INT, C_LONG, C_INT, C_INT}, C_LONG),
    ImageList_AddIcon   = registerw32Function( comctl32, "ImageList_AddIcon", {C_LONG, C_LONG}, C_LONG),
    ImageList_GetImageCount = registerw32Function( comctl32, "ImageList_GetImageCount", {C_LONG}, C_LONG),
    ImageList_DragMove  = registerw32Function( comctl32, "ImageList_DragMove", {C_LONG, C_LONG}, C_LONG),
    ImageList_BeginDrag = registerw32Function( comctl32, "ImageList_BeginDrag", {C_LONG, C_LONG, C_LONG, C_LONG}, C_LONG),
    ImageList_EndDrag   = registerw32Function( comctl32, "ImageList_EndDrag", {}, C_LONG),
    ImageList_DrawEx    = registerw32Procedure( comctl32, "ImageList_DrawEx", {C_LONG, C_INT, C_INT, C_INT, C_INT, C_INT, C_LONG, C_LONG, C_UINT} ),
    ImageList_Add       = registerw32Function( comctl32, "ImageList_Add", { C_LONG, C_LONG, C_LONG }, C_LONG ),
    ImageList_AddMasked = registerw32Function( comctl32, "ImageList_AddMasked", { C_LONG, C_LONG, C_LONG }, C_LONG ),
    ImageList_SetBkColor= registerw32Function( comctl32, "ImageList_SetBkColor", { C_LONG, C_LONG }, C_INT ),
    ImageList_GetIcon   = registerw32Function( comctl32, "ImageList_GetIcon", { C_LONG, C_LONG,C_LONG }, C_INT ),
    xCreateToolbarEx    = registerw32Function( comctl32, "CreateToolbarEx", repeat( C_LONG, 13), C_POINTER ),

    ILD_NORMAL = 0

-- w32user.ew

-- get handles to all dll routines that we need
--/topic Constant
--/const user32
--/desc Windows Library: User Interface

global constant
    -- link to the dlls
    user32      = registerw32Library("user32.dll"),    -- user interface

    xSetParent          = registerw32Function(user32, "SetParent", {C_ULONG, C_ULONG}, C_ULONG),
    xGetParent          = registerw32Function(user32, "GetParent", {C_ULONG},C_ULONG),
    xEnumChildWindows   = registerw32Function(user32, "EnumChildWindows",{C_ULONG,C_POINTER,C_ULONG},C_INT),
    xGetDoubleClickTime = registerw32Function(user32, "GetDoubleClickTime", {}, C_LONG),
-- creating windows
    xLoadIcon           = registerw32Function(user32, "LoadIconA", {C_POINTER, C_POINTER}, C_POINTER),
    xDestroyIcon        = registerw32Function(user32, "DestroyIcon", {C_POINTER}, C_UINT),
    xGetIconInfo           = registerw32Function(user32, "GetIconInfo", {C_POINTER, C_POINTER}, C_INT),
    xRegisterClassEx    = registerw32Function(user32, "RegisterClassExA", {C_POINTER}, C_POINTER),
    xUnregisterClass    = registerw32Function(user32, "UnregisterClassA", {C_POINTER, C_POINTER}, C_LONG),
    xCreateWindow       = registerw32Function(user32, "CreateWindowExA", {C_LONG,C_POINTER,C_POINTER,C_LONG,C_INT,C_INT,C_INT,C_INT,C_POINTER,C_POINTER,C_POINTER,C_POINTER}, C_UINT),
    xCreateMDIWindow    = registerw32Function(user32, "CreateMDIWindowA", {C_POINTER,C_POINTER,C_UINT,C_INT,C_INT,C_INT,C_INT,C_POINTER,C_POINTER,C_INT}, C_UINT),
    xGetClassName       = registerw32Function(user32, "GetClassNameA",{C_INT,C_INT,C_INT},C_INT),
    xShowWindow         = registerw32Function(user32, "ShowWindow", {C_POINTER, C_INT}, C_INT),
    xUpdateWindow       = registerw32Procedure(user32, "UpdateWindow", {C_POINTER}),
    xSetForegroundWindow = registerw32Function(user32, "SetForegroundWindow", {C_POINTER}, C_POINTER ),
    xGetForegroundWindow = registerw32Function(user32, "GetForegroundWindow", {}, C_INT ),
-- cursors
    xLoadCursor         = registerw32Function(user32, "LoadCursorA", {C_POINTER, C_POINTER}, C_POINTER),
    xLoadCursorFromFile = registerw32Function(user32, "LoadCursorFromFileA", {C_POINTER}, C_POINTER),
    xSetCursor          = registerw32Function(user32, "SetCursor", {C_POINTER}, C_LONG),
    xSetCursorPos       = registerw32Procedure(user32, "SetCursorPos",{C_LONG,C_LONG}),
    xmouse_event        = registerw32Procedure(user32, "mouse_event",{C_LONG,C_LONG,C_LONG,C_LONG,C_LONG}),
    xShowCursor         = registerw32Function(user32, "ShowCursor", {C_INT}, C_INT),
    xCreateCursor       = registerw32Function(user32, "CreateCursor", {C_POINTER,C_INT,C_INT,C_INT,C_INT,C_POINTER,C_POINTER}, C_POINTER),
    xDestroyCursor      = registerw32Function(user32, "DestroyCursor", {C_POINTER}, C_LONG),
-- class addresses
    xGetClassLong       = registerw32Function(user32, "GetClassLongA", {C_POINTER, C_INT}, C_POINTER),
    xSetClassLong       = registerw32Function(user32, "SetClassLongA", {C_POINTER, C_INT, C_LONG}, C_POINTER),
-- message passing
    xPeekMessage        = registerw32Function(user32, "PeekMessageA", {C_POINTER,C_POINTER,C_UINT,C_UINT, C_UINT}, C_INT),
    xGetMessage         = registerw32Function(user32, "GetMessageA", {C_POINTER,C_POINTER,C_UINT,C_UINT}, C_INT),
    xGetMessageTime     = registerw32Function(user32, "GetMessageTime", {}, C_INT),
    xTranslateMessage   = registerw32Procedure(user32, "TranslateMessage", {C_INT}),
    xDispatchMessage    = registerw32Procedure(user32, "DispatchMessageA", {C_POINTER}),
    xGetQueueStatus     = registerw32Function(user32, "GetQueueStatus", {C_UINT}, C_UINT),
    xSendMessage        = registerw32Function(user32, "SendMessageA", {C_POINTER, C_UINT, C_LONG, C_LONG}, C_LONG),
    xGetClientRect      = registerw32Function(user32, "GetClientRect", {C_POINTER, C_POINTER}, C_INT),
    xDrawText           = registerw32Function(user32, "DrawTextA", {C_POINTER,C_POINTER,C_INT,C_POINTER,C_UINT}, C_LONG ),
    xDrawTextEx         = registerw32Function(user32, "DrawTextExA", {C_POINTER,C_POINTER,C_INT,C_POINTER,C_UINT, C_POINTER},C_LONG ),
    xDefWindowProc      = registerw32Function(user32, "DefWindowProcA", {C_POINTER,C_UINT,C_LONG,C_LONG}, C_LONG ),
    xDefFrameProc       = registerw32Function(user32, "DefFrameProcA", {C_POINTER,C_POINTER, C_UINT,C_LONG,C_LONG}, C_LONG ),
    xGetDC              = registerw32Function(user32, "GetDC", {C_POINTER}, C_UINT),
    xGetWindowDC              = registerw32Function(user32, "GetWindowDC", {C_POINTER}, C_UINT),
    xReleaseDC          = registerw32Function(user32, "ReleaseDC", {C_POINTER, C_POINTER}, C_INT),
-- update window support
    xBeginPaint         = registerw32Function(user32, "BeginPaint", {C_POINTER, C_POINTER}, C_INT),
    xEndPaint           = registerw32Procedure(user32, "EndPaint", {C_POINTER, C_POINTER}),
    xGetUpdateRect      = registerw32Function(user32, "GetUpdateRect", {C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xGetUpdateRgn       = registerw32Function(user32, "GetUpdateRgn", {C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xExcludeUpdateRgn   = registerw32Function(user32, "ExcludeUpdateRgn", {C_POINTER, C_POINTER}, C_LONG),
    xInvalidateRect     = registerw32Function(user32, "InvalidateRect", {C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xValidateRect       = registerw32Function(user32, "ValidateRect", {C_POINTER, C_POINTER}, C_LONG),
    xInvalidateRgn      = registerw32Function(user32, "InvalidateRgn", {C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xValidateRgn        = registerw32Function(user32, "ValidateRgn", {C_POINTER, C_POINTER}, C_LONG),
    xRedrawWindow       = registerw32Function(user32, "RedrawWindow", {C_POINTER, C_POINTER, C_POINTER, C_UINT}, C_LONG),
-- timers
    xSetTimer           = registerw32Procedure(user32, "SetTimer", {C_POINTER,C_UINT,C_UINT,C_POINTER} ),
    xKillTimer          = registerw32Procedure(user32, "KillTimer", {C_POINTER, C_UINT}),
    xSetWindowText      = registerw32Function(user32, "SetWindowTextA", {C_POINTER, C_POINTER}, C_INT),
    xGetWindowText      = registerw32Function(user32, "GetWindowTextA", {C_POINTER, C_POINTER, C_INT}, C_INT),
    xGetWindowTextLength= registerw32Function(user32, "GetWindowTextLengthA", {C_POINTER}, C_INT),
    xEnableWindow       = registerw32Procedure(user32, "EnableWindow", {C_POINTER, C_LONG}),
    xIsWindowVisible    = registerw32Function(user32, "IsWindowVisible", {C_POINTER}, C_INT),
    xIsWindowEnabled    = registerw32Function(user32, "IsWindowEnabled", {C_POINTER}, C_INT),
    xIsWindow           = registerw32Function(user32, "IsWindow", {C_POINTER}, C_INT),
    xIsIconic           = registerw32Function(user32, "IsIconic", {C_POINTER}, C_INT),
    xIsZoomed           = registerw32Function(user32, "IsZoomed", {C_POINTER}, C_INT),
    xGetKeyState        = registerw32Function(user32, "GetKeyState", {C_INT}, C_INT),
    xSetFocus           = registerw32Procedure(user32, "SetFocus", {C_POINTER} ),
    xGetWindowLong      = registerw32Function(user32, "GetWindowLongA", {C_POINTER, C_INT}, C_LONG ),
    xSetWindowLong      = registerw32Function(user32, "SetWindowLongA", {C_POINTER, C_INT, C_LONG}, C_INT),
    xCallWindowProc     = registerw32Function(user32, "CallWindowProcA", {C_POINTER, C_POINTER, C_UINT, C_LONG, C_LONG}, C_LONG),
-- menus
    xLoadMenu           = registerw32Function(user32, "LoadMenuA", {C_POINTER, C_POINTER}, C_LONG),
    xLoadMenuIndirect   = registerw32Function(user32, "LoadMenuIndirectA", {C_POINTER}, C_POINTER),
    xGetMenu            = registerw32Function(user32, "GetMenu", {C_POINTER}, C_POINTER),
    xSetMenu            = registerw32Function(user32, "SetMenu", {C_POINTER, C_POINTER}, C_LONG),
    xHiliteMenuItem     = registerw32Function(user32, "HiliteMenuItem", {C_POINTER, C_POINTER, C_UINT, C_UINT}, C_LONG),
    xGetMenuString      = registerw32Function(user32, "GetMenuStringA", {C_POINTER, C_UINT, C_POINTER, C_INT, C_UINT}, C_LONG),
    xGetMenuState       = registerw32Function(user32, "GetMenuState", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xGetMenuItemRect    = registerw32Function(user32, "GetMenuItemRect", {C_POINTER, C_POINTER, C_UINT, C_POINTER}, C_INT),
    xDrawMenuBar        = registerw32Function(user32, "DrawMenuBar", {C_POINTER}, C_LONG),
    xGetSystemMenu      = registerw32Function(user32, "GetSystemMenu", {C_POINTER, C_LONG}, C_POINTER),
    xCreateMenu         = registerw32Function(user32, "CreateMenu", {}, C_POINTER),
    xCreatePopupMenu    = registerw32Function(user32, "CreatePopupMenu", {}, C_POINTER),
    xDestroyMenu        = registerw32Function(user32, "DestroyMenu", {C_POINTER}, C_LONG),
    xCheckMenuItem      = registerw32Function(user32, "CheckMenuItem", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xEnableMenuItem     = registerw32Function(user32, "EnableMenuItem", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xGetSubMenu         = registerw32Function(user32, "GetSubMenu", {C_POINTER, C_INT}, C_POINTER),
    xGetMenuItemID      = registerw32Function(user32, "GetMenuItemID", {C_POINTER, C_INT}, C_UINT),
    xGetMenuItemCount   = registerw32Function(user32, "GetMenuItemCount", {C_POINTER}, C_INT),
    xInsertMenu         = registerw32Function(user32, "InsertMenuA", {C_POINTER, C_UINT, C_UINT, C_UINT, C_POINTER}, C_LONG),
    xAppendMenu         = registerw32Function(user32, "AppendMenuA", {C_POINTER, C_UINT, C_UINT, C_POINTER}, C_POINTER),
    xModifyMenu         = registerw32Function(user32, "ModifyMenuA", {C_POINTER, C_UINT, C_UINT, C_UINT, C_POINTER}, C_LONG),
    xRemoveMenu         = registerw32Function(user32, "RemoveMenu", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xDeleteMenu         = registerw32Function(user32, "DeleteMenu", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xSetMenuItemBitmaps = registerw32Function(user32, "SetMenuItemBitmaps", {C_LONG, C_UINT, C_UINT, C_POINTER, C_POINTER}, C_LONG),
    xGetMenuCheckMarkDimensions = registerw32Function(user32, "GetMenuCheckMarkDimensions", {}, C_LONG),
    xTrackPopupMenu     = registerw32Function(user32, "TrackPopupMenu", {C_POINTER, C_UINT, C_INT, C_INT, C_INT, C_POINTER, C_POINTER}, C_LONG),
    xCheckMenuRadioItem = registerw32Function(user32,"CheckMenuRadioItem",{C_LONG, C_UINT, C_UINT, C_UINT, C_UINT}, C_USHORT),
    xSetMenuItemInfo    = registerw32Function(user32, "SetMenuItemInfoA",{C_POINTER, C_UINT, C_UINT, C_POINTER}, C_UINT),
    xGetMenuItemInfo    = registerw32Function(user32, "GetMenuItemInfoA",{C_POINTER, C_UINT, C_UINT, C_POINTER}, C_UINT),
    xIsMenu             = registerw32Function(user32, "IsMenu", {C_POINTER}, C_INT),
-- messages
    xPostMessage        = registerw32Function(user32, "PostMessageA", {C_POINTER, C_UINT, C_INT, C_LONG}, C_LONG),
    xPostQuitMessage    = registerw32Procedure(user32, "PostQuitMessage", {C_INT}),
    xMapWindowPoints    = registerw32Function(user32, "MapWindowPoints", {C_POINTER, C_POINTER, C_POINTER, C_INT}, C_INT),
    xGetCursorPos       = registerw32Function(user32, "GetCursorPos", {C_POINTER}, C_INT),
-- system colors
    xGetSysColor        = registerw32Function(user32, "GetSysColor", {C_INT}, C_LONG),
    xSetSysColors       = registerw32Function(user32, "SetSysColors", {C_INT, C_POINTER, C_LONG}, C_LONG),
    xLoadImage          = registerw32Function(user32, "LoadImageA",{C_POINTER, C_POINTER, C_UINT, C_INT, C_INT, C_UINT}, C_POINTER ),
-- scroll bars
    xSetScrollPos       = registerw32Function(user32, "SetScrollPos", {C_POINTER, C_INT, C_INT, C_LONG}, C_INT),
    xGetScrollPos       = registerw32Function(user32, "GetScrollPos", {C_POINTER, C_INT}, C_INT),
    xSetScrollRange     = registerw32Function(user32, "SetScrollRange", {C_POINTER, C_INT, C_INT, C_INT, C_LONG}, C_LONG),
    xGetScrollRange     = registerw32Function(user32, "GetScrollRange", {C_POINTER, C_INT, C_POINTER, C_POINTER}, C_LONG),
    xShowScrollBar      = registerw32Function(user32, "ShowScrollBar", {C_POINTER, C_INT, C_LONG}, C_LONG),
    xEnableScrollBar    = registerw32Function(user32, "EnableScrollBar", {C_POINTER, C_UINT, C_UINT}, C_LONG),
    xSetScrollInfo      = registerw32Function(user32, "SetScrollInfo", {C_POINTER, C_INT, C_POINTER, C_LONG}, C_INT),
    xGetScrollInfo      = registerw32Function(user32, "GetScrollInfo", {C_POINTER, C_INT, C_POINTER}, C_POINTER),
    xGetWindowRect      = registerw32Function(user32, "GetWindowRect", {C_POINTER, C_POINTER}, C_LONG),
    xClientToScreen     = registerw32Function(user32, "ClientToScreen", {C_POINTER, C_POINTER}, C_LONG),
    xScreenToClient     = registerw32Function(user32, "ScreenToClient", {C_POINTER, C_POINTER}, C_LONG),
    xCloseWindow        = registerw32Function(user32, "CloseWindow", {C_POINTER}, C_LONG),
    xMoveWindow         = registerw32Function(user32, "MoveWindow", {C_POINTER, C_INT, C_INT, C_INT, C_INT, C_LONG}, C_LONG),
    xSetWindowPos       = registerw32Function(user32, "SetWindowPos", {C_POINTER, C_POINTER, C_INT, C_INT, C_INT, C_INT, C_UINT}, C_LONG),
    xGetWindowPlacement = registerw32Function(user32, "GetWindowPlacement", {C_POINTER, C_POINTER}, C_LONG),
    xSetWindowPlacement = registerw32Function(user32, "SetWindowPlacement", {C_POINTER, C_POINTER}, C_LONG),
    xDestroyWindow      = registerw32Function(user32, "DestroyWindow", {C_POINTER}, C_LONG),
    xGetActiveWindow    = registerw32Function(user32, "GetActiveWindow", {}, C_POINTER ),
-- rectangles
    xDrawFocusRect      = registerw32Function(user32, "DrawFocusRect", {C_POINTER, C_POINTER}, C_LONG),
    xDrawFrameControl   = registerw32Function(user32, "DrawFrameControl", {C_POINTER, C_POINTER, C_UINT, C_UINT}, C_LONG),
-- carets
    xCreateCaret        = registerw32Function(user32, "CreateCaret", {C_POINTER, C_POINTER, C_LONG, C_LONG}, C_LONG ),
    xGetCaretBlinkTime  = registerw32Function(user32, "GetCaretBlinkTime", {}, C_LONG ),
    xSetCaretBlinkTime  = registerw32Function(user32, "SetCaretBlinkTime", {C_LONG}, C_LONG ),
    xDestroyCaret       = registerw32Function(user32, "DestroyCaret", {}, C_LONG ),
    xHideCaret          = registerw32Function(user32, "HideCaret", {C_POINTER}, C_LONG ),
    xShowCaret          = registerw32Function(user32, "ShowCaret", {C_POINTER}, C_LONG ),
    xSetCaretPos        = registerw32Function(user32, "SetCaretPos", {C_LONG, C_LONG}, C_LONG ),
    xGetCaretPos        = registerw32Function(user32, "GetCaretPos", {C_POINTER}, C_LONG ),
    xSetCapture         = registerw32Function(user32,"SetCapture",{C_UINT},C_INT),
    xReleaseCapture     = registerw32Procedure(user32,"ReleaseCapture",{}),
    xGetSystemMetrics   = registerw32Function(user32, "GetSystemMetrics", {C_INT},C_LONG),
    CopyImage           = registerw32Function( user32, "CopyImage", { C_LONG, C_UINT, C_INT, C_INT, C_UINT }, C_LONG ),
    RegisterWindowMessage = registerw32Function( user32, "RegisterWindowMessageA", { C_POINTER }, C_INT ),
    xFindWindow         = registerw32Function(user32, "FindWindowA", {C_POINTER,C_POINTER}, C_INT),
    ChildWindowFromPoint = registerw32Function( user32, "ChildWindowFromPoint",{ C_LONG, C_LONG }, C_LONG ),
    ChildWindowFromPointEx = registerw32Function( user32, "ChildWindowFromPointEx", { C_LONG, C_LONG, C_UINT }, C_LONG ),
    xGetWindowInfo      = registerw32Function( user32, "GetWindowInfo", {C_POINTER, C_POINTER}, C_LONG),
    xGetWindow          = registerw32Function( user32, "GetWindow", {C_LONG, C_LONG}, C_LONG),
    xGetFocus           = registerw32Function(user32, "GetFocus", {}, C_INT ),
    xSetWindowRgn       = registerw32Function(user32,"SetWindowRgn", {C_POINTER,C_POINTER, C_UINT},C_LONG),
    xLockWindowUpdate   = registerw32Function(user32,"LockWindowUpdate", {C_POINTER}, C_UINT),

-- Clipboard
    xChangeClipboardChain = registerw32Procedure(user32,"ChangeClipboardChain",{C_UINT,C_UINT}),
    xCloseClipboard     = registerw32Procedure(user32,"CloseClipboard",{}),
    xCountClipboardFormats = registerw32Function(user32,"CountClipboardFormats",{},C_INT),
    xEmptyClipboard     = registerw32Function(user32,"EmptyClipboard",{},C_INT),
    xEnumClipboardFormats = registerw32Function(user32,"EnumClipboardFormats",{C_UINT},C_UINT),
    xGetClipboardData   = registerw32Function(user32,"GetClipboardData",{C_UINT},C_UINT),
    xGetClipboardFormatName = registerw32Function(user32,"GetClipboardFormatNameA",{C_UINT,C_UINT,C_UINT},C_UINT),
    xGetClipboardOwner  = registerw32Function(user32,"GetClipboardOwner",{},C_UINT),
    xGetClipboardViewer = registerw32Function(user32,"GetClipboardViewer",{},C_UINT),
    xGetOpenClipboardWindow = registerw32Function(user32,"GetOpenClipboardWindow",{},C_UINT),
    xGetPriorityClipboardFormat = registerw32Function(user32,"GetPriorityClipboardFormat",{C_UINT,C_UINT},C_UINT),
    xIsClipboardFormatAvailable = registerw32Function(user32,"IsClipboardFormatAvailable",{C_UINT},C_INT),
    xOpenClipboard      = registerw32Function(user32,"OpenClipboard",{C_UINT},C_INT),
    xRegisterClipboardFormat = registerw32Function(user32,"RegisterClipboardFormatA",{C_UINT},C_UINT),
    xSetClipboardData   = registerw32Function(user32,"SetClipboardData",{C_UINT,C_UINT},C_UINT),
    xSetClipboardViewer = registerw32Function(user32,"SetClipboardViewer",{C_UINT},C_UINT),
    xBeep               = registerw32Function(user32, "MessageBeep", {C_INT},C_INT),
    xGetDialogBaseUnits = registerw32Function(user32, "GetDialogBaseUnits", {},C_INT),
    xSystemParametersInfo = registerw32Function(user32, "SystemParametersInfoA", {C_INT, C_POINTER,C_POINTER,C_INT},C_INT),
    xFillRect           = registerw32Function(user32, "FillRect",{C_POINTER,C_POINTER,C_POINTER},C_INT),
    xCharLowerBuff = registerw32Function(user32, "CharLowerBuffA", {C_POINTER, C_INT}, C_INT),
    xCharUpperBuff = registerw32Function(user32, "CharLowerBuffA", {C_POINTER, C_INT}, C_INT),
    xIsDialogMessage = registerw32Function(user32, "IsDialogMessage", {C_POINTER, C_POINTER}, C_INT)

global constant
    QS_KEY              = #0001,
    QS_MOUSEMOVE        = #0002,
    QS_MOUSEBUTTON      = #0004,
    QS_POSTMESSAGE      = #0008,
    QS_TIMER            = #0010,
    QS_PAINT            = #0020,
    QS_SENDMESSAGE      = #0040,
    QS_HOTKEY           = #0080,
    QS_ALLPOSTMESSAGE   = #0100,
    QS_MOUSE            = QS_MOUSEMOVE + QS_MOUSEBUTTON,
    QS_INPUT            = QS_MOUSE + QS_KEY,
    QS_ALLEVENTS        = QS_INPUT + QS_POSTMESSAGE + QS_TIMER + QS_PAINT + QS_HOTKEY,
    QS_ALLINPUT         = QS_ALLEVENTS + QS_SENDMESSAGE

global constant
    SPI_GETBEEP                 = 1,
    SPI_SETBEEP                 = 2,
    SPI_GETMOUSE                = 3,
    SPI_SETMOUSE                = 4,
    SPI_GETBORDER               = 5,
    SPI_SETBORDER               = 6,
    SPI_GETKEYBOARDSPEED       = 10,
    SPI_SETKEYBOARDSPEED       = 11,
    SPI_LANGDRIVER             = 12,
    SPI_ICONHORIZONTALSPACING  = 13,
    SPI_GETSCREENSAVETIMEOUT   = 14,
    SPI_SETSCREENSAVETIMEOUT   = 15,
    SPI_GETSCREENSAVEACTIVE    = 16,
    SPI_SETSCREENSAVEACTIVE    = 17,
    SPI_GETGRIDGRANULARITY     = 18,
    SPI_SETGRIDGRANULARITY     = 19,
    SPI_SETDESKWALLPAPER       = 20,
    SPI_SETDESKPATTERN         = 21,
    SPI_GETKEYBOARDDELAY       = 22,
    SPI_SETKEYBOARDDELAY       = 23,
    SPI_ICONVERTICALSPACING    = 24,
    SPI_GETICONTITLEWRAP       = 25,
    SPI_SETICONTITLEWRAP       = 26,
    SPI_GETMENUDROPALIGNMENT   = 27,
    SPI_SETMENUDROPALIGNMENT   = 28,
    SPI_SETDOUBLECLKWIDTH      = 29,
    SPI_SETDOUBLECLKHEIGHT     = 30,
    SPI_GETICONTITLELOGFONT    = 31,
    SPI_SETDOUBLECLICKTIME     = 32,
    SPI_SETMOUSEBUTTONSWAP     = 33,
    SPI_SETICONTITLELOGFONT    = 34,
    SPI_GETFASTTASKSWITCH      = 35,
    SPI_SETFASTTASKSWITCH      = 36,
    SPI_SETDRAGFULLWINDOWS     = 37,
    SPI_GETDRAGFULLWINDOWS     = 38,
    SPI_GETNONCLIENTMETRICS    = 41,
    SPI_SETNONCLIENTMETRICS    = 42,
    SPI_GETMINIMIZEDMETRICS    = 43,
    SPI_SETMINIMIZEDMETRICS    = 44,
    SPI_GETICONMETRICS         = 45,
    SPI_SETICONMETRICS         = 46,
    SPI_SETWORKAREA            = 47,
    SPI_GETWORKAREA            = 48,
    SPI_SETPENWINDOWS          = 49,
    SPI_GETHIGHCONTRAST        = 66,
    SPI_SETHIGHCONTRAST        = 67,
    SPI_GETKEYBOARDPREF        = 68,
    SPI_SETKEYBOARDPREF        = 69,
    SPI_GETSCREENREADER        = 70,
    SPI_SETSCREENREADER        = 71,
    SPI_GETANIMATION           = 72,
    SPI_SETANIMATION           = 73,
    SPI_GETFONTSMOOTHING       = 74,
    SPI_SETFONTSMOOTHING       = 75,
    SPI_SETDRAGWIDTH           = 76,
    SPI_SETDRAGHEIGHT          = 77,
    SPI_SETHANDHELD            = 78,
    SPI_GETLOWPOWERTIMEOUT     = 79,
    SPI_GETPOWEROFFTIMEOUT     = 80,
    SPI_SETLOWPOWERTIMEOUT     = 81,
    SPI_SETPOWEROFFTIMEOUT     = 82,
    SPI_GETLOWPOWERACTIVE      = 83,
    SPI_GETPOWEROFFACTIVE      = 84,
    SPI_SETLOWPOWERACTIVE      = 85,
    SPI_SETPOWEROFFACTIVE      = 86,
    SPI_SETCURSORS             = 87,
    SPI_SETICONS               = 88,
    SPI_GETDEFAULTINPUTLANG    = 89,
    SPI_SETDEFAULTINPUTLANG    = 90,
    SPI_SETLANGTOGGLE          = 91,
    SPI_GETWINDOWSEXTENSION    = 92,
    SPI_SETMOUSETRAILS         = 93,
    SPI_GETMOUSETRAILS         = 94,
    SPI_SETSCREENSAVERRUNNING  = 97,
    SPI_SCREENSAVERRUNNING     = SPI_SETSCREENSAVERRUNNING,
    SPI_GETFILTERKEYS          = 50,
    SPI_SETFILTERKEYS          = 51,
    SPI_GETTOGGLEKEYS          = 52,
    SPI_SETTOGGLEKEYS          = 53,
    SPI_GETMOUSEKEYS           = 54,
    SPI_SETMOUSEKEYS           = 55,
    SPI_GETSHOWSOUNDS          = 56,
    SPI_SETSHOWSOUNDS          = 57,
    SPI_GETSTICKYKEYS          = 58,
    SPI_SETSTICKYKEYS          = 59,
    SPI_GETACCESSTIMEOUT       = 60,
    SPI_SETACCESSTIMEOUT       = 61,
    SPI_GETSERIALKEYS          = 62,
    SPI_SETSERIALKEYS          = 63,
    SPI_GETSOUNDSENTRY         = 64,
    SPI_SETSOUNDSENTRY         = 65,
    SPI_GETSNAPTODEFBUTTON     = 95,
    SPI_SETSNAPTODEFBUTTON     = 96,
    SPI_GETMOUSEHOVERWIDTH     = 98,
    SPI_SETMOUSEHOVERWIDTH     = 99,
    SPI_GETMOUSEHOVERHEIGHT   = 100,
    SPI_SETMOUSEHOVERHEIGHT   = 101,
    SPI_GETMOUSEHOVERTIME     = 102,
    SPI_SETMOUSEHOVERTIME     = 103,
    SPI_GETWHEELSCROLLLINES   = 104,
    SPI_SETWHEELSCROLLLINES   = 105,
    SPI_GETMENUSHOWDELAY      = 106,
    SPI_SETMENUSHOWDELAY      = 107,
    SPI_GETSHOWIMEUI          = 110,
    SPI_SETSHOWIMEUI          = 111,
    SPI_GETMOUSESPEED         = 112,
    SPI_SETMOUSESPEED         = 113,
    SPI_GETSCREENSAVERRUNNING = 114,
    SPI_GETDESKWALLPAPER      = 115,
    SPI_GETACTIVEWINDOWTRACKING         = #1000,
    SPI_SETACTIVEWINDOWTRACKING         = #1001,
    SPI_GETMENUANIMATION                = #1002,
    SPI_SETMENUANIMATION                = #1003,
    SPI_GETCOMBOBOXANIMATION            = #1004,
    SPI_SETCOMBOBOXANIMATION            = #1005,
    SPI_GETLISTBOXSMOOTHSCROLLING       = #1006,
    SPI_SETLISTBOXSMOOTHSCROLLING       = #1007,
    SPI_GETGRADIENTCAPTIONS             = #1008,
    SPI_SETGRADIENTCAPTIONS             = #1009,
    SPI_GETKEYBOARDCUES                 = #100A,
    SPI_SETKEYBOARDCUES                 = #100B,
    SPI_GETMENUUNDERLINES               = SPI_GETKEYBOARDCUES,
    SPI_SETMENUUNDERLINES               = SPI_SETKEYBOARDCUES,
    SPI_GETACTIVEWNDTRKZORDER           = #100C,
    SPI_SETACTIVEWNDTRKZORDER           = #100D,
    SPI_GETHOTTRACKING                  = #100E,
    SPI_SETHOTTRACKING                  = #100F,
    SPI_GETMENUFADE                     = #1012,
    SPI_SETMENUFADE                     = #1013,
    SPI_GETSELECTIONFADE                = #1014,
    SPI_SETSELECTIONFADE                = #1015,
    SPI_GETTOOLTIPANIMATION             = #1016,
    SPI_SETTOOLTIPANIMATION             = #1017,
    SPI_GETTOOLTIPFADE                  = #1018,
    SPI_SETTOOLTIPFADE                  = #1019,
    SPI_GETCURSORSHADOW                 = #101A,
    SPI_SETCURSORSHADOW                 = #101B,
    SPI_GETUIEFFECTS                    = #103E,
    SPI_SETUIEFFECTS                    = #103F,
    SPI_GETFOREGROUNDLOCKTIMEOUT        = #2000,
    SPI_SETFOREGROUNDLOCKTIMEOUT        = #2001,
    SPI_GETACTIVEWNDTRKTIMEOUT          = #2002,
    SPI_SETACTIVEWNDTRKTIMEOUT          = #2003,
    SPI_GETFOREGROUNDFLASHCOUNT         = #2004,
    SPI_SETFOREGROUNDFLASHCOUNT         = #2005,
    SPI_GETCARETWIDTH                   = #2006,
    SPI_SETCARETWIDTH                   = #2007,

    MDIS_ALLCHILDSTYLES                 = #0001

-- w32comdlg.ew

--/topic Constants
--/const comdlg32
--/desc Windows Library: Common Dialogs

global constant comdlg32    = registerw32Library("comdlg32.dll"),  -- common dialogs

-- common dialogs
    xGetOpenFileName    = registerw32Function(comdlg32, "GetOpenFileNameA", {C_POINTER}, C_LONG),
    xGetSaveFileName    = registerw32Function(comdlg32, "GetSaveFileNameA", {C_POINTER}, C_LONG),
    xGetFileTitle       = registerw32Function(comdlg32, "GetFileTitleA", {C_POINTER, C_POINTER, C_INT}, C_INT),
    xChooseFont         = registerw32Function(comdlg32, "ChooseFontA", {C_POINTER},C_LONG),
    xPrintDlg           = registerw32Function(comdlg32, "PrintDlgA", {C_POINTER}, C_LONG),
    xPageSetupDlg       = registerw32Function(comdlg32, "PageSetupDlgA", {C_POINTER}, C_INT ),
    xColorDlg           = registerw32Function(comdlg32, "ChooseColorA", {C_POINTER}, C_LONG),
    FindTextA           = registerw32Function( comdlg32, "FindTextA", {C_LONG}, C_LONG ),
    ReplaceTextA        = registerw32Function( comdlg32, "ReplaceTextA", {C_LONG}, C_LONG ),
    CommDlgExtendedError = registerw32Function( comdlg32, "CommDlgExtendedError" , {}, C_LONG ),
    FINDMSGSTRING       = w32acquire_mem(0, "commdlg_FindReplace"),
    w32FindReplaceMsg     = w32Func( RegisterWindowMessage, { FINDMSGSTRING } )

-- w32gdi.ew

--/topic Constant
--/const gdi32
--/desc Windows Library: Graphic Device Interface (drawing, text, etc)

global constant
    gdi32       = registerw32Library("gdi32.dll"),     -- graphic device interface

    xGetStockObject     = registerw32Function(gdi32, "GetStockObject", {C_INT}, C_POINTER),
-- device context
    xSelectObject       = registerw32Function(gdi32, "SelectObject", {C_POINTER, C_POINTER}, C_POINTER),
    xCreateDC           = registerw32Function(gdi32, "CreateDCA", repeat( C_POINTER, 4 ), C_POINTER),
    xCreateIC           = registerw32Function(gdi32, "CreateICA", repeat( C_POINTER, 4 ), C_POINTER),
    xMoveToEx           = registerw32Function(gdi32, "MoveToEx", {C_POINTER, C_INT, C_INT, C_POINTER}, C_LONG),
-- graphics
    xCreatePen          = registerw32Function(gdi32, "CreatePen", {C_INT, C_INT, C_LONG}, C_POINTER),
    xCreateSolidBrush   = registerw32Function(gdi32, "CreateSolidBrush", {C_POINTER}, C_POINTER),
    xCreateHatchBrush   = registerw32Function(gdi32, "CreateHatchBrush", {C_UINT,C_POINTER}, C_POINTER),
    xCreatePatternBrush   = registerw32Function(gdi32, "CreatePatternBrush", {C_POINTER}, C_POINTER),
    xLineTo             = registerw32Function(gdi32, "LineTo", {C_POINTER, C_INT, C_INT}, C_LONG),
    xGetPixel           = registerw32Function(gdi32, "GetPixel", {C_POINTER, C_INT, C_INT}, C_LONG),
    xSetPixel           = registerw32Function(gdi32, "SetPixel", {C_POINTER, C_INT, C_INT, C_LONG}, C_LONG),
    xRectangle          = registerw32Function(gdi32, "Rectangle", {C_POINTER, C_INT, C_INT, C_INT, C_LONG}, C_LONG),
    xRoundRect          = registerw32Function(gdi32, "RoundRect", {C_POINTER, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT}, C_LONG),
    xEllipse            = registerw32Function(gdi32, "Ellipse", {C_POINTER, C_INT, C_INT, C_INT, C_INT}, C_LONG),
    xArc                = registerw32Function(gdi32, "Arc", {C_POINTER, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT}, C_LONG),
    xChord              = registerw32Function(gdi32, "Chord", {C_POINTER, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT}, C_LONG),
    xPie                = registerw32Function(gdi32, "Pie", {C_POINTER, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT}, C_LONG),
    xPolygon            = registerw32Function(gdi32, "Polygon", {C_POINTER, C_POINTER, C_INT}, C_LONG),
-- text
    xTextOut            = registerw32Procedure(gdi32, "TextOutA", {C_POINTER, C_INT, C_INT, C_POINTER, C_INT}),
-- used by EZ_FONT
    xSaveDC             = registerw32Function(gdi32, "SaveDC", {C_POINTER}, C_INT),
    xSetGraphicsMode    = registerw32Function(gdi32, "SetGraphicsMode", {C_POINTER, C_INT}, C_INT),
    xModifyWorldTransform = registerw32Function(gdi32, "ModifyWorldTransform", {C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xSetViewportOrgEx   = registerw32Function(gdi32, "SetViewportOrgEx", {C_POINTER, C_INT, C_INT, C_POINTER}, C_LONG),
    xSetWindowOrgEx     = registerw32Function(gdi32, "SetWindowOrgEx", {C_POINTER, C_INT, C_INT, C_POINTER}, C_LONG),
    xSetViewportExtEx   = registerw32Function(gdi32, "SetViewportExtEx", {C_LONG,C_INT,C_INT,C_INT},C_INT),
    xSetWindowExtEx     = registerw32Function(gdi32, "SetWindowExtEx",{C_LONG,C_INT,C_INT,C_POINTER},C_INT),
    xGetDeviceCaps      = registerw32Function(gdi32, "GetDeviceCaps", {C_POINTER, C_INT}, C_INT),
    xDPtoLP             = registerw32Function(gdi32, "DPtoLP", {C_POINTER, C_POINTER, C_INT}, C_LONG),
    xCreateFontIndirect = registerw32Function(gdi32, "CreateFontIndirectA", {C_POINTER}, C_POINTER),
    xGetTextMetrics     = registerw32Function(gdi32, "GetTextMetricsA", {C_POINTER, C_POINTER}, C_LONG),
    xGetOutlineTextMetrics     = registerw32Function(gdi32, "GetOutlineTextMetricsA", {C_POINTER, C_INT, C_POINTER}, C_LONG),
    xDeleteObject       = registerw32Function(gdi32, "DeleteObject", {C_POINTER}, C_LONG),
    xRestoreDC          = registerw32Function(gdi32, "RestoreDC", {C_POINTER, C_INT}, C_LONG),
    xGetTextExtentPoint = registerw32Function(gdi32, "GetTextExtentPoint32A", {C_POINTER, C_POINTER, C_INT, C_POINTER}, C_LONG),
-- graphic modes
    xSetMapMode         = registerw32Function(gdi32, "SetMapMode", {C_POINTER, C_INT}, C_INT),
    xGetMapMode         = registerw32Function(gdi32, "GetMapMode", {C_POINTER}, C_INT),
    xGetObject          = registerw32Function(gdi32, "GetObjectA", {C_POINTER, C_INT, C_POINTER}, C_POINTER),
    xGetObjectType      = registerw32Function(gdi32, "GetObjectType", {C_POINTER}, C_INT),
    xCreatePalette      = registerw32Function(gdi32, "CreatePalette", {C_POINTER}, C_POINTER),
-- bitmap graphics
    xGetWindowExtEx     = registerw32Function(gdi32, "GetWindowExtEx", {C_POINTER, C_POINTER}, C_POINTER),
    xCreateCompatibleBitmap = registerw32Function(gdi32, "CreateCompatibleBitmap", {C_POINTER, C_INT, C_INT}, C_POINTER),
    xSetBitmapBits      = registerw32Function(gdi32, "SetBitmapBits", {C_POINTER, C_LONG, C_POINTER}, C_LONG),
    xSelectPalette      = registerw32Function(gdi32, "SelectPalette", {C_POINTER, C_POINTER, C_LONG}, C_POINTER),
    xRealizePalette     = registerw32Function(gdi32, "RealizePalette", {C_POINTER}, C_UINT),
    xSetDIBitsToDevice  = registerw32Function(gdi32, "SetDIBitsToDevice", {C_POINTER, C_INT, C_INT, C_LONG, C_LONG, C_INT, C_INT, C_UINT, C_UINT, C_POINTER, C_POINTER, C_UINT}, C_INT),
    xStretchDIBits      = registerw32Function(gdi32, "StretchDIBits", {C_POINTER,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_POINTER,C_POINTER,C_UINT,C_LONG},C_INT),
    xBitBlt             = registerw32Function(gdi32, "BitBlt", {C_POINTER,C_INT,C_INT,C_INT,C_INT,C_POINTER,C_INT,C_INT,C_LONG},C_LONG),
    xSetROP2            = registerw32Function(gdi32, "SetROP2", {C_POINTER, C_LONG}, C_LONG ),
    xCreateCompatibleDC = registerw32Function(gdi32, "CreateCompatibleDC", {C_POINTER}, C_POINTER),
    xDeleteDC           = registerw32Function(gdi32, "DeleteDC", {C_POINTER}, C_POINTER),
    xCreateBitmap       = registerw32Function(gdi32, "CreateBitmap", {C_INT, C_INT, C_UINT, C_UINT, C_POINTER}, C_POINTER),
    xCreateBitmapIndirect = registerw32Function(gdi32, "CreateBitmapIndirect", {C_POINTER}, C_POINTER),
    xCreateDIBitmap     = registerw32Function(gdi32, "CreateDIBitmap", {C_POINTER, C_POINTER, C_LONG, C_LONG, C_POINTER, C_LONG}, C_POINTER ),
    xStretchBlt         = registerw32Function(gdi32, "StretchBlt",{ C_LONG,C_UINT,C_UINT,C_UINT,C_UINT,C_LONG,C_UINT,C_UINT,C_UINT,C_UINT,C_LONG},C_POINTER),
    xExtFloodFill       = registerw32Function(gdi32, "ExtFloodFill",{ C_POINTER,C_INT,C_INT,C_UINT,C_UINT},C_UINT),

-- extending the text attributes
    xSetTextColor       = registerw32Function(gdi32, "SetTextColor", {C_POINTER, C_LONG}, C_LONG),
    xSetTextAlign       = registerw32Function(gdi32, "SetTextAlign", {C_POINTER, C_UINT}, C_UINT),
    xSetTextJustification = registerw32Function(gdi32, "SetTextJustification", {C_POINTER, C_INT, C_INT}, C_LONG),
    xSetBkColor         = registerw32Function(gdi32, "SetBkColor", {C_POINTER, C_LONG}, C_LONG),
    xSetBkMode          = registerw32Function(gdi32, "SetBkMode", {C_POINTER, C_INT}, C_INT),
    xGetBkColor         = registerw32Function(gdi32, "GetBkColor", {C_POINTER}, C_LONG),
    xStartDoc           = registerw32Function(gdi32, "StartDocA", {C_LONG, C_POINTER}, C_LONG),
    xStartPage          = registerw32Function(gdi32, "StartPage", {C_LONG}, C_LONG),
    xEndPage            = registerw32Function(gdi32, "EndPage", {C_LONG}, C_LONG),
    xEndDoc             = registerw32Function(gdi32, "EndDoc", {C_LONG}, C_LONG),
    xAbortDoc           = registerw32Function(gdi32, "AbortDoc", {C_LONG}, C_LONG),
-- position of windows
    xGetViewportOrgEx   = registerw32Function(gdi32, "GetViewportOrgEx", {C_POINTER, C_POINTER}, C_LONG),
    xGetDIBits          = registerw32Function( gdi32, "GetDIBits",{ C_LONG, C_LONG, C_UINT, C_UINT, C_LONG, C_LONG, C_UINT }, C_LONG ),
    xCreateRectRgn      = registerw32Function(gdi32, "CreateRectRgn", {C_LONG, C_LONG,C_LONG,C_LONG},C_POINTER),
    xGetCurrentObject   = registerw32Function(gdi32, "GetCurrentObject", {C_LONG, C_LONG},C_POINTER),
    xLPtoDP=registerw32Function(gdi32,"LPtoDP",{C_POINTER,C_POINTER,C_LONG},C_LONG),


    OBJ_PEN            = 1,
    OBJ_BRUSH          = 2,
    OBJ_DC             = 3,
    OBJ_METADC         = 4,
    OBJ_PAL            = 5,
    OBJ_FONT           = 6,
    OBJ_BITMAP         = 7,
    OBJ_REGION         = 8,
    OBJ_METAFILE       = 9,
    OBJ_MEMDC          = 10,
    OBJ_EXTPEN         = 11,
    OBJ_ENHMETADC      = 12,
    OBJ_ENHMETAFILE    = 13,
    OBJ_COLORSPACE     = 14,

    FLOODFILLBORDER    = 0,
    FLOODFILLSURFACE   = 1,

    MM_TEXT            = 1,
    MM_LOMETRIC        = 2,
    MM_HIMETRIC        = 3,
    MM_LOENGLISH       = 4,
    MM_HIENGLISH       = 5,
    MM_TWIPS           = 6,
    MM_ISOTROPIC       = 7,
    MM_ANISOTROPIC     = 8,
    MM_MIN             = MM_TEXT,
    MM_MAX             = MM_ANISOTROPIC,
    MM_MAX_FIXEDSCALE  = MM_TWIPS

global constant
-- Stock Logical Objects
    WHITE_BRUSH = 0,
    LTGRAY_BRUSH = 1,
    GRAY_BRUSH = 2,
    DKGRAY_BRUSH = 3,
    BLACK_BRUSH = 4,
    NULL_BRUSH = 5,
    HOLLOW_BRUSH = NULL_BRUSH,
    WHITE_PEN = 6,
    BLACK_PEN = 7,
    NULL_PEN = 8,
    OEM_FIXED_FONT = 10,
    ANSI_FIXED_FONT = 11,
    ANSI_VAR_FONT = 12,
    SYSTEM_FONT = 13,
    DEVICE_DEFAULT_FONT = 14,
    DEFAULT_PALETTE = 15,
    SYSTEM_FIXED_FONT = 16,

    brush_white = w32Func( xGetStockObject, {WHITE_BRUSH}),
    brush_ltgray = w32Func( xGetStockObject, {LTGRAY_BRUSH}),
    brush_gray = w32Func( xGetStockObject, {GRAY_BRUSH}),
    brush_dkgray = w32Func( xGetStockObject, {DKGRAY_BRUSH}),
    brush_black = w32Func( xGetStockObject, {BLACK_BRUSH}),
    brush_null = w32Func( xGetStockObject, {NULL_BRUSH}),
    pen_white = w32Func( xGetStockObject, {WHITE_PEN}),
    pen_black = w32Func( xGetStockObject, {BLACK_PEN}),
    pen_null = w32Func( xGetStockObject, {NULL_PEN}),
    font_oem_fixed = w32Func( xGetStockObject, {OEM_FIXED_FONT}),
    font_ansi_fixed = w32Func( xGetStockObject, {ANSI_FIXED_FONT}),
    font_ansi_var = w32Func( xGetStockObject, {ANSI_VAR_FONT}),
    font_system = w32Func( xGetStockObject, {SYSTEM_FONT}),
    font_device_default = w32Func( xGetStockObject, {DEVICE_DEFAULT_FONT}),
    palette_default = w32Func( xGetStockObject, {DEFAULT_PALETTE}),
    font_system_fixed = w32Func( xGetStockObject, {SYSTEM_FIXED_FONT})
global constant
    STOCK_LAST = 16,
    -- null brush
    NullBrushID     = w32Func( xGetStockObject, { NULL_BRUSH } ),
    -- default pen
    DefaultPenID    = w32Func( xGetStockObject, {BLACK_PEN})

-- w32Kernel.ew

--/topic Constant
--/const kernel32
--/desc Windows Library: Memory and Basic Windows Core

global constant
    kernel32    = registerw32Library("kernel32.dll"),  -- memory

    xGetVersionEx       = registerw32Function(kernel32, "GetVersionExA", {C_POINTER},C_UINT),
-- memory
    xGlobalAlloc        = registerw32Function(kernel32, "GlobalAlloc", {C_UINT, C_LONG}, C_POINTER),
    xGlobalFree         = registerw32Function(kernel32, "GlobalFree", {C_POINTER}, C_POINTER),
    xDeleteFile         = registerw32Function(kernel32, "DeleteFileA",{C_POINTER},C_LONG),
    xMoveFile           = registerw32Function(kernel32, "MoveFileA",{C_POINTER,C_POINTER}, C_LONG),
    xCopyFile           = registerw32Function(kernel32, "CopyFileA",{C_POINTER,C_POINTER, C_LONG},C_LONG),
    xCreateDirectory    = registerw32Function(kernel32, "CreateDirectoryA",{C_POINTER, C_POINTER}, C_INT),
    xGetCurrentDirectory = registerw32Function(kernel32, "GetCurrentDirectoryA",{C_LONG,C_POINTER}, C_LONG),
    xSetCurrentDirectory = registerw32Function(kernel32, "SetCurrentDirectoryA",{C_POINTER}, C_LONG),
    xGetFullPathName    = registerw32Function(kernel32, "GetFullPathNameA",{ C_POINTER, C_LONG, C_POINTER, C_POINTER}, C_LONG),
    xGetLongPathName    = registerw32Function(kernel32, "GetLongPathNameA",{ C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xGetShortPathName   = registerw32Function(kernel32, "GetLongPathNameA",{ C_POINTER, C_POINTER, C_LONG}, C_LONG),
    xGetTempPath        = registerw32Function(kernel32, "GetTempPathA", {C_LONG, C_POINTER}, C_INT),
    xGetTempFileName    = registerw32Function(kernel32, "GetTempFileNameA", {C_POINTER, C_POINTER, C_UINT, C_POINTER}, C_INT),
    xGlobalLock         = registerw32Function(kernel32, "GlobalLock", {C_POINTER}, C_POINTER),
    xGlobalUnlock       = registerw32Function(kernel32, "GlobalUnlock",{C_POINTER},C_INT),
    xGlobalSize         = registerw32Function(kernel32, "GlobalSize", {C_POINTER},C_INT),
    xExitProcess        = registerw32Procedure(kernel32,"ExitProcess",{C_INT}),
    xGetLastError       = registerw32Function(kernel32, "GetLastError", {}, C_INT ),
    xSetLastError       = registerw32Procedure(kernel32, "SetLastError",{C_INT}),
    xCreateMutex        = registerw32Function(kernel32, "CreateMutexA",{C_POINTER,C_INT,C_POINTER},C_LONG),
    xReleaseMutex       = registerw32Function(kernel32, "ReleaseMutex",{C_LONG}, C_LONG),
    xCloseHandle        = registerw32Function(kernel32, "CloseHandle",{C_LONG}, C_LONG),
    xlstrcat            = registerw32Function(kernel32,"lstrcat",{C_POINTER, C_POINTER},C_POINTER),
    xlstrcmp            = registerw32Function(kernel32,"lstrcmp",{C_POINTER,C_POINTER},C_INT),
    xlstrcmpi           = registerw32Function(kernel32,"lstrcmpi",{C_POINTER,C_POINTER},C_INT),
    xlstrcpy            = registerw32Function(kernel32,"lstrcpy",{C_POINTER,C_POINTER},C_POINTER),
    xlstrcpyn           = registerw32Function(kernel32,"lstrcpyn",{C_POINTER,C_POINTER, C_INT},C_POINTER),
    xlstrlen            = registerw32Function(kernel32,"lstrlen",{C_POINTER},C_INT),
    xGetProfileString   = registerw32Function(kernel32,"GetProfileStringA",repeat(C_POINTER,5),C_INT),
    xSetFileAttributes  = registerw32Function(kernel32,"SetFileAttributesA",{C_POINTER, C_ULONG}, C_LONG),
    ---- System Time Date
    xGetSystemTime      = registerw32Procedure(kernel32,"GetSystemTime", {C_POINTER}),
    xGetLocalTime       = registerw32Procedure(kernel32,"GetLocalTime", {C_POINTER}),
    xSetUnhandledExceptionFilter = registerw32Function(kernel32,"SetUnhandledExceptionFilter",{C_POINTER},C_UINT),
    xGetLocaleInfo = registerw32Function(kernel32,"GetLocaleInfoA",{C_INT,C_INT,C_POINTER,C_INT},C_INT),
    xSleep         = registerw32Procedure(kernel32,"Sleep",{C_LONG}),

-- Constants
    ERROR_ALREADY_EXISTS = 183,
    EXCEPTION_EXECUTE_HANDLER = 1,
    EXCEPTION_CONTINUE_SEARCH = 0,
    EXCEPTION_CONTINUE_EXECUTION = -1,

    ATTR_NORMAL   = #00,   -- #00 is valid only if used alone.
    ATTR_READONLY = #01,   --   The other attributes can be added.
    ATTR_HIDDEN   = #02,
    ATTR_SYSTEM   = #04,
    ATTR_DIR      = #10,   -- #10 is ignored by set_attr().
    ATTR_ARCHIVE  = #20,   --   To create a directory, use the
                           --   CreateDirectory() function.

    LOCALE_USER_DEFAULT = #0800,
    LOCALE_IMEASURE = #0D,
    LOCALE_RETURN_NUMBER = #20000000


-- w32Shell.ew

--/topic Constant
--/const shell32
--/desc Windows Library: Shell Extensions

global constant
    shell32     = registerw32Library("shell32.dll"),   -- shell extentions

    xExtractIcon        = registerw32Function(shell32, "ExtractIconA", {C_UINT, C_POINTER, C_UINT}, C_UINT),
    xExtractIconEx      = registerw32Function(shell32, "ExtractIconExA", {C_POINTER, C_INT, C_POINTER,C_POINTER, C_UINT}, C_UINT),
    xShellExecute       = registerw32Function( shell32, "ShellExecuteA", {C_LONG, C_LONG, C_LONG, C_LONG, C_LONG, C_LONG}, C_LONG ),
    xDragQueryFile = registerw32Function(shell32, "DragQueryFileA", {C_POINTER, C_INT, C_POINTER, C_INT}, C_INT),
    xSHBrowseForFolder = registerw32Function(shell32, "SHBrowseForFolder",{C_POINTER}, C_POINTER),
    xSHGetPathFromIDList = registerw32Function(shell32,"SHGetPathFromIDList",{C_ULONG,C_POINTER},C_ULONG),
    xSHGetFileInfo = registerw32Function(shell32,"SHGetFileInfoA",{C_POINTER, C_LONG, C_POINTER, C_UINT, C_UINT},C_POINTER)

-- w32ole.ew

-- w32ole32.ew

--/topic Constant
--/const ole32
--/desc Windows Library: Graphic Device Interface (drawing, text, etc)
global constant
    ole32       = registerw32Library("ole32.dll"),

    xOleInitialize = registerw32Function(ole32, "OleInitialize", {C_INT}, C_INT),
    xOleUninitialize = registerw32Procedure(ole32, "OleUninitialize", {})

--/topic OLE ActiveX
--/info
--Object Linking and Embedding
--OLE is not well supported in win32lib yet. This will be added to as
-- people request it.

--/topic OLE ActiveX
--/proc OleUninitialize()
--/desc Resets the thread's OLE subsystem
--This is required for some Windows API routines. Each call to OleInitialize()
-- must have a matching call to OleUnitialize().
global procedure OleUninitialize()
    w32Proc(xOleUninitialize,{})
end procedure

--/topic OLE ActiveX
--/proc OleInitialize()
--/desc Initializes the thread's OLE subsystem
--This is required for some Windows API routines. Each call to OleInitialize()
-- must have a matching call to OleUnitialize().
global procedure OleInitialize()
    atom lRC

    lRC = w32Func(xOleInitialize,{0})

end procedure

-- w32winmm.ew

--/topic Constant
--/const winmm32
--/desc Windows Library: Multi-Media

global constant
    winmm       = registerw32Library("winmm.dll"),     -- multi-media

-- sound support
    xPlaySound          = registerw32Function(winmm, "PlaySound", {C_INT, C_INT, C_INT}, C_INT)

-- w32winspool.ew

--/topic Constants
--/const winspool
--/desc Windows library, Printer services

global constant
    winspool = registerw32Library("winspool.drv"),

    xEnumPrinters = registerw32Function(winspool,"EnumPrintersA",repeat(C_INT,7),C_INT),
    xGetDefaultPrinter=registerw32Function(winspool,"GetDefaultPrinterA",{C_POINTER,C_POINTER},C_LONG),
    xOpenPrinter=registerw32Function(winspool,"OpenPrinterA",repeat(C_POINTER,3),C_INT),
    xDocumentProperties=registerw32Function(winspool,"DocumentPropertiesA",repeat(C_POINTER,6),C_LONG),
    xClosePrinter=registerw32Function(winspool,"ClosePrinter",{C_POINTER},C_INT),
    xEnumForms=registerw32Function(winspool,"EnumFormsA",{C_POINTER,C_INT,C_POINTER,C_INT,C_POINTER,C_POINTER},C_INT),
    xAddForm=registerw32Function(winspool,"AddFormA",{C_POINTER,C_INT,C_POINTER},C_INT),

    -- flags for DocumentProperties and other

DM_IN_BUFFER = 8,
DM_MODIFY = DM_IN_BUFFER,
DM_OUT_BUFFER = 2,
DM_COPY = DM_OUT_BUFFER,
DM_IN_PROMPT = 4,
DM_PROPMT = DM_IN_PROMPT,
DM_OUT_DEFAULT = 1,
DM_UPDATE = DM_OUT_DEFAULT

-- w32advapi.ew

--/topic Constants
--/const advapi32
--/desc Windows Library: Advanced API

global constant
    advapi32    = registerw32Library("advapi32.dll"),  -- common dialogs

-- common dialogs
    xCryptAcquireContext    = registerw32Function(advapi32, "CryptAcquireContextA", {C_POINTER,C_POINTER,C_POINTER,C_LONG,C_UINT}, C_LONG),
    xCryptReleaseContext    = registerw32Function(advapi32, "CryptReleaseContext", {C_POINTER, C_UINT}, C_LONG),
    xCryptGenRandom         = registerw32Function(advapi32, "CryptGenRandom",{C_POINTER, C_LONG, C_POINTER}, C_UINT),
    xGetUserName            = registerw32Function(advapi32, "GetUserNameA", {C_POINTER, C_POINTER}, C_INT),

    PROV_RSA_FULL          = 1,
    PROV_RSA_SIG           = 2,
    PROV_DSS               = 3,
    PROV_FORTEZZA          = 4,
    PROV_MS_EXCHANGE       = 5,
    PROV_SSL               = 6,
    PROV_RSA_SCHANNEL      = 12,
    PROV_DSS_DH            = 13,
    PROV_EC_ECDSA_SIG      = 14,
    PROV_EC_ECNRA_SIG      = 15,
    PROV_EC_ECDSA_FULL     = 16,
    PROV_EC_ECNRA_FULL     = 17,
    PROV_DH_SCHANNEL       = 18,
    PROV_SPYRUS_LYNKS      = 20,
    PROV_RNG               = 21,
    PROV_INTEL_SEC         = 22,
    PROV_REPLACE_OWF       = 23,
    PROV_RSA_AES           = 24


--/topic System Attributes
--/func getUserName()
--/Desc Fetches the id of the currently logged in user.
--/ret SEQUENCE: The user ID
--
--Example:
--/code
--      sequence lUser
--      lUser  = getUserName()
--/endcode
global function getUserName()
    sequence lUserId
    atom lBufferAddress, lResultCode

    lBufferAddress = w32acquire_mem(0, 4 + 256 + 1)
    poke4(lBufferAddress, 256)
    lResultCode = w32Func(xGetUserName, {lBufferAddress+4, lBufferAddress})
    if lResultCode then
        lUserId = w32peek_string(lBufferAddress+4)
    else
        lUserId = {}
    end if
    w32release_mem(lBufferAddress)
    return lUserId
end function

-- w32tk.e

--------------------NOTICE-------------------------------*
-- Software ID: w32tk.e
-- This is used to help the transition from the old toolkit
-- routines to the new "w32" prefixed ones.

global object VOID

global function or_all( object pData )
  return w32or_all(pData)
end function

global procedure store( atom struct, sequence s, object o )
  w32store(struct,s,o)
end procedure

global function fetch( atom struct, sequence s )
  return w32fetch(struct,s)
end function

-- w32structures

--------------------NOTICE-------------------------------*
-- Software ID: w32structures.ew
-- Version:     0.70.4a
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*

-- Windows structures definitions

constant MAX_PATH = 260

global constant
    INITCOMMONCONTROLSEX_dwSize = w32allot( Long ),
    INITCOMMONCONTROLSEX_dwICC = w32allot( Long ),
    SIZEOF_INITCOMMONCONTROLSEX = w32allotted_size(),
    ID_INITCOMMONCONTROLSEX     = {{w32CurrentStructure()}},

    -- defining a window
    winExSize         = w32allot( UInt ),
    winExStyle        = w32allot( UInt ),
    winExProc         = w32allot( Long ),
    winExClsExtra     = w32allot( Long ),
    winExExtra        = w32allot( Long ),
    winExInstance     = w32allot( UInt ),
    winExIcon         = w32allot( UInt ),
    winExCursor       = w32allot( Long ),
    winExBackground   = w32allot( Long ),
    winExMenuName     = w32allot( Lpsz ),
    winExClassName    = w32allot( Lpsz ),
    winExIconSm       = w32allot( UInt ),
    SIZEOF_WNDCLASSEX = w32allotted_size(),
    ID_WNDCLASSEX     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type RECT
    rectLeft            = w32allot( Long ),
    rectTop             = w32allot( Long ),
    rectRight           = w32allot( Long ),
    rectBottom          = w32allot( Long ),
    SIZEOF_RECT        = w32allotted_size(),
    ID_RECT     = {{w32CurrentStructure()}},


-----------------------------------------------------------------------------
-- Type ICONINFO
    iconinfo_fIcon      = w32allot(Long),
    iconinfo_xHotspot   = w32allot(DWord),
    iconinfo_yHotspot   = w32allot(DWord),
    iconinfo_hbmMask    = w32allot(Ptr),
    iconinfo_hbmColor   = w32allot(Ptr),
    SIZEOF_ICONINFO     = w32allotted_size(),
    ID_ICONINFO     = {{w32CurrentStructure()}},


-----------------------------------------------------------------------------
-- Type DRAWTEXTPARAMS
    DTP_cbSize            = w32allot( UInt ),
    DTP_iTabLength        = w32allot( Long ),
    DTP_iLeftMargin       = w32allot( Long ),
    DTP_iRightMargin      = w32allot( Long ),
    DTP_uiLengthDrawn     = w32allot( UInt ),
    SIZEOF_DRAWTEXTPARAMS = w32allotted_size(),
    ID_DRAWTEXTPARAMS     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type PAINTSTRUCT
    psHdc               = w32allot( UInt ),
    psErase             = w32allot( Long ),
    psPaintRect         = w32allot( Rect ),
    psRestore           = w32allot( Long ),
    psIncUpdate         = w32allot( Long ),
    psRgbReserved       = w32allot( {32, Byte} ),
    SIZEOF_PAINTSTRUCT  = w32allotted_size(),
    ID_PAINTSTRUCT     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- defining a font
    lfHeight            = w32allot( Long ),
    lfWidth             = w32allot( Long ),
    lfEscapement        = w32allot( Long ),
    lfOrientation       = w32allot( Long ),
    lfWeight            = w32allot( Long ),
    lfItalic            = w32allot( Byte ),
    lfUnderline         = w32allot( Byte ),
    lfStrikeOut         = w32allot( Byte ),
    lfCharSet           = w32allot( Byte ),
    lfOutPrecision      = w32allot( Byte ),
    lfClipPrecision     = w32allot( Byte ),
    lfQuality           = w32allot( Byte ),
    lfPitchAndFamily    = w32allot( Byte ),
    lfFaceName          = w32allot( {32, Strz} ),
    SIZEOF_LOGFONT     = w32allotted_size(),
    ID_LOGFONT     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type TEXTMETRIC
    tmHeight            = w32allot( Long ),
    tmAscent            = w32allot( Long ),
    tmDescent           = w32allot( Long ),
    tmInternalLeading   = w32allot( Long ),
    tmExternalLeading   = w32allot( Long ),
    tmAveCharWidth      = w32allot( Long ),
    tmMaxCharWidth      = w32allot( Long ),
    tmWeight            = w32allot( Long ),
    tmOverhang          = w32allot( Long ),
    tmDigitizedAspectX  = w32allot( Long ),
    tmDigitizedAspectY  = w32allot( Long ),
    tmFirstChar         = w32allot( Byte ),
    tmLastChar          = w32allot( Byte ),
    tmDefaultChar       = w32allot( Byte ),
    tmBreakChar         = w32allot( Byte ),
    tmItalic            = w32allot( Byte ),
    tmUnderlined        = w32allot( Byte ),
    tmStruckOut         = w32allot( Byte ),
    tmPitchAndFamily    = w32allot( Byte ),
    tmCharSet           = w32allot( Byte ),
    SIZEOF_TEXTMETRIC  = w32allotted_size(),
    ID_TEXTMETRIC     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type NEWTEXTMETRIC
    ntmTextMetric       = w32allot(ID_TEXTMETRIC),
    ntmFlags            = w32allot( Long ),
    ntmSizeEM           = w32allot( Long ),
    ntmCellHeight       = w32allot( Long ),
    ntmAveWidth         = w32allot( Long ),
    SIZEOF_NEWTEXTMETRIC  = w32allotted_size(),
    ID_NEWTEXTMETRIC     = {{w32CurrentStructure()}},


-----------------------------------------------------------------------------
-- Type POINT
    ptX                 = w32allot( Long ),
    ptY                 = w32allot( Long ),
    SIZEOF_POINT       = w32allotted_size(),
    ID_POINT     = {{w32CurrentStructure()}},


-----------------------------------------------------------------------------
-- Type MSG
    msgHWnd             = w32allot( UInt ),
    msgMessage          = w32allot( UInt ),
    msgWParam           = w32allot( Long ),
    msgLParam           = w32allot( Long ),
    msgTime             = w32allot( DWord ),
    msgPtX              = w32allot( Long ),
    msgPtY              = w32allot( Long ),
    SIZEOF_MSG          = w32allotted_size(),
    ID_MSG     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type SIZE
    sizX                = w32allot( Long ),
    sizY                = w32allot( Long ),
    SIZEOF_SIZE         = w32allotted_size(),
    ID_SIZE     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type BITMAP
    bmType          = w32allot( Long ),
    bmWidth         = w32allot( Long ),
    bmHeight        = w32allot( Long ),
    bmWidthBytes    = w32allot( Long ),
    bmPlanes        = w32allot( Word ),
    bmBitsPixel     = w32allot( Word ),
    bmBits          = w32allot( Long ),
    SIZEOF_BITMAP   = w32allotted_size(),
    ID_BITMAP     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type BITMAPFILEHEADER
    bfType          = w32allot( {2, Byte} ),
    bfSize          = w32allot( DWord ),
    bfReserved1     = w32allot( Word ),
    bfReserved2     = w32allot( Word ),
    bfOffBits       = w32allot( DWord ),
    SIZEOF_BITMAPFILEHEADER = w32allotted_size(),
    ID_BITMAPFILEHEADER     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type BITMAPINFOHEADER
    biSize          = w32allot( DWord ),
    biWidth         = w32allot( Long ),
    biHeight        = w32allot( Long ),
    biPlanes        = w32allot( Word ),
    biBitCount      = w32allot( Word ),
    biCompression   = w32allot( DWord ),
    biSizeImage     = w32allot( DWord ),
    biXPelsPerMeter = w32allot( Long ),
    biYPelsPerMeter = w32allot( Long ),
    biClrUsed       = w32allot( DWord ),
    biClrImportant  = w32allot( DWord ),
    SIZEOF_BITMAPINFOHEADER = w32allotted_size(),
    ID_BITMAPINFOHEADER     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type BITMAPCOREHEADER
    bcSize                  = w32allot( Long ),
    bcWidth                 = w32allot( Word ),
    bcHeight                = w32allot( Word ),
    bcPlanes                = w32allot( Word ),
    bcBitCount              = w32allot( Word ),
    SIZEOF_BITMAPCOREHEADER = w32allotted_size(),
    ID_BITMAPCOREHEADER     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type RGBTRIPLE
    rgbtBlue        = w32allot( Byte ),
    rgbtGreen       = w32allot( Byte ),
    rgbtRed         = w32allot( Byte ),
    SIZEOF_RGBTRIPLE  = w32allotted_size(),
    ID_RGBTRIPLE     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type RGBQUAD
    rgbBlue         = w32allot( Byte ),
    rgbGreen        = w32allot( Byte ),
    rgbRed          = w32allot( Byte ),
    rgbReserved     = w32allot( Byte ),
    SIZEOF_RGBQUAD  = w32allotted_size(),
    ID_RGBQUAD     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type BITMAPINFO
    bmiHeader       = w32allot( SIZEOF_BITMAPINFOHEADER ),
    bmiColors       = w32allot( {2, SIZEOF_RGBQUAD} ),
    SIZEOF_BITMAPINFO = w32allotted_size(),
    ID_BITMAPINFO     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type PALLETTEENTRY
    peBlue          = w32allot( Byte ),
    peGreen         = w32allot( Byte ),
    peRed           = w32allot( Byte ),
    peFlags         = w32allot( Byte ),
    SIZEOF_PALETTEENTRY  = w32allotted_size(),
    ID_PALETTEENTRY     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type LOGPALETTE
    palVersion      = w32allot( Word ),
    palNumEntries   = w32allot( Word ),
    palPalEntr      = w32allot( {2, SIZEOF_PALETTEENTRY} ),
    SIZEOF_LOGPALETTE = w32allotted_size(),
    ID_LOGPALETTE     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Type COLORDLG
  COLORDLG_lStructSize     = w32allot(DWord),
  COLORDLG_hwndOwner       = w32allot(Long),
  COLORDLG_hInstance       = w32allot(Long),
  COLORDLG_rgbResult       = w32allot(Long),
  COLORDLG_lpCustColors    = w32allot(Long),
  COLORDLG_Flags           = w32allot(DWord),
  COLORDLG_lCustData       = w32allot(Long),
  COLORDLG_lpfnHook        = w32allot(Long),
  COLORDLG_lpTemplateName  = w32allot(Lpsz),
  SIZEOF_COLORDLG          = w32allotted_size(),
  ID_COLORDLG     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type SCROLLINFO
    sifSize                 = w32allot( Long ),
    sifMask                 = w32allot( Long ),
    sifMin                  = w32allot( Long ),
    sifMax                  = w32allot( Long ),
    sifPage                 = w32allot( Long ),
    sifPos                  = w32allot( Long ),
    sifTrackPos             = w32allot( Long ),
    SIZEOF_SCROLLINFO       = w32allotted_size(),
    ID_SCROLLINFO     = {{w32CurrentStructure()}},



-----------------------------------------------------------------------------
    --?? pRINTDLG_hDevNames              = w32allot( UInt ),
    --?? pRINTDLG_hPrintTemplate         = w32allot( UInt ),
    --?? pRINTDLG_hSetupTemplate         = w32allot( UInt ),

-- Type PRINTDLG
    PRINTDLG_lStructSize            = w32allot( DWord ),
    PRINTDLG_hwndOwner              = w32allot( UInt ),
    PRINTDLG_hDevMode               = w32allot( Hndl ),
    PRINTDLG_pDevMode               = w32allotted_handle(PRINTDLG_hDevMode),
    PRINTDLG_hDevNames              = w32allot( Hndl ),
    PRINTDLG_pDevNames              = w32allotted_handle(PRINTDLG_hDevNames),
    PRINTDLG_hdc                    = w32allot( UInt ),
    PRINTDLG_flags                  = w32allot( DWord ),
    PRINTDLG_nFromPage              = w32allot( Word ),
    PRINTDLG_nToPage                = w32allot( Word ),
    PRINTDLG_nMinPage               = w32allot( Word ),
    PRINTDLG_nMaxPage               = w32allot( Word ),
    PRINTDLG_nCopies                = w32allot( Word ),
    PRINTDLG_hInstance              = w32allot( UInt ),
    PRINTDLG_lCustData              = w32allot( Long ),
    PRINTDLG_lpfnPrintHook          = w32allot( UInt ),
    PRINTDLG_lpfnSetupHook          = w32allot( UInt ),
    PRINTDLG_lpPrintTemplateName    = w32allot( UInt ),
    PRINTDLG_lpSetupTemplateName    = w32allot( UInt ),
    PRINTDLG_hPrintTemplate         = w32allot( Hndl ),
    PRINTDLG_pPrintTemplate         = w32allotted_handle(PRINTDLG_hPrintTemplate),
    PRINTDLG_hSetupTemplate         = w32allot( Hndl ),
    PRINTDLG_pSetupTemplate         = w32allotted_handle(PRINTDLG_hSetupTemplate),
    SIZEOF_PRINTDLG                 = w32allotted_size(),
    ID_PRINTDLG     = {{w32CurrentStructure()}},

-- DEVMODE structure
    DEVMODE_dmDeviceName            = w32allot( {32,Byte} ),   -- bchar[32]
    DEVMODE_dmSpecVersion           = w32allot( Word ),        -- word
    DEVMODE_dmDriverVersion         = w32allot( Word ),        -- word
    DEVMODE_dmSize                  = w32allot( Word ),        -- word
    DEVMODE_dmDriverExtra           = w32allot( Word ),        -- word
    DEVMODE_dmFields                = w32allot( Long ),        -- dword
    DEVMODE_dmOrientation           = w32allot( Word ),        -- short
    DEVMODE_dmPaperSize             = w32allot( Word ),        -- short
    DEVMODE_dmPaperLength           = w32allot( Word ),        -- short
    DEVMODE_dmPaperWidth            = w32allot( Word ),        -- short
    DEVMODE_dmScale                 = w32allot( Word ),        -- short
    DEVMODE_dmCopies                = w32allot( Word ),        -- short
    DEVMODE_dmDefaultSource         = w32allot( Word ),        -- short
    DEVMODE_dmPrintQuality          = w32allot( Word ),        -- short
    DEVMODE_dmColor                 = w32allot( Word ),        -- short
    DEVMODE_dmDuplex                = w32allot( Word ),        -- short
    DEVMODE_dmYResolution           = w32allot( Word ),        -- short
    DEVMODE_dmTTOption              = w32allot( Word ),        -- short
    DEVMODE_dmCollate               = w32allot( Word ),        -- short
    DEVMODE_dmFormName              = w32allot( {32,Byte} ),   -- byte[32]
    DEVMODE_dmLogPixels             = w32allot( Word ),        -- word
    DEVMODE_dmBitsPerPel            = w32allot( Long ),        -- dword
    DEVMODE_dmPelsWidth             = w32allot( Long ),        -- dword
    DEVMODE_dmPelsHeight            = w32allot( Long ),        -- dword
    DEVMODE_dmDisplayFlags          = w32allot( Long ),        -- dword
    DEVMODE_dmDisplayFrequency      = w32allot( Long ),        -- dword
    SIZEOF_DEVMODE                  = w32allotted_size(),
    ID_DEVMODE     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type DOCINFO
    DOCINFO_cbSize                  = w32allot( Long ),
    DOCINFO_lpszDocName             = w32allot( Lpsz ),
    DOCINFO_lpszOutput              = w32allot( Lpsz ),
    DOCINFO_lpszDatatype            = w32allot( Lpsz ),
    DOCINFO_fwType                  = w32allot( DWord ),
    SIZEOF_DOCINFO                  = w32allotted_size(),
    ID_DOCINFO     = {{w32CurrentStructure()}},

    TBADDBITMAP_hInst           = w32allot( Long ),
    TBADDBITMAP_nID             = w32allot( UInt ),
    SIZEOF_TBADDBITMAP          = w32allotted_size(),
    ID_TBADDBITMAP     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- Type TC_ITEM
    TC_ITEM_mask                    = w32allot( UInt ),
    TC_ITEM_lpReserved1             = w32allot( UInt ),
    TC_ITEM_lpReserved2             = w32allot( UInt ),
    TC_ITEM_pszText                 = w32allot( asBuffer ),
    TC_ITEM_iImage                  = w32allot( UInt ),
    TC_ITEM_lParam                  = w32allot( Long ),
    SIZEOF_TC_ITEM                  = w32allotted_size(),
    ID_TC_ITEM     = {{w32CurrentStructure()}},

    TCHITTESTINFO_ptX       = w32allot( Long ),
    TCHITTESTINFO_ptY       = w32allot( Long ),
    TCHITTESTINFO_flags     = w32allot( UInt ),
    SIZEOF_TCHITTESTINFO    = w32allotted_size(),
    ID_TCHITTESTINFO     = {{w32CurrentStructure()}},


-----------------------------------------------------------------------------
-- type CHOOSEFONT
    CF_lStructSize      = w32allot( DWord ),
    CF_hwndOwner        = w32allot( Ptr ),
    CF_hDC              = w32allot( Ptr ),
    CF_hLogFont         = w32allot( Ptr ),
    CF_iPointSize       = w32allot( Long ),
    CF_Flags            = w32allot( DWord ),
    CF_rgbColors        = w32allot( DWord ),
    CF_lCustData        = w32allot( Long ),
    CF_lpfnHook         = w32allot( Ptr ),
    CF_lpTemplateName   = w32allot( Ptr ),
    CF_hInstance        = w32allot( Ptr ),
    CF_lpszStyle        = w32allot( Lpsz ),
    CF_nFontType        = w32allot( Word ),
    CF_FillerAlign      = w32allot( Word ),
    CF_nSizeMin         = w32allot( Long ),
    CF_nSizeMax         = w32allot( Long ),
    SIZEOF_CHOOSEFONT   = w32allotted_size(),
    ID_CHOOSEFONT     = {{w32CurrentStructure()}},

-----------------------------------------------------------------------------
-- type NMHDR
    NMHDR_hwndFrom                  = w32allot( UInt ),
    NMHDR_idFrom                    = w32allot( Long ),
    NMHDR_code                      = w32allot( Long ),
    SIZEOF_NMHDR                    = w32allotted_size(),
    ID_NMHDR     = {{w32CurrentStructure()}},
    LVCOLUMN_mask           = w32allot( Long ),
    LVCOLUMN_fmt            = w32allot( Long ),
    LVCOLUMN_cx             = w32allot( Long ),
    LVCOLUMN_pszText        = w32allot( asBuffer ),
    LVCOLUMN_iSubItem       = w32allot( Long ),
    LVCOLUMN_iImage         = w32allot( Long ),
    LVCOLUMN_iOrder         = w32allot( Long ),
    SIZEOF_LVCOLUMN         = w32allotted_size(),
    ID_LVCOLUMN     = {{w32CurrentStructure()}},

    LVITEM_mask             = w32allot( Long ),
    LVITEM_iItem            = w32allot( Long ),
    LVITEM_iSubItem         = w32allot( Long ),
    LVITEM_state            = w32allot( UInt ),
    LVITEM_stateMask        = w32allot( UInt ),
    LVITEM_pszText          = w32allot( asBuffer ),
    LVITEM_iImage           = w32allot( Long ),
    LVITEM_lParam           = w32allot( Long ),
    LVITEM_iIndent          = w32allot( Long ),
    LVITEM_iGroupId         = w32allot( Long ),
    LVITEM_cColumns         = w32allot( Long ),
    LVITEM_puColumns        = w32allot( Long ),
    SIZEOF_LVITEM           = w32allotted_size(),
    ID_LVITEM     = {{w32CurrentStructure()}},

    LVDISPINFO_hdr                  = w32allot( ID_NMHDR ),
    LVDISPINFO_item                 = w32allot( ID_LVITEM ),
    SIZEOF_LVDISPINFO               = w32allotted_size(),
    ID_LVDISPINFO     = {{w32CurrentStructure()}},

    -- List View HITTESTINFO
    LVHITTESTINFO_ptX           = w32allot(Long),
    LVHITTESTINFO_ptY           = w32allot(Long),
    LVHITTESTINFO_flags         = w32allot(UInt),
    LVHITTESTINFO_iItem         = w32allot(Long),
    LVHITTESTINFO_iSubItem      = w32allot(Long),
    SIZEOF_LVHITTESTINFO        = w32allotted_size(),
    ID_LVHITTESTINFO     = {{w32CurrentStructure()}},


    NMLISTVIEW_hdr              = w32allot( ID_NMHDR ),
    NMLISTVIEW_iItem            = w32allot( Long ),
    NMLISTVIEW_iSubItem         = w32allot( Long ),
    NMLISTVIEW_uNewState        = w32allot( UInt ),
    NMLISTVIEW_uOldState        = w32allot( UInt ),
    NMLISTVIEW_uChanged         = w32allot( UInt ),
    NMLISTVIEW_ptActionX        = w32allot( Long ),
    NMLISTVIEW_ptActionY        = w32allot( Long ),
    NMLISTVIEW_lParam           = w32allot( Long ),
    SIZEOF_NMLISTVIEW           = w32allotted_size(),
    ID_NMLISTVIEW     = {{w32CurrentStructure()}},

    TVITEMEX_mask           = w32allot( Long ),
    TVITEM_mask             = TVITEMEX_mask,
    TVITEMEX_hItem          = w32allot( Long ),
    TVITEM_hItem            = TVITEMEX_hItem,
    TVITEMEX_state          = w32allot( Long ),
    TVITEM_state            = TVITEMEX_state,
    TVITEMEX_stateMask      = w32allot( Long ),
    TVITEM_stateMask        = TVITEMEX_stateMask,
    TVITEMEX_pszText        = w32allot( asBuffer ),
    TVITEM_pszText          = TVITEMEX_pszText,
    TVITEMEX_iImage         = w32allot( Long ),
    TVITEM_iImage           = TVITEMEX_iImage,
    TVITEMEX_iSelectedImage = w32allot( Long ),
    TVITEM_iSelectedImage   = TVITEMEX_iSelectedImage,
    TVITEMEX_cChildren      = w32allot( Long ),
    TVITEM_cChildren        = TVITEMEX_cChildren,
    TVITEMEX_lParam         = w32allot( Long ),
    TVITEM_lParam           = TVITEMEX_lParam,
    SIZEOF_TVITEM           = w32allotted_sofar(),
    ID_TVITEM               = w32define_this_struct(),

    TVITEMEX_iIntegral      = w32allot( Long ),
    SIZEOF_TVITEMEX         = w32allotted_size(),
    ID_TVITEMEX             = {{w32CurrentStructure()}},

    TVINSERTSTRUCT_hParent              = w32allot( Long ),
    TVINSERTSTRUCT_hInsertAfter         = w32allot( Long ),
    TVINSERTSTRUCT_item                 = w32allot( ID_TVITEM ),
    SIZEOF_TVINSERTSTRUCT               = w32allotted_size(),
    ID_TVINSERTSTRUCT     = {{w32CurrentStructure()}},

    TVDISPINFO_hdr              = w32allot( ID_NMHDR ),
    TVDISPINFO_item             = w32allot( ID_TVITEM ),
    SIZEOF_TVDISPINFO             = w32allotted_size(),
    ID_TVDISPINFO     = {{w32CurrentStructure()}},

    TVHITTESTINFO_ptX       = w32allot( Long ),
    TVHITTESTINFO_ptY       = w32allot( Long ),
    TVHITTESTINFO_flags     = w32allot( UInt ),
    TVHITTESTINFO_hItem     = w32allot( Long ),
    SIZEOF_TVHITTESTINFO    = w32allotted_size(),
    ID_TVHITTESTINFO     = {{w32CurrentStructure()}},

    NMCBEENDEDIT_hdr                  = w32allot( ID_NMHDR ),
    NMCBEENDEDIT_fChanged             = w32allot( UInt ),
    NMCBEENDEDIT_iNewSelection        = w32allot( UInt ),
    NMCBEENDEDIT_szText               = w32allot( aszText ),
    NMCBEENDEDIT_iWhy                 = w32allot( UInt ),
    SIZEOF_NMCBEENDEDIT               = w32allotted_size(),
    ID_NMCBEENDEDIT     = {{w32CurrentStructure()}},

    NMTREEVIEW_hdr                  = w32allot( ID_NMHDR ),
    NMTREEVIEW_action               = w32allot( UInt ),
    NMTREEVIEW_itemOld              = w32allot( ID_TVITEM ),
    NMTREEVIEW_itemNew              = w32allot( ID_TVITEM ),
    NMTREEVIEW_ptX                  = w32allot( Long ),
    NMTREEVIEW_ptY                  = w32allot( Long ),
    SIZEOF_NMTREEVIEW           = w32allotted_size(),
    ID_NMTREEVIEW     = {{w32CurrentStructure()}},

    SYSTEMTIME_wYear                = w32allot( Word ),
    SYSTEMTIME_wMonth               = w32allot( Word ),
    SYSTEMTIME_wDayOfWeek           = w32allot( Word ),
    SYSTEMTIME_wDay                 = w32allot( Word ),
    SYSTEMTIME_wHour                = w32allot( Word ),
    SYSTEMTIME_wMinute              = w32allot( Word ),
    SYSTEMTIME_wSecond              = w32allot( Word ),
    SYSTEMTIME_wMilliseconds        = w32allot( Word ),
    SIZEOF_SYSTEMTIME               = w32allotted_size(),
    ID_SYSTEMTIME     = {{w32CurrentStructure()}},

    NMDAYSTATE_nmhdr                = w32allot( ID_NMHDR ),
    NMDAYSTATE_stStart              = w32allot( ID_SYSTEMTIME ),
    NMDAYSTATE_cDayState            = w32allot( Long ),
    NMDAYSTATE_prgDayState          = w32allot( Long ),
    SIZEOF_NMDAYSTATE               = w32allotted_size(),
    ID_NMDAYSTATE     = {{w32CurrentStructure()}},

    CHARFORMAT_cbSize               = w32allot( UInt ),
    CHARFORMAT_dwMask               = w32allot( DWord ),
    CHARFORMAT_dwEffects            = w32allot( DWord ),
    CHARFORMAT_yHeight              = w32allot( Long ),
    CHARFORMAT_yOffset              = w32allot( Long ),
    CHARFORMAT_crTextColor          = w32allot( Long ),
    CHARFORMAT_bCharSet             = w32allot( Byte ),
    CHARFORMAT_bPitchAndFamily      = w32allot( Byte ),
    CHARFORMAT_szFaceName           = w32allot( {32, Strz} ),
    CHARFORMAT_Reserved             = w32allot(2),
    SIZEOF_CHARFORMAT               = w32allotted_size(),
    ID_CHARFORMAT     = {{w32CurrentStructure()}},

    PARAFORMAT_cbSize               = w32allot( UInt ),
    PARAFORMAT_dwMask               = w32allot( Long ),
    PARAFORMAT_wNumbering           = w32allot( Word ),
    PARAFORMAT_wReserved            = w32allot( Word ),
    PARAFORMAT_dxStartIndent        = w32allot( Long ),
    PARAFORMAT_dxRightIndent        = w32allot( Long ),
    PARAFORMAT_dxOffset             = w32allot( Long ),
    PARAFORMAT_wAlignment           = w32allot( Word ),
    PARAFORMAT_cTabCount            = w32allot( Word ),
    PARAFORMAT_rgxTabs              = w32allot( {32, Long} ), -- Array of Long's
    SIZEOF_PARAFORMAT               = w32allotted_size(),
    ID_PARAFORMAT     = {{w32CurrentStructure()}},

    CHARRANGE_cpMin             = w32allot( Long ),
    CHARRANGE_cpMax             = w32allot( Long ),
    SIZEOF_CHARRANGE            = w32allotted_size(),
    ID_CHARRANGE     = {{w32CurrentStructure()}},

    FINDTEXTEX_chrgcpMin        = w32allot( Long ),
    FINDTEXTEX_chrgcpMax        = w32allot( Long ),
    FINDTEXTEX_lpstrText        = w32allot(w32iff(equal(WC_RICHEDIT,WC_RICHEDIT50), Upsz, Lpsz)) ,
    FINDTEXTEX_chrgTextcpMin    = w32allot( Long ),
    FINDTEXTEX_chrgTextcpMax    = w32allot( Long ),
    SIZEOF_FINDTEXTEX           = w32allotted_size(),
    ID_FINDTEXTEX     = {{w32CurrentStructure()}},

    TEXTRANGE_chrgcpMin         = w32allot( Long ),
    TEXTRANGE_chrgcpMax         = w32allot( Long ),
    TEXTRANGE_lpstrText         = w32allot( w32iff(equal(WC_RICHEDIT,WC_RICHEDIT50),Upsz,Lpsz) ),
    SIZEOF_TEXTRANGE            = w32allotted_size(),
    ID_TEXTRANGE     = {{w32CurrentStructure()}},

    EDITSTREAM_dwCookie         = w32allot( Long ),
    EDITSTREAM_dwError          = w32allot( Long ),
    EDITSTREAM_pfnCallback      = w32allot( Long ),
    SIZEOF_EDITSTREAM           = w32allotted_size(),
    ID_EDITSTREAM     = {{w32CurrentStructure()}},

    FINDREPLACE_lStructSize         = w32allot( Long ),
    FINDREPLACE_hwndOwner           = w32allot( Long ),
    FINDREPLACE_hInstance           = w32allot( Long ),
    FINDREPLACE_Flags               = w32allot( Long ),
    FINDREPLACE_lpstrFindWhat       = w32allot( Lpsz ),
    FINDREPLACE_lpstrReplaceWith    = w32allot( Lpsz ),
    FINDREPLACE_wFindWhatLen        = w32allot( Word ),
    FINDREPLACE_wReplaceWithLen     = w32allot( Word ),
    FINDREPLACE_lCustData           = w32allot( Long ),
    FINDREPLACE_lpfnHook            = w32allot( Long ),
    FINDREPLACE_lpTemplateName      = w32allot( Long ),
    SIZEOF_FINDREPLACE              = w32allotted_size(),
    ID_FINDREPLACE     = {{w32CurrentStructure()}},

    REBARBANDINFO_cbSize            = w32allot( UInt ),
    REBARBANDINFO_fMask             = w32allot( UInt ),
    REBARBANDINFO_fStyle            = w32allot( UInt ),
    REBARBANDINFO_clrFore           = w32allot( Long ),
    REBARBANDINFO_clrBack           = w32allot( Long ),
    REBARBANDINFO_lpText            = w32allot( asBuffer ),
    REBARBANDINFO_iImage            = w32allot( Long ),
    REBARBANDINFO_hwndChild         = w32allot( Long ),
    REBARBANDINFO_cxMinChild        = w32allot( Long ),
    REBARBANDINFO_cyMinChild        = w32allot( Long ),
    REBARBANDINFO_cx                = w32allot( Long ),
    REBARBANDINFO_hbmBack           = w32allot( Long ),
    REBARBANDINFO_wID               = w32allot( UInt ),
    REBARBANDINFO_cyChild           = w32allot( UInt ),
    REBARBANDINFO_cyMaxChild        = w32allot( UInt ),
    REBARBANDINFO_cyIntegral        = w32allot( UInt ),
    REBARBANDINFO_cxIdeal           = w32allot( UInt ),
    REBARBANDINFO_lParam            = w32allot( Long ),
    REBARBANDINFO_cxHeader          = w32allot( UInt ),
    SIZEOF_REBARBANDINFO            = w32allotted_size(),
    ID_REBARBANDINFO     = {{w32CurrentStructure()}},

    REBARINFO_cbSize                = w32allot( UInt ),
    REBARINFO_fMask                 = w32allot( UInt ),
    REBARINFO_himl                  = w32allot( Long ),
    SIZEOF_REBARINFO                = w32allotted_size(),
    ID_REBARINFO     = {{w32CurrentStructure()}},

    TOOLINFO_cbSize     = w32allot( UInt ),
    TOOLINFO_uFlags     = w32allot( UInt ),
    TOOLINFO_hwnd       = w32allot( Long ),
    TOOLINFO_uId        = w32allot( UInt ),
    TOOLINFO_rect       = w32allot( Rect ),
    TOOLINFO_hinst      = w32allot( Long ),
    TOOLINFO_lpszText   = w32allot( Lpsz ),
    TOOLINFO_lParam     = w32allot( Long ),
    SIZEOF_TOOLINFO     = w32allotted_size(),
    ID_TOOLINFO     = {{w32CurrentStructure()}},

    NMTTDISPINFO_hdr                 = w32allot( ID_NMHDR ),
    NMTTDISPINFO_lpszText            = w32allot( Lpsz ),
    NMTTDISPINFO_szText              = w32allot( {80, Strz} ),
    NMTTDISPINFO_hinst               = w32allot( Long ),
    NMTTDISPINFO_uFlags              = w32allot( UInt ),
    SIZEOF_NMTTDISPINFO              = w32allotted_size(),
    ID_NMTTDISPINFO     = {{w32CurrentStructure()}},

    TTHITTESTINFO_hwnd              = w32allot( Long ),
    TTHITTESTINFO_pt                = w32allot( Point ),
    TTHITTESTINFO_ti                = w32allot( ID_TOOLINFO ),
    SIZEOF_TTHITTESTINFO            = w32allotted_size(),
    ID_TTHITTESTINFO     = {{w32CurrentStructure()}},

    PAGESETUPDLG_lStructSize        = w32allot( Long ),
    PAGESETUPDLG_hwndOwner          = w32allot( Long ),
    PAGESETUPDLG_hDevMode           = w32allot( Hndl ),
    PAGESETUPDLG_pDevMode           = w32allotted_handle(PAGESETUPDLG_hDevMode),
    PAGESETUPDLG_hDevNames          = w32allot( Hndl ),
    PAGESETUPDLG_pDevNames          = w32allotted_handle(PAGESETUPDLG_hDevNames),
    PAGESETUPDLG_Flags              = w32allot( Long ),
    PAGESETUPDLG_ptPaperSize        = w32allot( Point ),
    PAGESETUPDLG_rtMinMargin        = w32allot( Rect ),
    PAGESETUPDLG_rtMargin           = w32allot( Rect ),
    PAGESETUPDLG_hInstance          = w32allot( Long ),
    PAGESETUPDLG_lCustData          = w32allot( Long ),
    PAGESETUPDLG_lpfnPageSetupHook  = w32allot( Long ),
    PAGESETUPDLG_lpfnPagePaintHood  = w32allot( Long ),
    PAGESETUPDLG_lpPageSetupTemplateName    = w32allot( Long ),
    PAGESETUPDLG_hPageSetupTemplate = w32allot( Hndl ),
    PAGESETUPDLG_pPageSetupTemplate = w32allotted_handle(PAGESETUPDLG_hPageSetupTemplate),
    SIZEOF_PAGESETUPDLG             = w32allotted_size(),
    ID_PAGESETUPDLG     = {{w32CurrentStructure()}},

    DEVNAMES_wDriverOffset          = w32allot( Word ),
    DEVNAMES_wDeviceOffset          = w32allot( Word ),
    DEVNAMES_wOutputOffset          = w32allot( Word ),
    SIZEOF_DEVNAMES                 = w32allotted_size(),
    ID_DEVNAMES     = {{w32CurrentStructure()}},

    TBSAVEPARAMS_hkr            = w32allot( Long ),
    TBSAVEPARAMS_pszSubKey      = w32allot( Lpsz ),
    TBSAVEPARAMS_pszValueName   = w32allot( Lpsz ),
    SIZEOF_TBSAVEPARAMS         = w32allotted_size(),
    ID_TBSAVEPARAMS     = {{w32CurrentStructure()}},

    TBINSERTMARK_iButton        = w32allot( Long ),
    TBINSERTMARK_dwFlags        = w32allot( Long ),
    SIZEOF_TBINSERTMARK         = w32allotted_size(),
    ID_TBINSERTMARK     = {{w32CurrentStructure()}},

    TBBUTTON_iBitmap            = w32allot( Long ),
    TBBUTTON_idCommand          = w32allot( Long ),
    TBBUTTON_fsState            = w32allot( Byte ),
    TBBUTTON_fsStyle            = w32allot( Byte ),
    TBBUTTON_bReserved          = w32allot( {2, Byte} ),
    TBBUTTON_dwData             = w32allot( Long ),
    TBBUTTON_iString            = w32allot( Long ),
    SIZEOF_TBBUTTON             = w32allotted_size(),
    ID_TBBUTTON     = {{w32CurrentStructure()}},

    TBBUTTONINFO_cbSize         = w32allot( UInt ),
    TBBUTTONINFO_dwMask         = w32allot( Long ),
    TBBUTTONINFO_idCommand      = w32allot( Long ),
    TBBUTTONINFO_iImage         = w32allot( Long ),
    TBBUTTONINFO_fsState        = w32allot( Byte ),
    TBBUTTONINFO_fsStyle        = w32allot( Byte ),
    TBBUTTONINFO_cx             = w32allot( Word ),
    TBBUTTONINFO_lParam         = w32allot( Long ),
    TBBUTTONINFO_pszText        = w32allot( asBuffer ),
    SIZEOF_TBBUTTONINFO         = w32allotted_size(),
    ID_TBBUTTONINFO     = {{w32CurrentStructure()}},

    NMTOOLBAR_hdr           = w32allot( ID_NMHDR ),
    NMTOOLBAR_iItem         = w32allot( Long ),
    NMTOOLBAR_tbButton      = w32allot( ID_TBBUTTON ),
    NMTOOLBAR_cchText       = w32allot( Long ),
    NMTOOLBAR_pszText       = w32allot( Lpsz ),
    SIZEOF_NMTOOLBAR        = w32allotted_size(),
    ID_NMTOOLBAR     = {{w32CurrentStructure()}},

    COMBOBOXEXITEM_mask             = w32allot( UInt ),
    COMBOBOXEXITEM_iItem            = w32allot( Long ),
    COMBOBOXEXITEM_pszText          = w32allot( asBuffer ),
    COMBOBOXEXITEM_iImage           = w32allot( Long ),
    COMBOBOXEXITEM_iSelectedImage   = w32allot( Long ),
    COMBOBOXEXITEM_iOverlay         = w32allot( Long ),
    COMBOBOXEXITEM_iIndent          = w32allot( Long ),
    COMBOBOXEXITEM_lParam           = w32allot( Long ),
    SIZEOF_COMBOBOXEXITEM           = w32allotted_size(),

    ID_COMBOBOXEXITEM     = {{w32CurrentStructure()}},
    GETTEXTLENGTHEX_flags        = w32allot( DWord ),
    GETTEXTLENGTHEX_codepage     = w32allot( UInt ),
    SIZEOF_GETTEXTLENGTHEX       = w32allotted_size(),
    ID_GETTEXTLENGTHEX     = {{w32CurrentStructure()}},

    GETTEXTEX_cb           = w32allot( DWord ),
    GETTEXTEX_flags        = w32allot( DWord ),
    GETTEXTEX_codepage     = w32allot( UInt ),
    GETTEXTEX_lpDefaultChar = w32allot( Ptr ),
    GETTEXTEX_lpUsedDefChar = w32allot( Ptr ),
    SIZEOF_GETTEXTEX       = w32allotted_size(),
    ID_GETTEXTEX     = {{w32CurrentStructure()}},

-------------------------------------------------
    WINDOWINFO_cbSize           = w32allot( DWord ),
    WINDOWINFO_WRect            = w32allot( Rect ),
    WINDOWINFO_CRect            = w32allot( Rect ),
    WINDOWINFO_Style            = w32allot( UInt ),
    WINDOWINFO_ExStyle          = w32allot( UInt ),
    WINDOWINFO_WindowStatus     = w32allot( UInt ),
    WINDOWINFO_xWindowBorders   = w32allot( UInt ),
    WINDOWINFO_yWindowBorders   = w32allot( UInt ),
    WINDOWINFO_WindowType       = w32allot( Word ),
    WINDOWINFO_CreatorVersion   = w32allot( Word),
    SIZEOF_WINDOWINFO           = w32allotted_size(),
    ID_WINDOWINFO     = {{w32CurrentStructure()}},

    LVBKIMAGE_ulFlags           = w32allot(Long),
    LVBKIMAGE_hbm               = w32allot(Long),
    LVBKIMAGE_pszImage          = w32allot(asBuffer),
    LVBKIMAGE_xOffsetPercent    = w32allot(Long),
    LVBKIMAGE_yOffsetPercent    = w32allot(Long),
    SIZEOF_LVBKIMAGE            = w32allotted_size(),
    ID_LVBKIMAGE     = {{w32CurrentStructure()}},

    -- MenuItem Info
    MENUITEMINFO_cbSize     = w32allot(UInt),
    MENUITEMINFO_fMask      = w32allot(UInt),
    MENUITEMINFO_fType      = w32allot(UInt),
    MENUITEMINFO_fState     = w32allot(UInt),
    MENUITEMINFO_wID        = w32allot(UInt),
    MENUITEMINFO_hSubMenu   = w32allot(UInt),
    MENUITEMINFO_hbmpChecked = w32allot(UInt),
    MENUITEMINFO_hbmpUnchecked = w32allot(UInt),
    MENUITEMINFO_dwItemData = w32allot(UInt),
    MENUITEMINFO_dwTypeData = w32allot(usBuffer),
    MENUITEMINFO_hbmpItem   = w32allot(UInt),
    SIZEOF_MENUITEMINFO     = w32allotted_size(),
    ID_MENUITEMINFO     = {{w32CurrentStructure()}},
-- Type OPENFILENAME
    ofnStructSize           = w32allot( Long ),
    ofnOwner                = w32allot( Long ),
    ofnInstance             = w32allot( Long ),
    ofnFilter               = w32allot( Lpsz ),
    ofnCustomFilter         = w32allot( Lpsz ),
    ofnMaxCustFilter        = w32allot( DWord ),
    ofnFilterIndex          = w32allot( DWord ),
    ofnFile                 = w32allot( asBuffer ),
    ofnFileTitle            = w32allot( Lpsz ),
    ofnMaxFileTitle         = w32allot( DWord ),
    ofnInitialDir           = w32allot( Lpsz ),
    ofnTitle                = w32allot( Lpsz ),
    ofnFlags                = w32allot( DWord ),
    ofnFileOffset           = w32allot( Word ),
    ofnFileExtension        = w32allot( Word ),
    ofnDefExt               = w32allot( Lpsz ),
    ofnCustData             = w32allot( DWord ),
    ofnHook                 = w32allot( Long ),
    ofnTemplateName         = w32allot( Long ),
    SIZEOF_OPENFILENAME    = w32allotted_size(),
    ID_OPENFILENAME     = {{w32CurrentStructure()}},

-- Type BROWSEINFO
    bfOwner         = w32allot( Long ),
    bfpidlRoot      = w32allot( Long ),
    bfDisplayName   = w32allot( Lpsz ),
    bfTitle         = w32allot( Lpsz ),
    bfFlags         = w32allot( Long ),
    bfFunction      = w32allot( Long ),
    bfParam         = w32allot( Long ),
    bfImage         = w32allot( Long ),
    SIZEOF_BROWSEINFO = w32allotted_size(),
    ID_BROWSEINFO     = {{w32CurrentStructure()}},

  dwOSVersionInfoSize      = w32allot(DWord),
  dwMajorVersion           = w32allot(DWord),
  dwMinorVersion           = w32allot(DWord),
  dwBuildNumber            = w32allot(DWord),
  dwPlatformId             = w32allot(DWord),
  szCSDVersion             = w32allot({128, Byte}),
  SIZEOF_OSVERSIONINFO     = w32allotted_sofar(),
  wServicePackMajor        = w32allot(Word),
  wServicePackMinor        = w32allot(Word),
  wSuiteMask               = w32allot(Word),
  wProductType             = w32allot(Byte),
  wReserved                = w32allot(Byte),
  SIZEOF_OSVERSIONINFOEX   = w32allotted_size(),
  ID_OSVERSIONINFOEX     = {{w32CurrentStructure()}},

-- struct SHFILEINFO --
    SHFILEINFO_hIcon        = w32allot( Ptr ),
    SHFILEINFO_iIcon        = w32allot( Long ),
    SHFILEINFO_dwAttributes = w32allot( Long ),
    SHFILEINFO_szDisplayName = w32allot({MAX_PATH, Byte}),
    SHFILEINFO_szTypeName   = w32allot({80, Byte}),
    SIZEOF_SHFILEINFO       = w32allotted_size(),
    ID_SHFILEINFO     = {{w32CurrentStructure()}},

    FORMATRANGE_hdc         = w32allot(ULong),
    FORMATRANGE_hdcTarget   = w32allot(ULong),
    FORMATRANGE_rcRect      = w32allot( Rect ),
    FORMATRANGE_rcPageRect  = w32allot( Rect ),
    FORMATRANGE_chrgStart   = w32allot( Long ),
    FORMATRANGE_chrgEnd     = w32allot( Long ),
    SIZEOF_FORMATRANGE      = w32allotted_size(),
    ID_FORMATRANGE          = {{w32CurrentStructure()}},

-- PRINTER_INFO_5
    PINFO5_piPrinterName = w32allot( Long ),
    PINFO5_piPortName = w32allot( Long ),
    PINFO5_piAttributes = w32allot( Long ),
    PINFO5_piDeviceNotSelectedTimeout = w32allot( Long ),
    PINFO5_piTransmissionRetryTimeout = w32allot( Long ),
    SIZEOF_PINFO5       = w32allotted_size(),
    ID_PINFO5     = {{w32CurrentStructure()}},

-- OUTLINETEXTMETRIC
  otmSize = w32allot(UInt),                  --0
  otmTextMetrics = w32allot(ID_TEXTMETRIC),  --4
  otmFiller = w32allot({3,Byte}),            --57
  otmPanoseNumber = w32allot({12,Byte}),     --60
  otmfsSelection = w32allot(UInt),           --72
  otmfsType = w32allot(Long),
  otmsCharSlopeRise = w32allot(Long),
  otmsCharSlopeRun = w32allot(Long),
  otmItalicAngle = w32allot(Long),
  otmEMSquare = w32allot(UInt),
  otmAscent = w32allot(Long),
  otmDescent = w32allot(Long),
  otmLineGap = w32allot(Long),
  otmsCapEmHeight = w32allot(Long),
  otmsXHeight = w32allot(Long),
  otmrcFontBox = w32allot(Rect),
  otmMacAscent = w32allot(Long),
  otmMacDescent = w32allot(Long),
  otmMacLineGap = w32allot(UInt),
  otmusMinimumPPEM = w32allot(UInt),
  otmptSubscriptSize = w32allot(Point),
  otmptSubscriptOffset = w32allot(Point),
  otmptSuperscriptSize = w32allot(Point),
  otmptSuperscriptOffset = w32allot(Point),
  otmsStrikeoutSize = w32allot(UInt),
  otmsStrikeoutPosition = w32allot(Long),
  otmsUnderscoreSize  = w32allot(Long),
  otmsUnderscorePosition = w32allot(Long),
  otmpFamilyName = w32allot(Long),     -- offset from structure start to ASCIZ string
  otmpFaceName= w32allot(Long),        -- ditto
  otmpStyleName = w32allot(Long),      -- ditto
  otmpFullName = w32allot(Long),       -- ditto
  SIZEOF_OUTLINETEXTMETRIC = w32allotted_size(),
  ID_OUTLINETEXTMETRIC = {{w32CurrentStructure()}},

-- FORM_INFO_1 structure
  FORM_INFO_1_Flags = w32allot(Long),
  FORM_INFO_1_pName = w32allot(Lpsz),
  FORM_INFO_1_Size  = w32allot(Point),
  FORM_INFO_1_ImageableArea = w32allot(Rect),
  SIZEOF_FORM_INFO_1 = w32allotted_size(),
  ID_FORM_INFO_1 = {{w32CurrentStructure()}}

-- declaring structures with start with their size, so that you can omit this in w32to_memory()
setStartWithSize(ID_OSVERSIONINFOEX)
setStartWithSize(ID_INITCOMMONCONTROLSEX)
setStartWithSize(ID_WINDOWINFO)
setStartWithSize(ID_MENUITEMINFO)
setStartWithSize(ID_WNDCLASSEX)
setStartWithSize(ID_SCROLLINFO)
setStartWithSize(ID_COLORDLG)
setStartWithSize(ID_DOCINFO)
setStartWithSize(ID_DRAWTEXTPARAMS)
setStartWithSize(ID_OPENFILENAME)
setStartWithSize(ID_BITMAPINFOHEADER)
setStartWithSize(ID_PAGESETUPDLG)
setStartWithSize(ID_CHARFORMAT)
setStartWithSize(ID_TOOLINFO)
setStartWithSize(ID_REBARBANDINFO)
setStartWithSize(ID_OUTLINETEXTMETRIC)
setStartWithSize(ID_PARAFORMAT)
setStartWithSize(ID_FINDREPLACE)

-- w32Keys.e

global constant
     VK_LBUTTON        = #01
   , VK_RBUTTON        = #02
   , VK_CANCEL         = #03
   , VK_MBUTTON        = #04    -- NOT contiguous with L & RBUTTON
   , VK_XBUTTON1       = #05    -- NOT contiguous with L & RBUTTON
   , VK_XBUTTON2       = #06    -- NOT contiguous with L & RBUTTON
   , VK_BACK           = #08
   , VK_BACKSPACE      = VK_BACK -- win32lib.ew special alias
   , VK_TAB            = #09
   , VK_CLEAR          = #0C
   , VK_RETURN         = #0D
   , VK_ENTER          = VK_RETURN -- win32lib.ew special alias
   , VK_SHIFT          = #10
   , VK_CONTROL        = #11
   , VK_MENU           = #12
   , VK_PAUSE          = #13
   , VK_CAPITAL        = #14
   , VK_KANA           = #15
   , VK_HANGEUL        = #15  -- old name - should be here for compatibility
   , VK_HANGUL         = #15
   , VK_JUNJA          = #17
   , VK_FINAL          = #18
   , VK_HANJA          = #19
   , VK_KANJI          = #19
   , VK_ESCAPE         = #1B
   , VK_CONVERT        = #1C
   , VK_NONCONVERT     = #1D
   , VK_ACCEPT         = #1E
   , VK_MODECHANGE     = #1F
   , VK_SPACE          = #20
   , VK_PRIOR          = #21
   , VK_PAGEUP         = VK_PRIOR -- win32lib.ew special alias
   , VK_NEXT           = #22
   , VK_PAGEDOWN       = VK_NEXT -- win32lib.ew special alias
   , VK_END            = #23
   , VK_HOME           = #24
   , VK_LEFT           = #25
   , VK_UP             = #26
   , VK_RIGHT          = #27
   , VK_DOWN           = #28
   , VK_SELECT         = #29
   , VK_PRINT          = #2A
   , VK_EXECUTE        = #2B
   , VK_SNAPSHOT       = #2C
   , VK_INSERT         = #2D
   , VK_DELETE         = #2E
   , VK_HELP           = #2F
-- * VK_0 - VK_9 are the same as ASCII '0' - '9' ( #30 - #39)
-- * #40 : unassigned
-- * VK_A - VK_Z are the same as ASCII 'A' - 'Z' ( #41 - #5A)
   , VK_LWIN           = #5B
   , VK_RWIN           = #5C
   , VK_APPS           = #5D
-- #5E : reserved
   , VK_SLEEP          = #5F
   , VK_NUMPAD0        = #60
   , VK_NUMPAD1        = #61
   , VK_NUMPAD2        = #62
   , VK_NUMPAD3        = #63
   , VK_NUMPAD4        = #64
   , VK_NUMPAD5        = #65
   , VK_NUMPAD6        = #66
   , VK_NUMPAD7        = #67
   , VK_NUMPAD8        = #68
   , VK_NUMPAD9        = #69
   , VK_MULTIPLY       = #6A
   , VK_ADD            = #6B
   , VK_SEPARATOR      = #6C
   , VK_SUBTRACT       = #6D
   , VK_DECIMAL        = #6E
   , VK_DIVIDE         = #6F
   , VK_F1             = #70
   , VK_F2             = #71
   , VK_F3             = #72
   , VK_F4             = #73
   , VK_F5             = #74
   , VK_F6             = #75
   , VK_F7             = #76
   , VK_F8             = #77
   , VK_F9             = #78
   , VK_F10            = #79
   , VK_F11            = #7A
   , VK_F12            = #7B
   , VK_F13            = #7C
   , VK_F14            = #7D
   , VK_F15            = #7E
   , VK_F16            = #7F
   , VK_F17            = #80
   , VK_F18            = #81
   , VK_F19            = #82
   , VK_F20            = #83
   , VK_F21            = #84
   , VK_F22            = #85
   , VK_F23            = #86
   , VK_F24            = #87
-- * #88 - #8F : unassigned
   , VK_NUMLOCK        = #90
   , VK_SCROLL         = #91
-- * NEC PC-9800 kbd definitions
   , VK_OEM_NEC_EQUAL  = #92   -- '=' key on numpad
-- * Fujitsu/OASYS kbd definitions
   , VK_OEM_FJ_JISHO   = #92   -- 'Dictionary' key
   , VK_OEM_FJ_MASSHOU = #93   -- 'Unregister word' key
   , VK_OEM_FJ_TOUROKU = #94   -- 'Register word' key
   , VK_OEM_FJ_LOYA    = #95   -- 'Left OYAYUBI' key
   , VK_OEM_FJ_ROYA    = #96   -- 'Right OYAYUBI' key
-- * #97 - #9F : unassigned
-- * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
-- * Used only as parameters to GetAsyncKeyState() and GetKeyState().
-- * No other API or message will distinguish left and right keys in this way.
   , VK_LSHIFT         = #A0
   , VK_RSHIFT         = #A1
   , VK_LCONTROL       = #A2
   , VK_RCONTROL       = #A3
   , VK_LMENU          = #A4
   , VK_RMENU          = #A5
   , VK_BROWSER_BACK        = #A6  -- Windows 5.00 or later
   , VK_BROWSER_FORWARD     = #A7  -- Windows 5.00 or later
   , VK_BROWSER_REFRESH     = #A8  -- Windows 5.00 or later
   , VK_BROWSER_STOP        = #A9  -- Windows 5.00 or later
   , VK_BROWSER_SEARCH      = #AA  -- Windows 5.00 or later
   , VK_BROWSER_FAVORITES   = #AB  -- Windows 5.00 or later
   , VK_BROWSER_HOME        = #AC  -- Windows 5.00 or later
   , VK_VOLUME_MUTE         = #AD  -- Windows 5.00 or later
   , VK_VOLUME_DOWN         = #AE  -- Windows 5.00 or later
   , VK_VOLUME_UP           = #AF  -- Windows 5.00 or later
   , VK_MEDIA_NEXT_TRACK    = #B0  -- Windows 5.00 or later
   , VK_MEDIA_PREV_TRACK    = #B1  -- Windows 5.00 or later
   , VK_MEDIA_STOP          = #B2  -- Windows 5.00 or later
   , VK_MEDIA_PLAY_PAUSE    = #B3  -- Windows 5.00 or later
   , VK_LAUNCH_MAIL         = #B4  -- Windows 5.00 or later
   , VK_LAUNCH_MEDIA_SELECT = #B5  -- Windows 5.00 or later
   , VK_LAUNCH_APP1         = #B6  -- Windows 5.00 or later
   , VK_LAUNCH_APP2         = #B7  -- Windows 5.00 or later
-- * #B8 - #B9 : reserved
   , VK_OEM_1          = #BA   -- ';:' for US
   , VK_OEM_PLUS       = #BB   -- '+' any country
   , VK_OEM_COMMA      = #BC   -- ',' any country
   , VK_OEM_MINUS      = #BD   -- '-' any country
   , VK_OEM_PERIOD     = #BE   -- '.' any country
   , VK_OEM_2          = #BF   -- '/?' for US
   , VK_OEM_3          = #C0   -- '`~' for US
-- * #C1 - #D7 : reserved
-- * #D8 - #DA : unassigned
   , VK_OEM_4          = #DB  --  '[{' for US
   , VK_OEM_5          = #DC  --  '\|' for US
   , VK_OEM_6          = #DD  --  ']}' for US
   , VK_OEM_7          = #DE  --  ''"' for US
   , VK_OEM_8          = #DF
-- * #E0 : reserved
-- * Various extended or enhanced keyboards
   , VK_OEM_AX         = #E1  --  'AX' key on Japanese AX kbd
   , VK_OEM_102        = #E2  --  "<>" or "\|" on RT 102-key kbd.
   , VK_ICO_HELP       = #E3  --  Help key on ICO
   , VK_ICO_00         = #E4  --  00 key on ICO
   , VK_PROCESSKEY     = #E5  -- Windows 4.00 or later
   , VK_ICO_CLEAR      = #E6
   , VK_PACKET         = #E7  -- Windows 5.00 or later
-- * #E8 : unassigned
-- * Nokia/Ericsson definitions
   , VK_OEM_RESET      = #E9
   , VK_OEM_JUMP       = #EA
   , VK_OEM_PA1        = #EB
   , VK_OEM_PA2        = #EC
   , VK_OEM_PA3        = #ED
   , VK_OEM_WSCTRL     = #EE
   , VK_OEM_CUSEL      = #EF
   , VK_OEM_ATTN       = #F0
   , VK_OEM_FINISH     = #F1
   , VK_OEM_COPY       = #F2
   , VK_OEM_AUTO       = #F3
   , VK_OEM_ENLW       = #F4
   , VK_OEM_BACKTAB    = #F5
   , VK_ATTN           = #F6
   , VK_CRSEL          = #F7
   , VK_EXSEL          = #F8
   , VK_EREOF          = #F9
   , VK_PLAY           = #FA
   , VK_ZOOM           = #FB
   , VK_NONAME         = #FC
   , VK_PA1            = #FD
   , VK_OEM_CLEAR      = #FE
-- * End Nokia/Ericsson definitions

-- w32constants.ew

global constant
    -- used in alignControls()
    w32LeftEdge   = 'L',
    w32Leftmost   = 'l',
    w32TopEdge    = 'T',
    w32Topmost    = 't',
    w32RightEdge  = 'R',
    w32Rightmost  = 'r',
    w32BottomEdge = 'B',
    w32Bottommost = 'b',
    -- used in distributeControls()
    w32VertCentre = 'V',
    w32HorzCentre = 'H',
    w32VertGap    = 'v',
    w32HorzGap    = 'h',
    -- used in sizeControls()
    w32Widest     = 'W',
    w32Narrowest  = 'N',
    w32Tallest    = 'T',
    w32Shortest   = 'S',
    w32Width      = 'w',
    w32Height     = 'h',
    -- Request Codes
    w32Request_RtnId = 'r'

--/topic Constants
--/const kMainMsg
--/desc Used by the notify and raw message handlers. See /setNotifyHandler

--/topic Constants
--/const kReturnNow
--/desc Used by the notify and raw message handlers. See /setNotifyHandler

--/topic Constants
--/const kSubclassedMsg
--/desc Used by the notify and raw message handlers. See /setNotifyHandler

--/topic Constants
--/const kProcessMsg
--/desc Used by the notify and raw message handlers. See /setNotifyHandler


--/topic Constants
--/const w32PB_ICON
--/desc Used when creating a /PictureButton and /ToggleButton.

--/topic Constants
--/const w32PB_BITMAP
--/desc Used when creating a /PictureButton and /ToggleButton.

--/topic Constants
--/const w32KH_SetFocus
--/desc Used as a return value by w32HKeyDown handlers to indicate that the focus needs to be changed.

--/topic Constants
--/const w32LV_StartSorting
--/desc Used by /ListView controls that have a custom sorting routine.

--/topic Constants
--/const w32LV_EndSorting
--/desc Used by /ListView controls that have a custom sorting routine.

-- Some magic numbers.
global constant
    kMainMsg = -2761,
    kReturnNow = kMainMsg,
    kSubclassedMsg = -9987,
    kWinDefProc = kSubclassedMsg,

    w32PB_ICON = {-1,"icon"},
    w32PB_BITMAP = {-1,"bitmap"},

    w32KH_SetFocus = {-1, "setfocus"},

    w32LV_StartSorting = 0,
    w32LV_EndSorting = 1

-- Font Weights
global constant
    FW_DONTCARE = 0,
    FW_THIN    = 100,
    FW_EXTRALIGHT = 200,
    FW_ULTRALIGHT = 200,
    FW_LIGHT = 300,
    FW_NORMAL = 400,
    FW_REGULAR = 400,
    FW_MEDIUM = 500,
    FW_SEMIBOLD = 600,
    FW_DEMIBOLD = 600,
    FW_BOLD = 700,
    FW_EXTRABOLD = 800,
    FW_ULTRABOLD = 800,
    FW_HEAVY = 900,
    FW_BLACK = 900

global constant
    w32Color_SCROLLBAR             = -1,
    w32Color_BACKGROUND            = -2,
    w32Color_DESKTOP               = w32Color_BACKGROUND,
    w32Color_ACTIVECAPTION         = -3,
    w32Color_INACTIVECAPTION       = -4,
    w32Color_MENU                  = -5,
    w32Color_WINDOW                = -6,
    w32Color_WINDOWFRAME           = -7,
    w32Color_MENUTEXT              = -8,
    w32Color_WINDOWTEXT            = -9,
    w32Color_CAPTIONTEXT           = -10,
    w32Color_ACTIVEBORDER          = -11,
    w32Color_INACTIVEBORDER        = -12,
    w32Color_APPWORKSPACE          = -13,
    w32Color_HIGHLIGHT             = -14,
    w32Color_HIGHLIGHTTEXT         = -15,
    w32Color_BTNFACE               = -16,
    w32Color_3DFACE                = w32Color_BTNFACE,
    w32Color_BTNSHADOW             = -17,
    w32Color_3DSHADOW              = w32Color_BTNSHADOW,
    w32Color_GRAYTEXT              = -18,
    w32Color_BTNTEXT               = -19,
    w32Color_INACTIVECAPTIONTEXT   = -20,
    w32Color_BTNHIGHLIGHT          = -21,
    w32Color_3DHILIGHT             = w32Color_BTNHIGHLIGHT,
    w32Color_3DDKSHADOW            = -22,
    w32Color_3DLIGHT               = -23,
    w32Color_INFOTEXT              = -24,
    w32Color_TOOLTIPTEXT           = w32Color_INFOTEXT,
    w32Color_INFOBK                = -25,
    w32Color_TOOLTIPBK             = w32Color_INFOBK,
    w32Color_HOTLIGHT              = -27,
    w32Color_GRADIENTACTIVECAPTION = -28,
    w32Color_GRADIENTINACTIVECAPTION = -29,
    w32Color_MENUHILIGHT           = -30,
    w32Color_MENUBAR               = -31

global constant
    -- font attributes
    w32FontName        = 1,
    w32FontSize        = 2,
    w32FontAttrib      = 3,
    w32FontColor       = 4

    -- Windows versions
global constant
    WIN_3_1     = 1,
    WIN_95      = 2,
    WIN_95_OSR2 = 2.5,
    WIN_98      = 3,
    WIN_98SE    = 3.5,
    WIN_ME      = 4,
    WIN_NT_3_51 = 5,
    WIN_NT_4    = 6,
    WIN_2000    = 7,
    WIN_XP      = 8,
    WIN_VISTA   = 9,
    WIN_UNKNOWN = 0

global constant
       DLGC_WANTARROWS =#0001,
       DLGC_WANTTAB =#0002,
       DLGC_WANTALLKEYS =#0004,
       DLGC_WANTCHARS =#0008,
       DLGC_WANTENTER  =#0010,
       DLGC_RADIOBUTTON =#0040,
       DLGC_HASSETSEL =#0080,
       DLGC_DEFPUSHBUTTON =#0100,
       DLGC_UNDEFPUSHBUTTON =#0200,
       DLGC_3STATE  =#0800,
       DLGC_STATIC =#1000,
       DLGC_BUTTON =#2000

-- Moved initialization of common controls to procedure.  Also had to
-- move location in order to use structures.
global constant
    ICC_LISTVIEW_CLASSES = #1, --// listview, hader
    ICC_TREEVIEW_CLASSES = #2, --// treeview, tooltips
    ICC_BAR_CLASSES      = #4, --// toolbar, statusbar, trackbar, tooltips
    ICC_TAB_CLASSES      = #8, --// tab, tooltips
    ICC_UPDOWN_CLASS     = #10, --// updown
    ICC_PROGRESS_CLASS   = #20, --// proress
    ICC_HOTKEY_CLASS     = #40, --// hotkey
    ICC_ANIMATE_CLASS    = #80, --// animate
    ICC_WIN95_CLASSES    = #FF,
    ICC_DATE_CLASSES     = #100, -- month picker, date picker, time picker, updown
    ICC_USEREX_CLASSES   = #200, -- comboex
    ICC_COOL_CLASSES     = #400, -- rebar (coolbar) control
    ICC_INTERNET_CLASSES = #800,
    ICC_PAGESCROLLER_CLASS = #1000,   -- page scroller
    ICC_NATIVEFNTCTL_CLASS = #2000,

    -- Private Window Messages Start Here:
    WM_USER = #400,

-- drawText() cnstants
    DT_TOP                  = #00000000,
    DT_LEFT                 = #00000000,
    DT_CENTER               = #00000001,
    DT_RIGHT                = #00000002,
    DT_VCENTER              = #00000004,
    DT_BOTTOM               = #00000008,
    DT_WORDBREAK            = #00000010,
    DT_SINGLELINE           = #00000020,
    DT_EXPANDTABS           = #00000040,
    DT_TABSTOP              = #00000080,
    DT_NOCLIP               = #00000100,
    DT_EXTERNALLEADING      = #00000200,
    DT_CALCRECT             = #00000400,
    DT_NOPREFIX             = #00000800,
    DT_INTERNAL             = #00001000,
    DT_EDITCONTROL          = #00002000,
    DT_PATH_ELLIPSIS        = #00004000,
    DT_END_ELLIPSIS         = #00008000,
    DT_MODIFYSTRING         = #00010000,
    DT_RTLREADING           = #00020000,
    DT_WORD_ELLIPSIS        = #00040000,
    DT_NOFULLWIDTHCHARBREAK = #00080000,
    DT_HIDEPREFIX           = #00100000,
    DT_PREFIXONLY           = #00200000,


    -- biCompression field values:
		BI_JPEG = 4,
		BI_PNG = 5,
		BI_RGB = 0,
		BI_RLE4 = 2,
		BI_RLE8 = 1,
		BI_bitfields = 3,

--
-- Flags in dmFields determine what has/has not been initialised
    DM_ORIENTATION      = #00001,
    DM_PAPERSIZE        = #00002,
    DM_PAPERLENGTH      = #00004,
    DM_PAPERWIDTH       = #00008,
    DM_SCALE            = #00010,
    DM_COPIES           = #00100,
    DM_DEFAULTSOURCE    = #00200,
    DM_PRINTQUALITY     = #00400,
    DM_COLOR            = #00800,
    DM_DUPLEX           = #01000,
    DM_YRESOLUTION      = #02000,
    DM_TTOPTION         = #04000,
    DM_COLLATE          = #08000,
    DM_FORMNAME         = #10000,
    DM_SPECVERSION      = #00400,
--
---- paper orientation
--
    DMORIENT_PORTRAIT   = 1,
    DMORIENT_LANDSCAPE  = 2,
---- paper standard sizes
 DMPAPER_LETTER                  =  1, -- Letter 8 1/2 x 11 in
 DMPAPER_FIRST                   =  DMPAPER_LETTER,
 DMPAPER_LETTERSMALL             =  2  ,--Letter Small 8 1/2 x 11 in
 DMPAPER_TABLOID                 =  3  ,--Tabloid 11 x 17 in
 DMPAPER_LEDGER                  =  4  ,--Ledger 17 x 11 in
 DMPAPER_LEGAL                   =  5  ,--Legal 8 1/2 x 14 in
 DMPAPER_STATEMENT               =  6  ,--Statement 5 1/2 x 8 1/2 in
 DMPAPER_EXECUTIVE               =  7  ,--Executive 7 1/4 x 10 1/2 in
 DMPAPER_A3                      =  8  ,--A3 297 x 420 mm
 DMPAPER_A4                      =  9  ,--A4 210 x 297 mm
 DMPAPER_A4SMALL                 = 10  ,--A4 Small 210 x 297 mm
 DMPAPER_A5                      = 11  ,--A5 148 x 210 mm
 DMPAPER_B4                      = 12  ,--B4 (JIS) 250 x 354
 DMPAPER_B5                      = 13  ,--B5 (JIS) 182 x 257 mm
 DMPAPER_FOLIO                   = 14  ,--Folio 8 1/2 x 13 in
 DMPAPER_QUARTO                  = 15  ,--Quarto 215 x 275 mm
 DMPAPER_10X14                   = 16  ,--10x14 in
 DMPAPER_11X17                   = 17  ,--11x17 in
 DMPAPER_NOTE                    = 18  ,--Note 8 1/2 x 11 in
 DMPAPER_ENV_9                   = 19  ,--Envelope #9 3 7/8 x 8 7/8
 DMPAPER_ENV_10                  = 20  ,--Envelope #10 4 1/8 x 9 1/2
 DMPAPER_ENV_11                  = 21  ,--Envelope #11 4 1/2 x 10 3/8
 DMPAPER_ENV_12                  = 22  ,--Envelope #12 4 \276 x 11
 DMPAPER_ENV_14                  = 23  ,--Envelope #14 5 x 11 1/2
 DMPAPER_CSHEET                  = 24  ,--C size sheet
 DMPAPER_DSHEET                  = 25  ,--D size sheet
 DMPAPER_ESHEET                  = 26  ,--E size sheet
 DMPAPER_ENV_DL                  = 27  ,--Envelope DL 110 x 220mm
 DMPAPER_ENV_C5                  = 28  ,--Envelope C5 162 x 229 mm
 DMPAPER_ENV_C3                  = 29  ,--Envelope C3  324 x 458 mm
 DMPAPER_ENV_C4                  = 30  ,--Envelope C4  229 x 324 mm
 DMPAPER_ENV_C6                  = 31  ,--Envelope C6  114 x 162 mm
 DMPAPER_ENV_C65                 = 32  ,--Envelope C65 114 x 229 mm
 DMPAPER_ENV_B4                  = 33  ,--Envelope B4  250 x 353 mm
 DMPAPER_ENV_B5                  = 34  ,--Envelope B5  176 x 250 mm
 DMPAPER_ENV_B6                  = 35  ,--Envelope B6  176 x 125 mm
 DMPAPER_ENV_ITALY               = 36  ,--Envelope 110 x 230 mm
 DMPAPER_ENV_MONARCH             = 37  ,--Envelope Monarch 3.875 x 7.5 in
 DMPAPER_ENV_PERSONAL            = 38  ,--6 3/4 Envelope 3 5/8 x 6 1/2 in
 DMPAPER_FANFOLD_US              = 39  ,--US Std Fanfold 14 7/8 x 11 in
 DMPAPER_FANFOLD_STD_GERMAN      = 40  ,--German Std Fanfold 8 1/2 x 12 in
 DMPAPER_FANFOLD_LGL_GERMAN      = 41  ,--German Legal Fanfold 8 1/2 x 13 in
 DMPAPER_ISO_B4                  = 42  ,--B4 (ISO) 250 x 353 mm
 DMPAPER_JAPANESE_POSTCARD       = 43  ,--Japanese Postcard 100 x 148 mm
 DMPAPER_9X11                    = 44  ,--9 x 11 in
 DMPAPER_10X11                   = 45  ,--10 x 11 in
 DMPAPER_15X11                   = 46  ,--15 x 11 in
 DMPAPER_ENV_INVITE              = 47  ,--Envelope Invite 220 x 220 mm
 DMPAPER_RESERVED_48             = 48  ,--RESERVED--DO NOT USE
 DMPAPER_RESERVED_49             = 49  ,--RESERVED--DO NOT USE
 DMPAPER_LETTER_EXTRA            = 50  ,--Letter Extra 9 \275 x 12 in
 DMPAPER_LEGAL_EXTRA             = 51  ,--Legal Extra 9 \275 x 15 in
 DMPAPER_TABLOID_EXTRA           = 52  ,--Tabloid Extra 11.69 x 18 in
 DMPAPER_A4_EXTRA                = 53  ,--A4 Extra 9.27 x 12.69 in
 DMPAPER_LETTER_TRANSVERSE       = 54  ,--Letter Transverse 8 \275 x 11 in
 DMPAPER_A4_TRANSVERSE           = 55  ,--A4 Transverse 210 x 297 mm
 DMPAPER_LETTER_EXTRA_TRANSVERSE = 56  ,--etter Extra Transverse 9\275 x 12 in
 DMPAPER_A_PLUS                  = 57  ,--SuperA/SuperA/A4 227 x 356 mm
 DMPAPER_B_PLUS                  = 58  ,--SuperB/SuperB/A3 305 x 487 mm
 DMPAPER_LETTER_PLUS             = 59  ,--Letter Plus 8.5 x 12.69 in
 DMPAPER_A4_PLUS                 = 60  ,--A4 Plus 210 x 330 mm
 DMPAPER_A5_TRANSVERSE           = 61  ,--A5 Transverse 148 x 210 mm
 DMPAPER_B5_TRANSVERSE           = 62  ,--B5 (JIS) Transverse 182 x 257 mm
 DMPAPER_A3_EXTRA                = 63  ,--A3 Extra 322 x 445 mm
 DMPAPER_A5_EXTRA                = 64  ,--A5 Extra 174 x 235 mm
 DMPAPER_B5_EXTRA                = 65  ,--B5 (ISO) Extra 201 x 276 mm
 DMPAPER_A2                      = 66  ,--A2 420 x 594 mm
 DMPAPER_A3_TRANSVERSE           = 67  ,--A3 Transverse 297 x 420 mm
 DMPAPER_A3_EXTRA_TRANSVERSE     = 68  ,--A3 Extra Transverse 322 x 445 mm
-- the following values are supported under Win2K and up
 DMPAPER_DBL_JAPANESE_POSTCARD   = 69  ,--apanese Double Postcard 200 x 148 mm
 DMPAPER_A6                      = 70  ,--A6 105 x 148 mm
 DMPAPER_JENV_KAKU2              = 71  ,--Japanese Envelope Kaku #2
 DMPAPER_JENV_KAKU3              = 72  ,--Japanese Envelope Kaku #3
 DMPAPER_JENV_CHOU3              = 73  ,--Japanese Envelope Chou #3
 DMPAPER_JENV_CHOU4              = 74  ,--Japanese Envelope Chou #4
 DMPAPER_LETTER_ROTATED          = 75  ,--Letter Rotated 11 x 8 1/2 11 in
 DMPAPER_A3_ROTATED              = 76  ,--A3 Rotated 420 x 297 mm
 DMPAPER_A4_ROTATED              = 77  ,--A4 Rotated 297 x 210 mm
 DMPAPER_A5_ROTATED              = 78  ,--A5 Rotated 210 x 148 mm
 DMPAPER_B4_JIS_ROTATED          = 79  ,--B4 (JIS) Rotated 364 x 257 mm
 DMPAPER_B5_JIS_ROTATED          = 80  ,--B5 (JIS) Rotated 257 x 182 mm
 DMPAPER_JAPANESE_POSTCARD_ROTATED=81  ,--apanese Postcard Rotated 148 x 100 mm
 DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED
                                 = 82  ,--ouble Japanese Postcard Rotated 148 x 200 mm
 DMPAPER_A6_ROTATED              = 83  ,--A6 Rotated 148 x 105 mm
 DMPAPER_JENV_KAKU2_ROTATED      = 84  ,--Japanese Envelope Kaku #2 Rotated
 DMPAPER_JENV_KAKU3_ROTATED      = 85  ,--Japanese Envelope Kaku #3 Rotated
 DMPAPER_JENV_CHOU3_ROTATED      = 86  ,--Japanese Envelope Chou #3 Rotated
 DMPAPER_JENV_CHOU4_ROTATED      = 87  ,--Japanese Envelope Chou #4 Rotated
 DMPAPER_B6_JIS                  = 88  ,--B6 (JIS) 128 x 182 mm
 DMPAPER_B6_JIS_ROTATED          = 89  ,--B6 (JIS) Rotated 182 x 128 mm
 DMPAPER_12X11                   = 90  ,--12 x 11 in
 DMPAPER_JENV_YOU4               = 91  ,--Japanese Envelope You #4
 DMPAPER_JENV_YOU4_ROTATED       = 92  ,--Japanese Envelope You #4 Rotated
 DMPAPER_P16K                    = 93  ,--PRC 16K 146 x 215 mm
 DMPAPER_P32K                    = 94  ,--PRC 32K 97 x 151 mm
 DMPAPER_P32KBIG                 = 95  ,--PRC 32K(Big) 97 x 151 mm
 DMPAPER_PENV_1                  = 96  ,--PRC Envelope #1 102 x 165 mm
 DMPAPER_PENV_2                  = 97  ,--PRC Envelope #2 102 x 176 mm
 DMPAPER_PENV_3                  = 98  ,--PRC Envelope #3 125 x 176 mm
 DMPAPER_PENV_4                  = 99  ,--PRC Envelope #4 110 x 208 mm
 DMPAPER_PENV_5                  = 100 ,--PRC Envelope #5 110 x 220 mm
 DMPAPER_PENV_6                  = 101 ,--PRC Envelope #6 120 x 230 mm
 DMPAPER_PENV_7                  = 102 ,--PRC Envelope #7 160 x 230 mm
 DMPAPER_PENV_8                  = 103 ,--PRC Envelope #8 120 x 309 mm
 DMPAPER_PENV_9                  = 104 ,--PRC Envelope #9 229 x 324 mm
 DMPAPER_PENV_10                 = 105 ,--PRC Envelope #10 324 x 458 mm
 DMPAPER_P16K_ROTATED            = 106 ,--PRC 16K Rotated
 DMPAPER_P32K_ROTATED            = 107 ,--PRC 32K Rotated
 DMPAPER_P32KBIG_ROTATED         = 108 ,--PRC 32K(Big) Rotated
 DMPAPER_PENV_1_ROTATED          = 109 ,--PRC Envelope #1 Rotated 165 x 102 mm
 DMPAPER_PENV_2_ROTATED          = 110 ,--PRC Envelope #2 Rotated 176 x 102 mm
 DMPAPER_PENV_3_ROTATED          = 111 ,--PRC Envelope #3 Rotated 176 x 125 mm
 DMPAPER_PENV_4_ROTATED          = 112 ,--PRC Envelope #4 Rotated 208 x 110 mm
 DMPAPER_PENV_5_ROTATED          = 113 ,--PRC Envelope #5 Rotated 220 x 110 mm
 DMPAPER_PENV_6_ROTATED          = 114 ,--PRC Envelope #6 Rotated 230 x 120 mm
 DMPAPER_PENV_7_ROTATED          = 115 ,--PRC Envelope #7 Rotated 230 x 160 mm
 DMPAPER_PENV_8_ROTATED          = 116 ,--PRC Envelope #8 Rotated 309 x 120 mm
 DMPAPER_PENV_9_ROTATED          = 117 ,--PRC Envelope #9 Rotated 324 x 229 mm
 DMPAPER_PENV_10_ROTATED         = 118 ,--PRC Envelope #10 Rotated 458 x 324 mm
 DMPAPER_USER                    = 256, -- device specific paper sizes start here.
----
-- paper source - the names are assumed to be self explanatory
DMBIN_UPPER         = 1,
DMBIN_ONLYONE       = DMBIN_UPPER,
DMBIN_FIRST         = DMBIN_UPPER,
DMBIN_LOWER         = 2,
DMBIN_MIDDLE        = 3,
DMBIN_MANUAL        = 4,
DMBIN_ENVELOPE      = 5,
DMBIN_ENVMANUAL     = 6,
DMBIN_AUTO          = 7,
DMBIN_TRACTOR       = 8,
DMBIN_SMALLFMT      = 9,
DMBIN_LARGEFMT      = 10,
DMBIN_LARGECAPACITY = 11,
DMBIN_CASSETTE      = 14,
DMBIN_FORMSOURCE    = 15,
DMBIN_LAST          = DMBIN_FORMSOURCE,



-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
--  Device Parameters for xGetDeviceCaps() and queryDevice()
    DRIVERVERSION = 0,      --  Device driver version
    TECHNOLOGY = 2,         --  Device classification
    HORZSIZE = 4,           --  Horizontal size in millimeters
    VERTSIZE = 6,           --  Vertical size in millimeters
    HORZRES = 8,            --  Horizontal width in pixels
    VERTRES = 10,           --  Vertical width in pixels
    BITSPIXEL = 12,         --  Number of bits per pixel
    PLANES = 14,            --  Number of planes
    NUMBRUSHES = 16,        --  Number of brushes the device has
    NUMPENS = 18,           --  Number of pens the device has
    NUMMARKERS = 20,        --  Number of markers the device has
    NUMFONTS = 22,          --  Number of fonts the device has
    NUMCOLORS = 24,         --  Number of colors the device supports
    PDEVICESIZE = 26,       --  Size required for device descriptor
    CURVECAPS = 28,         --  Curve capabilities
    LINECAPS = 30,          --  Line capabilities
    POLYGONALCAPS = 32,     --  Polygonal capabilities
    TEXTCAPS = 34,          --  Text capabilities
    CLIPCAPS = 36,          --  Clipping capabilities
    RASTERCAPS = 38,        --  Bitblt capabilities
    ASPECTX = 40,           --  Length of the X leg
    ASPECTY = 42,           --  Length of the Y leg
    ASPECTXY = 44,          --  Length of the hypotenuse

    LOGPIXELSX = 88,        --  Logical pixels/inch in X
    LOGPIXELSY = 90,        --  Logical pixels/inch in Y

    SIZEPALETTE = 104,      --  Number of entries in physical palette
    NUMRESERVED = 106,      --  Number of reserved entries in palette
    COLORRES = 108,         --  Actual color resolution

--  Printing related DeviceCaps. These replace the appropriate Escapes
    PHYSICALWIDTH = 110, --  Physical Width in device units
    PHYSICALHEIGHT = 111, --  Physical Height in device units
    PHYSICALOFFSETX = 112, --  Physical Printable Area x margin
    PHYSICALOFFSETY = 113, --  Physical Printable Area y margin
    SCALINGFACTORX = 114, --  Scaling factor x
    SCALINGFACTORY = 115  --  Scaling factor y

-----------------------------------------------------------------------------

global constant
    OUT_DEFAULT_PRECIS    =      0,
    OUT_STRING_PRECIS     =      1,
    OUT_CHARACTER_PRECIS  =      2,
    OUT_STROKE_PRECIS     =      3,
    OUT_TT_PRECIS         =      4,
    OUT_DEVICE_PRECIS     =      5,
    OUT_RASTER_PRECIS     =      6,
    OUT_TT_ONLY_PRECIS    =      7,
    OUT_OUTLINE_PRECIS    =      8,
    OUT_SCREEN_OUTLINE_PRECIS =  9,
    OUT_PS_ONLY_PRECIS      =    10,

    CLIP_DEFAULT_PRECIS   =  0,
    CLIP_CHARACTER_PRECIS =  1,
    CLIP_STROKE_PRECIS    =  2,
    CLIP_MASK             =  15,
    CLIP_LH_ANGLES        =  #10000,
    CLIP_TT_ALWAYS        =  #20000,
    CLIP_EMBEDDED         =  #80000,

    DEFAULT_QUALITY       =  0,
    DRAFT_QUALITY         =  1,
    PROOF_QUALITY         =  2,
    NONANTIALIASED_QUALITY = 3,
    ANTIALIASED_QUALITY    = 4,

    DEFAULT_PITCH          = 0,
    FIXED_PITCH            = 1,
    VARIABLE_PITCH         = 2,
    MONO_FONT              = 8,

    ANSI_CHARSET           = 0,
    DEFAULT_CHARSET        = 1,
    SYMBOL_CHARSET         = 2,
    SHIFTJIS_CHARSET       = 128,
    HANGEUL_CHARSET        = 129,
    HANGUL_CHARSET         = 129,
    GB2312_CHARSET         = 134,
    CHINESEBIG5_CHARSET    = 136,
    OEM_CHARSET            = 255,
    JOHAB_CHARSET          = 130,
    HEBREW_CHARSET         = 177,
    ARABIC_CHARSET         = 178,
    GREEK_CHARSET          = 161,
    TURKISH_CHARSET        = 162,
    VIETNAMESE_CHARSET     = 163,
    THAI_CHARSET           = 222,
    EASTEUROPE_CHARSET     = 238,
    RUSSIAN_CHARSET        = 204,

    MAC_CHARSET            = 77,
    BALTIC_CHARSET         = 186,

    FS_LATIN1              = #00000001,
    FS_LATIN2              = #00000002,
    FS_CYRILLIC            = #00000004,
    FS_GREEK               = #00000008,
    FS_TURKISH             = #00000010,
    FS_HEBREW              = #00000020,
    FS_ARABIC              = #00000040,
    FS_BALTIC              = #00000080,
    FS_VIETNAMESE          = #00000100,
    FS_THAI                = #00010000,
    FS_JISJAPAN            = #00020000,
    FS_CHINESESIMP         = #00040000,
    FS_WANSUNG             = #00080000,
    FS_CHINESETRAD         = #00100000,
    FS_JOHAB               = #00200000,
    FS_SYMBOL              = #80000000,

    -- Font Families
    FF_DONTCARE       =  #00000, --  /* Don't care or don't know. */
    FF_ROMAN          =  #10000, -- /* Variable stroke width, serifed. */
                                 --       /* Times Roman, Century Schoolbook, etc. */
    FF_SWISS          =  #20000, -- /* Variable stroke width, sans-serifed. */
                                 --       /* Helvetica, Swiss, etc. */
    FF_MODERN         =  #30000, -- /* Constant stroke width, serifed or sans-serifed. */
                                 --       /* Pica, Elite, Courier, etc. */
    FF_SCRIPT         =  #40000, -- /* Cursive, etc. */
    FF_DECORATIVE     =  #50000, -- /* Old English, etc. */

-- Class styles
    CS_VREDRAW = #1,
    CS_HREDRAW = #2,
    CS_KEYCVTWINDOW = #4,
    CS_DBLCLKS = #8,
    CS_OWNDC = #20,
    CS_CLASSDC = #40,
    CS_PARENTDC = #80,
    CS_NOKEYCVT = #100,
    CS_NOCLOSE = #200,
    CS_SAVEBITS = #800,
    CS_BYTEALIGNCLIENT = #1000,
    CS_BYTEALIGNWINDOW = #2000,
    CS_PUBLICCLASS = #4000,

-- ShowWindow() Commands
    SW_HIDE = 0,
    SW_SHOWNORMAL = 1,
    SW_NORMAL = 1,
    SW_SHOWMINIMIZED = 2,
    SW_SHOWMAXIMIZED = 3,
    SW_MAXIMIZE = 3,
    SW_SHOWNOACTIVATE = 4,
    SW_SHOW = 5,
    SW_MINIMIZE = 6,
    SW_SHOWMINNOACTIVE = 7,
    SW_SHOWNA = 8,
    SW_RESTORE = 9,
    SW_SHOWDEFAULT = 10,
    SW_MAX = 10,
    w32FullScreen = "fullscreen",

-- PeekMessage options
    PM_NOREMOVE =  0,
    PM_REMOVE   =  1,
    PM_NOYIELD  =  2,

-- Window Messages
    WM_NULL     = #0,
    WM_CREATE   = #1,
    WM_DESTROY  = #2,
    WM_MOVE     = #3,
    WM_SIZE     = #5,

    WM_ACTIVATE = #6,
--
--  WM_ACTIVATE state values

    WA_INACTIVE = 0,
    WA_ACTIVE = 1,
    WA_CLICKACTIVE = 2,

    WM_SETFOCUS         = #7,
    WM_KILLFOCUS        = #8,
    WM_ENABLE           = #A,
    WM_SETREDRAW        = #B,
    WM_SETTEXT          = #C,
    WM_GETTEXT          = #D,
    WM_GETTEXTLENGTH    = #E,
    WM_PAINT            = #F,
    WM_CLOSE            = #10,
    WM_QUERYENDSESSION  = #11,
    WM_QUIT             = #12,
    WM_QUERYOPEN        = #13,
    WM_ERASEBKGND       = #14,
    WM_SYSCOLORCHANGE   = #15,
    WM_ENDSESSION       = #16,
    WM_SHOWWINDOW       = #18,
    WM_WININICHANGE     = #1A,
    WM_DEVMODECHANGE    = #1B,
    WM_ACTIVATEAPP      = #1C,
    WM_FONTCHANGE       = #1D,
    WM_TIMECHANGE       = #1E,
    WM_CANCELMODE       = #1F,
    WM_SETCURSOR        = #20,
    WM_MOUSEACTIVATE    = #21,
    WM_CHILDACTIVATE    = #22,
    WM_QUEUESYNC        = #23,
    WM_GETMINMAXINFO    = #24,
    -- setting fonts in controls
    WM_SETFONT          = #30,
    WM_GETFONT          = #31,

    WM_NOTIFY           = #4E,
    WM_SETICON          = #80,
    -- non-client messages
    WM_NCCREATE         = #81,
    WM_NCDESTROY        = #82,
    WM_NCCALCSIZE       = #83,
    WM_NCHITTEST        = #84,
    WM_NCPAINT          = #85,
    WM_NCACTIVATE       = #86,
    WM_GETDLGCODE       = #87,
    WM_SYNCPAINT        = #88,
    WM_NCMOUSEMOVE      = #A0,
    WM_NCLBUTTONDOWN    = #A1,
    WM_NCLBUTTONUP      = #A2,
    WM_NCLBUTTONDBLCLK  = #A3,
    WM_NCRBUTTONDOWN    = #A4,
    WM_NCRBUTTONUP      = #A5,
    WM_NCRBUTTONDBLCLK  = #A6,
    WM_NCMBUTTONDOWN    = #A7,
    WM_NCMBUTTONUP      = #A8,
    WM_NCMBUTTONDBLCLK  = #A9,
    WM_NCXBUTTONDOWN    = #AB,
    WM_NCXBUTTONUP      = #AC,
    WM_NCXBUTTONDBLCLK  = #AD,

    WM_SYSTIMER         = #118,  -- 280

    WM_PARENTNOTIFY     = #210,
    WM_DROPFILES        = #233,

-- MDI messages

    WM_MDICREATE        = #220,
    WM_MDIDESTROY       = #221,
    WM_MDIACTIVATE      = #222,
    WM_MDIRESTORE       = #223,
    WM_MDINEXT          = #224,
    WM_MDIMAXIMIZE      = #225,
    WM_MDITILE          = #226,
    WM_MDICASCADE       = #227,
    WM_MDIICONARANGE    = #228,
    WM_MDIGETACTIVE     = #229,
    WM_MDISETMENU       = #230,
    WM_ENTERSIZEMOVE    = #231,
    WM_EXITSIZEMOVE     = #232,
    WM_MDIREFRSHMENU    = #234,
    -- mouse events
    WM_MOUSEMOVE        = #200, -- mouse moved
    WM_LBUTTONDOWN      = #201, -- (513) mouse button down
    WM_LBUTTONUP        = #202, -- left button released
    WM_LBUTTONDBLCLK    = #203, -- (515) mouse button double clicked
    WM_RBUTTONDOWN      = #204, -- right button down
    WM_RBUTTONUP        = #205, -- right button released
    WM_RBUTTONDBLCLK    = #206, -- mouse right button double clicked
    WM_MBUTTONDOWN      = #207, -- middle button down
    WM_MBUTTONUP        = #208, -- middle button released
    WM_MBUTTONDBLCLK    = #209, -- middle button double click
    WM_MOUSEWHEEL       = #20A, -- mouse wheel moved
    WM_XBUTTONDOWN      = #20B,
    WM_XBUTTONUP        = #20C,
    WM_XBUTTONDBLCLK    = #20D,

    NM_FIRST      = #0,
    NM_OUTOFMEMORY    =     (NM_FIRST-1),
    NM_CLICK          =     (NM_FIRST-2),    -- uses NMCLICK struct
    NM_DBLCLK         =     (NM_FIRST-3),
    NM_RETURN         =     (NM_FIRST-4),
    NM_RCLICK         =     (NM_FIRST-5),    -- uses NMCLICK struct
    NM_RDBLCLK        =     (NM_FIRST-6),
    NM_SETFOCUS       =     (NM_FIRST-7),
    NM_KILLFOCUS      =     (NM_FIRST-8),
    NM_CUSTOMDRAW     =     (NM_FIRST-12),
    NM_HOVER          =     (NM_FIRST-13),
    NM_NCHITTEST      =     (NM_FIRST-14),   -- uses NMMOUSE struct
    NM_KEYDOWN        =     (NM_FIRST-15),   -- uses NMKEY struct
    NM_RELEASEDCAPTURE=     (NM_FIRST-16),
    NM_SETCURSOR      =     (NM_FIRST-17),   -- uses NMMOUSE struct
    NM_CHAR           =     (NM_FIRST-18),   -- uses NMCHAR struct
    NM_TOOLTIPSCREATED=     (NM_FIRST-19),   -- notify of when the tooltips window is create
    NM_LDOWN          =     (NM_FIRST-20),
    NM_RDOWN          =     (NM_FIRST-21),

    SND_SYNC        = #00000000, -- play synchronously (default)
    SND_ASYNC       = #00000001,
    SND_NODEFAULT   = #00000002, -- silence (!default) if sound not found
    SND_MEMORY      = #00000004, -- pszSound points to a memory file
    SND_LOOP        = #00000008, -- loop the sound until next sndPlaySound
    SND_NOSTOP      = #00000010, -- don't start if anything is currently playing
    SND_PURGE       = #00000040,  -- purge non-static events for task
    SND_APPLICATION = #00000080,-- look for application specific association
    SND_NOWAIT      = #00002000,-- don't wait if the driver is busy
    SND_ALIAS       = #00010000,-- name is a registry alias
    SND_FILENAME    = #00020000,
    SND_RESOURCE    = #00040004,-- name is resource name or atom
    SND_ALIAS_ID    = #00110000,-- alias is a predefined ID

    SND_ALIAS_SYSTEMASTERISK        = 'S' + 256 * '*',
    SND_ALIAS_SYSTEMQUESTION        = 'S' + 256 * '?',
    SND_ALIAS_SYSTEMHAND            = 'S' + 256 * 'H',
    SND_ALIAS_SYSTEMEXIT            = 'S' + 256 * 'E',
    SND_ALIAS_SYSTEMSTART           = 'S' + 256 * 'S',
    SND_ALIAS_SYSTEMWELCOME         = 'S' + 256 * 'W',
    SND_ALIAS_SYSTEMEXCLAMATION     = 'S' + 256 * '!',
    SND_ALIAS_SYSTEMDEFAULT         = 'S' + 256 * 'D',


-- Window Styles
    WS_OVERLAPPED   = #0,
    WS_POPUP        = #80000000,
    WS_CHILD        = #40000000,
    WS_MINIMIZE     = #20000000,
    WS_VISIBLE      = #10000000,
    WS_DISABLED     = #08000000,
    WS_CLIPPINGCHILD= #44000000,
    WS_CLIPSIBLINGS = #04000000,
    WS_CLIPCHILDREN = #02000000,
    WS_MAXIMIZE     = #01000000,
    WS_CAPTION      = #00C00000,      --  WS_BORDER Or WS_DLGFRAME
    WS_BORDER       = #00800000,      -- creates border on window
    WS_DLGFRAME     = #00400000,
    WS_HSCROLL      = #00100000,    -- horizontal scroll bar
    WS_VSCROLL      = #00200000,    -- vertical scroll bar
    WS_SYSMENU      = #00080000,
    WS_THICKFRAME   = #00040000,
    WS_GROUP        = #00020000,
    WS_TABSTOP      = #00010000,   -- use tab stop
    WS_SCROLLBARS   = #00300000,    -- set both vertical and horizontal scrollbars
    WS_MINIMIZEBOX  = #00020000,
    WS_MAXIMIZEBOX  = #00010000,

    WS_NO_RESIZE = {WS_CAPTION,WS_SYSMENU}, --> Win32lib special.
    WS_TILED = WS_OVERLAPPED,
    WS_ICONIC = WS_MINIMIZE,
    WS_SIZEBOX = WS_THICKFRAME,
    WS_OVERLAPPEDWINDOW = w32or_all({  WS_BORDER,
	    	        WS_DLGFRAME,
	    	        WS_SYSMENU,
	    	        WS_THICKFRAME,
	    	        WS_MINIMIZEBOX,
	    	        WS_MAXIMIZEBOX}),


    WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW,

--   Common Window Styles
    WS_POPUPWINDOW = w32or_all({WS_POPUP, WS_BORDER, WS_SYSMENU}),
    WS_CHILDWINDOW = WS_CHILD,

-- Extended styles
    WS_EX_ACCEPTFILES     = #00000010,
    WS_EX_APPWINDOW       = #00040000,
    WS_EX_CLIENTEDGE      = #00000200,
    WS_EX_CONTEXTHELP     = #00000400,
    WS_EX_CONTROLPARENT   = #00010000,
    WS_EX_DLGMODALFRAME   = #00000001,
    WS_EX_LEFT            = #00000000,
    WS_EX_LEFTSCROLLBAR   = #00004000,
    WS_EX_LTRREADING      = #00000000,
    WS_EX_MDICHILD        = #00000040, --64,
    WS_EX_NOPARENTNOTIFY  = #00000004,
    WS_EX_OVERLAPPEDWINDOW =#00000300,
    WS_EX_PALETTEWINDOW   = #00000188,
    WS_EX_RIGHT           = #00001000,
    WS_EX_RIGHTSCROLLBAR  = #00000000,
    WS_EX_RTLREADING      = #00002000,
    WS_EX_STATICEDGE      = #00020000,
    WS_EX_TOOLWINDOW      = #00000080, --128,
    WS_EX_TOPMOST         = #00000008,
    WS_EX_TRANSPARENT     = #00000020, --32,
    WS_EX_WINDOWEDGE      = #00000100,
    WS_EX_LAYERED         = #00080000,
    WS_EX_NOINHERITLAYOUT = #00100000, -- Disable inheritence of mirroring by children
    WS_EX_LAYOUTRTL       = #00400000, --Right to left mirroring
    WS_EX_NOACTIVATE      = #08000000,

    BS_3STATE           = #0005,       -- tri-state button
    w32AUTOCLOSE        = 0&"autoclose", -- generates code to close the main window.
    BS_AUTO3STATE       = #0006,       -- tri-state button, windows toggles
    BS_AUTOCHECKBOX     = #0003,       -- checkbox, windows toggles
    BS_AUTORADIOBUTTON  = #0009,       -- radio button, windows toggles
    BS_BITMAP           = #0080,
    BS_BOTTOM           = #0800,
    BS_CENTER           = #0300,
    BS_CHECKBOX         = #0002,       -- checkbox
    BS_DEFPUSHBUTTON    = #0001,       -- default pushbutton (heavy border)
    BS_GROUPBOX         = #0007,       -- group box
    BS_ICON             = #0040,
    BS_LEFT             = #0100,
    BS_LEFTTEXT         = #020,
    BS_MULTILINE        = #2000,
    BS_NOTIFY           = #4000,
    BS_OWNERDRAW        = #000B,       -- owner drawn
    BS_PUSHBUTTON       = #0000,       -- pushbutton
    BS_PUSHLIKE         = #1000,
    BS_RADIOBUTTON      = #0004,       -- radio button
    BS_RIGHT            = #0200,
    BS_RIGHTBUTTON      = #0020,
    BS_TEXT             = #0000,
    BS_TOP              = #0400,
    BS_USERBUTTON       = #0008,
    BS_VCENTER          = #0C00,

    ES_LEFT             = #00000000,        -- left justified text
    ES_CENTER           = #00000001,        -- centered text
    ES_RIGHT            = #00000002,        -- right justified text
    ES_MULTILINE        = #00000004,        -- multiline edit
    ES_UPPERCASE        = #00000008,
    ES_LOWERCASE        = #00000010,
    ES_PASSWORD         = #00000020,
    ES_AUTOVSCROLL      = #00000040,        -- automatic vertical scroll
    ES_AUTOHSCROLL      = #00000080,        -- automatic horizontal scroll
    ES_AUTOSCROLL       = #000000C0,        -- both vertical and horizontal auto scroll
    ES_NOHIDESEL        = #00000100,
    --ES_DISABLENOSCROLL  = #00000200,     -- disable, rather than hide, unwanted scrollbars
    ES_OEMCONVERT       = #00000400,
    ES_READONLY         = #00000800,
    ES_WANTRETURN       = #00001000,
    ES_NUMBER           = #00002000,
    ES_NUMERIC          = ES_NUMBER,
    ES_SAVESEL          = #00008000,
    ES_SUNKEN           = #00004000,
    ES_DISABLENOSCROLL  = #00002000,


    LBS_NOTIFY            = #0001,-- notify parent on click or double click
    LBS_SORT              = #0002,-- sort strings in box alphabetically
    LBS_NOREDRAW          = #0004,
    LBS_MULTIPLESEL       = #0008,
    LBS_OWNERDRAWFIXED    = #0010,
    LBS_OWNERDRAWVARIABLE = #0020,
    LBS_HASSTRINGS        = #0040,
    LBS_USETABSTOPS       = #0080,
    LBS_NOINTEGRALHEIGHT  = #0100,
    LBS_MULTICOLUMN       = #0200,
    LBS_WANTKEYBOARDINPUT = #0400,
    LBS_EXTENDEDSEL       = #0800,
    LBS_DISABLENOSCROLL   = #1000,
    LBS_NODATA            = #2000,
    LBS_NOSEL             = #4000,
    LBS_STANDARD    = w32or_all( { LBS_NOTIFY, LBS_SORT, WS_VSCROLL, WS_BORDER} ),

    LB_ADDSTRING        = #180,     -- list box: add string
    LB_INSERTSTRING     = #181,     -- list box: insert string
    LB_DELETESTRING     = #182,     -- list box: delete string
    LB_SELITEMRANGEEX   = #183,
    LB_RESETCONTENT     = #184,     -- list box: reset list
    LB_GETTEXT          = #189,     -- list box: get text
    LB_GETTEXTLEN       = #18A,     -- list box: get length of text
    LB_GETCOUNT         = #18B,     -- list box: get length of list
    LB_GETCURSEL        = #188,     -- list box: get index of selected item
    LB_SETSEL           = #185,     -- list box: set index of multiple selected item
    LB_SETCURSEL        = #186,     -- list box: set index of selected item
    LB_GETSELCOUNT      = #190,
    LB_GETSELITEMS      = #191,
    LB_SETTABSTOPS      = #192,
    LB_SELITEMRANGE     = #19B,
    LB_SETHORIZONTALEXTENT = 404,

    LB_OKAY             = 0,
    LB_ERR              = -1,
    LB_ERRSPACE         = -2,

    GW_HWNDFIRST        = 0,
    GW_HWNDLAST         = 1,
    GW_HWNDNEXT         = 2,
    GW_HWNDPREV         = 3,
    GW_OWNER            = 4,
    GW_CHILD            = 5,
    GW_ENABLEDPOPUP     = 6,

    CB_OKAY             = 0,
    CB_ERR              = -1,
    CB_ERRSPACE         = -2,
    CB_GETEDITSEL       = #140,
    CB_LIMITTEXT        = #141,
    CB_SETEDITSEL       = #142,
    CB_ADDSTRING        = #143,     -- combo box: add string
    CB_DELETESTRING     = #144,     -- combo box: delete string
    CB_DIR              = #145,
    CB_GETCOUNT         = #146,     -- combo box: get list count
    CB_GETCURSEL        = #147,     -- combo box: return index of current item
    CB_GETLBTEXT        = #148,     -- combo box: get text
    CB_GETLBTEXTLEN     = #149,     -- combo box: get text length
    CB_INSERTSTRING     = #14A,     -- combo box: insert string
    CB_RESETCONTENT     = #14B,     -- combo box: erase list
    CB_FINDSTRING       = #14C,
    CB_SELECTSTRING     = #14D,
    CB_SETCURSEL        = #14E,     -- combo box: set index
    CB_SHOWDROPDOWN     = #14F,     -- combo box: open/close the 'list' part
    CB_GETITEMDATA      = #150,
    CB_SETITEMDATA      = #151,
    CB_GETDROPPEDCONTROLRECT =  #152,
    CB_SETITEMHEIGHT    = #153,
    CB_GETITEMHEIGHT    = #154,
    CB_SETEXTENDEDUI    = #155,
    CB_GETEXTENDEDUI    = #156,
    CB_GETDROPPEDSTATE  = #157,
    CB_FINDSTRINGEXACT  = #158,
    CB_SETLOCALE        = #159,
    CB_GETLOCALE        = #15A,
    CB_GETTOPINDEX      = #15B,
    CB_SETTOPINDEX      = #15C,
    CB_GETHORIZONTALEXTENT = #15D,
    CB_SETHORIZONTALEXTENT = #15E,
    CB_GETDROPPEDWIDTH  = #15F,
    CB_SETDROPPEDWIDTH  = #160,
    CB_INITSTORAGE      = #161,
    CB_MULTIPLEADDSTRING = #163,


-- Button Control Messages
    BM_CLICK        = 245,
    BM_GETCHECK     = 240,
    BM_GETIMAGE     = 246,
    BM_GETSTATE     = 242,
    BM_SETCHECK     = 241,
    BM_SETIMAGE     = 247,
    BM_SETSTATE     = 243,
    BM_SETSTYLE     = 244,

    BST_UNCHECKED      = #0000,
    BST_CHECKED        = #0001,
    BST_INDETERMINATE  = #0002,
    BST_PUSHED         = #0004,
    BST_FOCUS          = #0008

global constant
    CF_BITMAP     =  2,
    CF_DIB =  8,
    CF_PALETTE    =  9,
    CF_ENHMETAFILE =  14,
    CF_METAFILEPICT = 3,
    CF_OEMTEXT      = 7,
    CF_TEXT = 1,
    CF_UNICODETEXT  = 13,
    CF_DIF  = 5,
    CF_DSPBITMAP    = 130,
    CF_DSPENHMETAFILE       = 142,
    CF_DSPMETAFILEPICT      = 131,
    CF_DSPTEXT      = 129,
    CF_GDIOBJFIRST  = 768,
    CF_GDIOBJLAST   = 1023,
    CF_HDROP        = 15,
    CF_LOCALE       = 16,
    CF_OWNERDISPLAY = 128,
    CF_PENDATA      = 10,
    CF_PRIVATEFIRST = 512,
    CF_PRIVATELAST  = 767,
    CF_RIFF = 11,
    CF_SYLK = 4,
    CF_WAVE = 12,
    CF_TIFF = 6

global constant
    -- Trackbar Styles
    TBS_HORZ            = 0,
    TBS_VERT            = 2,
    TBS_AUTOTICKS       = 1,
    TBS_NOTICKS         = 16,
    TBS_TOP             = 4,
    TBS_BOTTOM          = 0,
    TBS_LEFT            = 4,
    TBS_RIGHT           = 0,
    TBS_BOTH            = 8,
    TBS_ENABLESELRANGE  = 32,
    TBS_FIXEDLENGTH     = 64,
    TBS_NOTHUMB         = 128,
    TB_BOTTOM           = 7,
    TB_ENDTRACK         = 8,
    TB_LINEDOWN         = 1,
    TB_LINEUP           = 0,
    TB_PAGEDOWN         = 3,
    TB_PAGEUP           = 2,
    TB_THUMBPOSITION    = 4,
    TB_THUMBTRACK       = 5,
    TB_TOP              = 6,
-- Track bar control
    TBM_CLEARSEL        = 1043,
    TBM_CLEARTICS       = 1033,
    TBM_GETCHANNELRECT  = 1050,
    TBM_GETLINESIZE     = 1048,
    TBM_GETNUMTICS      = 1040,
    TBM_GETPAGESIZE     = 1046,
    TBM_GETPOS          = 1024,
    TBM_GETPTICS        = 1038,
    TBM_GETRANGEMAX     = 1026,
    TBM_GETRANGEMIN     = 1025,
    TBM_GETSELEND       = 1042,
    TBM_GETSELSTART     = 1041,
    TBM_GETTHUMBLENGTH  = 1052,
    TBM_GETTHUMBRECT    = 1049,
    TBM_GETTIC          = 1027,
    TBM_GETTICPOS       = 1039,
    TBM_SETLINESIZE     = 1047,
    TBM_SETPAGESIZE     = 1045,
    TBM_SETPOS          = 1029,
    TBM_SETRANGE        = 1030,
    TBM_SETRANGEMAX     = 1032,
    TBM_SETRANGEMIN     = 1031,
    TBM_SETSEL          = 1034,
    TBM_SETSELEND       = 1036,
    TBM_SETSELSTART     = 1035,
    TBM_SETTHUMBLENGTH  = 1051,
    TBM_SETTIC          = 1028,
    TBM_SETTICFREQ      = 1044,

-- Tab control
    TCM_ADJUSTRECT      = 4904,
    TCM_DELETEALLITEMS  = 4873,
    TCM_DELETEITEM      = 4872,
    TCM_GETCURFOCUS     = 4911,
    TCM_GETCURSEL       = 4875,
    TCM_GETIMAGELIST    = 4866,
    TCM_GETITEMW        = 4924,
    TCM_INSERTITEMW     = 4926,
    TCM_SETITEMW        = 4925,
    TCM_GETITEMA        = 4869,
    TCM_INSERTITEMA     = 4871,
    TCM_SETITEMA        = 4870,
    TCM_GETITEM         = TCM_GETITEMA,
    TCM_INSERTITEM      = TCM_INSERTITEMA,
    TCM_SETITEM         = TCM_SETITEMA,
    TCM_GETITEMCOUNT    = 4868,
    TCM_GETITEMRECT     = 4874,
    TCM_GETROWCOUNT     = 4908,
    TCM_GETTOOLTIPS     = 4909,
    TCM_HITTEST         = 4877,
    TCM_REMOVEIMAGE     = 4906,
    TCM_SETCURFOCUS     = 4912,
    TCM_SETCURSEL       = 4876,
    TCM_SETIMAGELIST    = 4867,
    TCM_SETITEMEXTRA    = 4878,
    TCM_SETITEMSIZE     = 4905,
    TCM_SETPADDING      = 4907,
    TCM_SETTOOLTIPS     = 4910,

    -- Tab control notifications
    TCN_KEYDOWN         = -550,
    TCN_SELCHANGE       = -551,
    TCN_SELCHANGING     = -552,


    -- TC_ITEM structure
    TCIF_TEXT           = 1,            -- display text on tabs
    TCIF_IMAGE          = 2,            -- display images on tabs
    TCIF_PARAM          = 8,
    TCIF_RTLREADING     = 4,

    -- progress bar styles
    PBS_SMOOTH          = 1,
    PBS_VERTICAL        = 4,
    -- progress bar messages
    PBM_SETRANGE    = WM_USER + 1,      -- set min/max
    PBM_SETPOS      = WM_USER + 2,      -- set position
    PBM_DELTAPOS    = WM_USER + 3,      -- change by requested increment
    PBM_SETSTEP     = WM_USER + 4,      -- set step size
    PBM_STEPIT      = WM_USER + 5,      -- step ahead by 1 step
    PBM_SETRANGE32  = WM_USER + 6,      -- range is double length word
    PBM_GETRANGE    = WM_USER + 7,      -- get range
    PBM_GETPOS      = WM_USER + 8,      -- get position

    -- key commands
    WM_KEYDOWN      = #100,         -- key pressed
    WM_KEYUP        = #101,
    WM_CHAR         = #102,

    -- system key commands
    WM_SYSCHAR      = 262,
    WM_SYSDEADCHAR  = 263,
    WM_SYSKEYDOWN   = 260,
    WM_SYSKEYUP     = 261,



    GWL_WndProc     = -4,           -- GetWindowLong: ptr to function

-- Menu flags for Add/Check/EnableMenuItem()
    MF_INSERT = #0,
    MF_CHANGE = #80,
    MF_APPEND = #100,
    MF_DELETE = #200,
    MF_REMOVE = #1000,

    MF_BYCOMMAND = #0,              -- specifies parameter type
    MF_BYPOSITION = #400,           -- specifies parameter type

    MF_SEPARATOR = #800,            -- menu format: seperator

    MF_ENABLED = #0,                -- menu format: enabled
    MF_GRAYED = #1,                 -- menu format: grayed
    MF_DISABLED = #2,               -- menu format: disabled

    MF_UNCHECKED = #0,              -- menu format: unchecked
    MF_CHECKED = #8,                -- menu format: checked
    MF_USECHECKBITMAPS = #200,      -- menu format: use check bitmaps

    MF_STRING = #0,                 -- menu format: display string
    MF_BITMAP = #4,                 -- menu format: display bitmap
    MF_OWNERDRAW = #100,            -- menu format: owner drawn

    MF_POPUP = #10,                 -- menu format: popup style
    MF_MENUBARBREAK = #20,          -- menu format: menu bar break style
    MF_MENUBREAK = #40,             -- menu format: menu break style

    MF_UNHILITE = #0,
    MF_HILITE = #80,

    MF_SYSMENU = #2000,
    MF_HELP = #4000,
    MF_MOUSESELECT = #8000,
    MF_DEFAULT     =   #00001000,

    MF_RIGHTJUSTIFY =  #00004000,

    MFS_GRAYED      =   #00000003,
    MFS_DISABLED    =   MFS_GRAYED,
    MFS_CHECKED     =   MF_CHECKED,
    MFS_HILITE      =   MF_HILITE,
    MFS_ENABLED     =   MF_ENABLED,
    MFS_UNCHECKED   =   MF_UNCHECKED,
    MFS_UNHILITE    =   MF_UNHILITE,
    MFS_DEFAULT     =   MF_DEFAULT,

    MFT_STRING        = MF_STRING,
    MFT_BITMAP        = MF_BITMAP,
    MFT_MENUBARBREAK  = MF_MENUBARBREAK,
    MFT_MENUBREAK     = MF_MENUBREAK,
    MFT_OWNERDRAW     = MF_OWNERDRAW,
    MFT_RADIOCHECK    = #00000200,
    MFT_SEPARATOR     = MF_SEPARATOR,
    MFT_RIGHTORDER    = #00002000,
    MFT_RIGHTJUSTIFY  = MF_RIGHTJUSTIFY,

    -- NOTIFICATIONS (events)

    -- Button Control Notification Codes
    BN_CLICKED          = 0,
    BN_DBLCLK           = 5,
    BN_DISABLE          = 4,
    BN_DOUBLECLICKED    = 5,
    BN_HILITE           = 2,
    BN_KILLFOCUS        = 7,
    BN_PAINT            = 1,
    BN_PUSHED           = 2,
    BN_SETFOCUS         = 6,
    BN_UNHILITE         = 3,
    BN_UNPUSHED         = 3,

    -- Edit Control Notification Codes
    EN_SETFOCUS     = #100,         -- get focus
    EN_KILLFOCUS    = #200,         -- lose focus
    EN_CHANGE       = #300,         -- change
    EN_UPDATE       = #400,         -- update
    EN_ERRSPACE     = #500,         -- out of memory
    EN_MAXTEXT      = #501,         -- more than allotted text
    EN_HSCROLL      = #601,         -- horizontal scroll
    EN_VSCROLL      = #602,         -- vertical scroll

    -- RichEdit mask flags
    ENM_CHANGE = 1,

	-- List Box Control Notification Codes
    LBN_ERRSPACE    = -2,     -- out of space
    LBN_SELCHANGE   = 1,        -- change selection
    LBN_DBLCLK      = 2,        -- double click
    LBN_SELCANCEL   = 3,        -- cancel selection
    LBN_SETFOCUS    = 4,        -- focus
    LBN_KILLFOCUS   = 5,        -- lose focus

    -- Combo Box Control Notification Codes
    CBN_ERRSPACE        = -1, -- out of space
    CBN_SELCHANGE       = 1,    -- change selection
    CBN_DBLCLK          = 2,    -- double click
    CBN_SETFOCUS        = 3,    -- set focus
    CBN_KILLFOCUS       = 4,    -- lose focus
    CBN_EDITCHANGE      = 5,    -- change data
    CBN_EDITUPDATE      = 6,    -- update data
    CBN_DROPDOWN        = 7,    -- dropdown
    CBN_CLOSEUP         = 8,    -- close dropdown
    CBN_SELENDOK        = 9,
    CBN_SELENDCANCEL    = 10,

    CBS_AUTOHSCROLL         = 64,
    CBS_DISABLENOSCROLL     = #800,
    CBS_DROPDOWN            = 2,
    CBS_DROPDOWNLIST        = 3,
    CBS_HASSTRINGS          = 512,
    CBS_LOWERCASE           = #4000,
    CBS_NOINTEGRALHEIGHT    = #400,
    CBS_OEMCONVERT          = 128,
    CBS_OWNERDRAWFIXED      = 16,
    CBS_OWNERDRAWVARIABLE   = 32,
    CBS_SIMPLE              = 1,
    CBS_SORT                = 256,
    CBS_UPPERCASE           = #2000,



    WM_COMMAND      = #0111,        -- window message command
    WM_MENUSELECT   = #011F,        -- menu item selected


    -- edit commands
    WM_CUT = #300,
    WM_COPY = #301,
    WM_PASTE = #302,
    WM_CLEAR = #303,
    WM_UNDO = #304,

    -- Edit Control Messages
    EM_GETSEL = #B0,        -- 2 long pointers
    EM_SETSEL = #B1,        -- pass start and end
--    EM_GETRECT = #B2,
--    EM_SETRECT = #B3,
--    EM_SETRECTNP = #B4,
    EM_SCROLL = #B5,
    EM_LINESCROLL = #B6,
    EM_SCROLLCARET = #B7,
    EM_GETMODIFY = #B8,
    EM_SETMODIFY = #B9,
    EM_GETLINECOUNT = #BA,
    EM_LINEINDEX = #BB,
    EM_SETHANDLE = #BC,
    EM_GETHANDLE = #BD,
    EM_GETTHUMB = #BE,
    EM_LINELENGTH = #C1,
    EM_REPLACESEL = #C2,
    EM_GETLINE = #C4,
    EM_LIMITTEXT = #C5,
    EM_CANUNDO = #C6,
    EM_UNDO = #C7,
    EM_FMTLINES = #C8,
    EM_LINEFROMCHAR = #C9,
    EM_SETTABSTOPS = #CB,
    EM_SETPASSWORDCHAR = #CC,
    EM_EMPTYUNDOBUFFER = #CD,
    EM_GETFIRSTVISIBLELINE = #CE,
    EM_SETREADONLY = #CF,
    EM_SETWORDBREAKPROC = #D0,
    EM_GETWORDBREAKPROC = #D1,
    EM_GETPASSWORDCHAR = #D2,
    EM_CHARFROMPOS     = #D7,
    EM_POSFROMCHAR     = #D8,

    EM_GETCHARFORMAT = 1082,
    EM_GETEVENTMASK = #043B,
	EM_GETSELTEXT = 1086,
    EM_SETCHARFORMAT = 1092,
    EM_SETEVENTMASK = #0445,
    EM_SETTARGETDEVICE = 1096,
    EM_SETTEXTMODE = 1113,
    EM_GETTEXTMODE = 1114,
    EM_GETTEXTEX  = WM_USER + 94,
    EM_GETTEXTLENGTHEX =        WM_USER + 95,

    TM_PLAINTEXT                        = 1,
    TM_RICHTEXT                                = 2,
    TM_SINGLELEVELUNDO                = 4,
    TM_MULTILEVELUNDO                = 8,
    TM_SINGLECODEPAGE                = 16,
    TM_MULTICODEPAGE                = 32,

    SCF_WORD = 2,
    SCF_SELECTION = 1,
    SCF_ALL = 4,



-- Status Window
    SBT_OWNERDRAW           = #1000,
    SBT_NOBORDERS           = #0100,
    SBT_POPOUT              = #0200,
    SBT_RTLREADING          = #0400,
    SBT_TOOLTIPS            = #0800,

    SB_GETBORDERS           = 1031,
    SB_GETPARTS             = 1030,
    SB_GETRECT              = 1034,
    SB_GETTEXTW             = 1037,
    SB_GETTEXTLENGTHW       = 1036,
    SB_SETTEXTW             = 1035,
    SB_GETTEXTA             = 1026,
    SB_GETTEXTLENGTHA       = 1027,
    SB_SETTEXTA             = 1025,
    SB_GETTEXT              = SB_GETTEXTA,
    SB_GETTEXTLENGTH        = SB_GETTEXTLENGTHA,
    SB_SETTEXT              = SB_SETTEXTA,
    SB_SETMINHEIGHT         = 1032,
    SB_SETPARTS             = 1028,
    SB_SIMPLE               = 1033,
    SB_SETICON              = WM_USER + 15,
    SB_SETTIPTEXT           = WM_USER + 16,
    SB_SETBKCOLOR           = #2001,

    --  Graphics Modes (used by EZ_FONT)
    GM_ADVANCED = 2,

    -- Background Modes
    TRANSPARENT     = 1,        -- background is not touched
    OPAQUE          = 2,        -- background filled before drawing

    --  xform stuff
    MWT_IDENTITY    = 1,
    CW_USEDEFAULT   = #80000000,

    -- icons and pointers
    ICON_SMALL      = 0,
    ICON_BIG        = 1,

    IDC_ARROW       = 32512,
    IDC_IBEAM       = 32513,
    IDC_WAIT        = 32514,
    IDC_CROSS       = 32515,
    IDC_UPARROW     = 32516,
    IDC_ICON        = 32641,
    IDC_SIZENWSE    = 32642,
    IDC_SIZENESW    = 32643,
    IDC_SIZEWE      = 32644,
    IDC_SIZENS      = 32645,
    IDC_SIZEALL     = 32646,
    IDC_SIZE        = IDC_SIZEALL, -- 32640 is obsolete
    IDC_NO          = 32648,
    IDC_HAND        = 32649,
    IDC_APPSTARTING = 32650,
    IDC_HELP        = 32651,
    IDI_APPLICATION = 32512,
    IDI_ERROR       = 32513,
    IDI_HAND        = IDI_ERROR,
    IDI_QUESTION    = 32514,
    IDI_EXCLAMATION = 32515,
    IDI_WARNING     = IDI_EXCLAMATION,
    IDI_ASTERISK    = 32516,
    IDI_INFORMATION = IDI_ASTERISK,
    IDI_WINLOGO     = 32517,
    WinIcons        = {IDI_APPLICATION, IDI_ERROR, IDI_QUESTION,
                       IDI_WARNING, IDI_ASTERISK, IDI_WINLOGO},

    -- Win32Lib's versions
    ArrowPointer        = IDC_ARROW,
    IBeamPointer        = IDC_IBEAM,
    WaitPointer         = IDC_WAIT,
    CrossPointer        = IDC_CROSS,
    UpArrowPointer      = IDC_UPARROW,
    SizeNWSEPointer     = IDC_SIZENWSE,
    SizeNESWPointer     = IDC_SIZENESW,
    SizeWEPointer       = IDC_SIZEWE,
    SizeNSPointer       = IDC_SIZENS,
    SizeAllPointer      = IDC_SIZEALL,
    NoPointer           = IDC_NO,
    AppStartingPointer  = IDC_APPSTARTING,
    HelpPointer         = IDC_HELP,
    ApplicationIcon     = IDI_APPLICATION,
    HandIcon            = IDI_HAND,
    QuestionIcon        = IDI_QUESTION,
    ExclamationIcon     = IDI_EXCLAMATION,
    AsteriskIcon        = IDI_ASTERISK,
    WinLogoIcon         = IDI_WINLOGO,
    SizePointer         = IDC_SIZEALL,
    IconPointer         = IDC_ICON,
    HandPointer         = IDC_HAND

global constant
-- GetSystemMetrics
    SM_CYMIN            = 29,
    SM_CXMIN            = 28,
    SM_ARRANGE          = 56,
    SM_CLEANBOOT        = 67,
    -- The right value for SM_CEMETRICS for NT 3.5 is 75.  For Windows 95
   -- and NT 4.0, it is 76.  The meaning is undocumented, anyhow.
    SM_CMETRICS         = 76,
    SM_CMOUSEBUTTONS    = 43,
    SM_CXBORDER         = 5,
    SM_CYBORDER         = 6,
    SM_CXCURSOR         = 13,
    SM_CYCURSOR         = 14,
    SM_CXDLGFRAME       = 7,
    SM_CYDLGFRAME       = 8,
    SM_CXDOUBLECLK      = 36,
    SM_CYDOUBLECLK      = 37,
    SM_CXDRAG           = 68,
    SM_CYDRAG           = 69,
    SM_CXEDGE           = 45,
    SM_CYEDGE           = 46,
    SM_CXFIXEDFRAME     = 7,
    SM_CYFIXEDFRAME     = 8,
    SM_CXFRAME          = 32,
    SM_CYFRAME          = 33,
    SM_CXFULLSCREEN     = 16,
    SM_CYFULLSCREEN     = 17,
    SM_CXHSCROLL        = 21,
    SM_CYHSCROLL        = 3,
    SM_CXHTHUMB         = 10,
    SM_CXICON           = 11,
    SM_CYICON           = 12,
    SM_CXICONSPACING    = 38,
    SM_CYICONSPACING    = 39,
    SM_CXMAXIMIZED      = 61,
    SM_CYMAXIMIZED      = 62,
    SM_CXMAXTRACK       = 59,
    SM_CYMAXTRACK       = 60,
    SM_CXMENUCHECK      = 71,
    SM_CYMENUCHECK      = 72,
    SM_CXMENUSIZE       = 54,
    SM_CYMENUSIZE       = 55,
    SM_CXMINIMIZED      = 57,
    SM_CYMINIMIZED      = 58,
    SM_CXMINSPACING     = 47,
    SM_CYMINSPACING     = 48,
    SM_CXMINTRACK       = 34,
    SM_CYMINTRACK       = 35,
    SM_CXSCREEN         = 0,
    SM_CYSCREEN         = 1,
    SM_CXSIZE           = 30,
    SM_CYSIZE           = 31,
    SM_CXSIZEFRAME      = 32,
    SM_CYSIZEFRAME      = 33,
    SM_CXSMICON         = 49,
    SM_CYSMICON         = 50,
    SM_CXSMSIZE         = 52,
    SM_CYSMSIZE         = 53,
    SM_CXVSCROLL        = 2,
    SM_CYVSCROLL        = 20,
    SM_CYVTHUMB         = 9,
    SM_CYCAPTION        = 4,
    SM_CYKANJIWINDOW    = 18,
    SM_CYMENU           = 15,
    SM_CYSMCAPTION      = 51,
    SM_DBCSENABLED      = 42,
    SM_DEBUG            = 22,
    SM_MENUDROPALIGNMENT= 40,
    SM_MIDEASTENABLED   = 74,
    SM_MOUSEPRESENT     = 19,
    SM_MOUSEWHEELPRESENT= 75,
    SM_NETWORK          = 63,
    SM_PENWINDOWS       = 41,
    SM_RESERVED1        = 24,
    SM_RESERVED2        = 25,
    SM_RESERVED3        = 26,
    SM_RESERVED4        = 27,
    SM_SECURE           = 44,
    SM_SHOWSOUNDS       = 70,
    SM_SLOWMACHINE      = 73,
    SM_SWAPBUTTON       = 23,
    ARW_BOTTOMLEFT      = 0,
    ARW_BOTTOMRIGHT     = #1,
    ARW_HIDE            = #8,
    ARW_TOPLEFT         = #2,
    ARW_TOPRIGHT        = #3,
    ARW_DOWN            = #4,
    ARW_LEFT            = 0,
    ARW_RIGHT           = 0,
    ARW_UP              = #4,


--  Scroll bar messages
    SBM_SETPOS = #E0, -- not in win3.1
    SBM_GETPOS = #E1, -- not in win3.1
    SBM_SETRANGE = #E2, -- not in win3.1
    SBM_SETRANGEREDRAW = #E6, -- not in win3.1
    SBM_GETRANGE = #E3, -- not in win3.1
    SBM_ENABLE_ARROWS = #E4, -- not in win3.1

-- Scroll Bar Styles
    SBS_HORZ = #0,
    SBS_VERT = #1,
    SBS_TOPALIGN = #2,
    SBS_LEFTALIGN = #2,
    SBS_BOTTOMALIGN = #4,
    SBS_RIGHTALIGN = #4,
    SBS_SIZEBOXTOPLEFTALIGN = #2,
    SBS_SIZEBOXBOTTOMRIGHTALIGN = #4,
    SBS_SIZEBOX = #8,

    -- scroll bar events
    WM_HSCROLL = #114,
    WM_VSCROLL = #115,

-- Scroll Bar Constants
    SB_HORZ = 0,
    SB_VERT = 1,
    SB_CTL = 2,
    SB_BOTH = 3,

-- Scroll Bar Commands
    SB_UserDefined = -1,
    SB_LINEUP = 0,
    SB_LINELEFT = 0,
    SB_LINEDOWN = 1,
    SB_LINERIGHT = 1,
    SB_PAGEUP = 2,
    SB_PAGELEFT = 2,
    SB_PAGEDOWN = 3,
    SB_PAGERIGHT = 3,
    SB_THUMBPOSITION = 4,
    SB_THUMBTRACK = 5,
    SB_TOP = 6,
    SB_LEFT = 6,
    SB_BOTTOM = 7,
    SB_RIGHT = 7,
    SB_ENDSCROLL = 8,

-- scroll bar information flags
    SIF_DISABLENOSCROLL = #8,
    SIF_PAGE = #2,
    SIF_POS = #4,
    SIF_RANGE = #1,
    SIF_TRACKPOS = #10,
    SIF_ALL = w32or_all({SIF_RANGE,SIF_PAGE,SIF_POS,SIF_TRACKPOS}),

-- Color hooks - control about to be drawn
    WM_CTLCOLORMSGBOX = #132,
    WM_CTLCOLOREDIT = #133,
    WM_CTLCOLORLISTBOX = #134,
    WM_CTLCOLORBTN = #135,
    WM_CTLCOLORDLG = #136,
    WM_CTLCOLORSCROLLBAR = #137,
    WM_CTLCOLORSTATIC = #138,


-- MessageBox() Flags
--  these are found in Euphoria's MESSAGE.E file
--    MB_OK = #0,
--    MB_OKCANCEL = #1,
--    MB_ABORTRETRYIGNORE = #2,
--    MB_YESNOCANCEL = #3,
--    MB_YESNO = #4,
--    MB_RETRYCANCEL = #5,
--    MB_ICONHAND = #10,
--    MB_ICONQUESTION = #20,
--    MB_ICONEXCLAMATION = #30,
--    MB_ICONASTERISK = #40,
--    MB_ICONINFORMATION = MB_ICONASTERISK,
--    MB_ICONSTOP = MB_ICONHAND,
--    MB_DEFBUTTON1 = #0,
--    MB_DEFBUTTON2 = #100,
--    MB_DEFBUTTON3 = #200,
--    MB_APPLMODAL = #0,
--    MB_SYSTEMMODAL = #1000,
--    MB_TASKMODAL = #2000,

-- timer
    WM_TIMER = #113,

--  Ternary raster operations
    SRCCOPY = #CC0020, -- (DWORD) dest = source
    SRCPAINT = #EE0086,        -- (DWORD) dest = source OR dest
    SRCAND = #8800C6,  -- (DWORD) dest = source AND dest
    SRCINVERT = #660046,       -- (DWORD) dest = source XOR dest
    SRCERASE = #440328,        -- (DWORD) dest = source AND (NOT dest )
    NOTSRCCOPY = #330008,      -- (DWORD) dest = (NOT source)
    NOTSRCERASE = #1100A6,     -- (DWORD) dest = (NOT src) AND (NOT dest)
    MERGECOPY = #C000CA,       -- (DWORD) dest = (source AND pattern)
    MERGEPAINT = #BB0226,      -- (DWORD) dest = (NOT source) OR dest
    PATCOPY = #F00021, -- (DWORD) dest = pattern
    PATPAINT = #FB0A09,        -- (DWORD) dest = DPSnoo
    PATINVERT = #5A0049,       -- (DWORD) dest = pattern XOR dest
    DSTINVERT = #550009,       -- (DWORD) dest = (NOT dest)
    BLACKNESS = #42, -- (DWORD) dest = BLACK
    WHITENESS = #FF0062,       -- (DWORD) dest = WHITE

--  Ternary raster operations
    SrcCopy     = SRCCOPY,
    SrcPaint    = SRCPAINT,
    SrcAnd      = SRCAND,
    SrcInvert   = SRCINVERT,
    SrcErase    = SRCERASE,
    NotSrcCopy  = NOTSRCCOPY,
    NotSrcErase = NOTSRCERASE,
    MergeCopy   = MERGECOPY,
    MergePaint  = MERGEPAINT,
    PatCopy     = PATCOPY,
    PatPaint    = PATPAINT,
    PatInvert   = PATINVERT,
    DstInvert   = DSTINVERT,
    Blackness   = BLACKNESS,
    Whiteness   = WHITENESS,

-- Binary raster ops
    R2_BLACK = 1,           -- Pixel is always 0.
    R2_NOTMERGEPEN = 2,     -- Pixel is the inverse of the R2_MERGEPEN color.
    R2_MASKNOTPEN = 3,      -- combination common screen and inverse of pen.
    R2_NOTCOPYPEN = 4,      -- Pixel is the inverse of the pen color.
    R2_MASKPENNOT = 5,      -- combination common to pen and inverse of screen.
    R2_NOT = 6,             -- Pixel is the inverse of the screen color.
    R2_XORPEN = 7,          -- Pixel is the inverse of the R2_XORPEN color.
    R2_NOTMASKPEN = 8,      -- Pixel is the inverse of the R2_MASKPEN color.
    R2_MASKPEN = 9,         -- combination common to pen and the screen.
    R2_NOTXORPEN = 10,      -- combination of colors in pen and screen, but not in both.
    R2_NOP = 11,            -- Pixel remains unchanged.
    R2_MERGENOTPEN = 12,    -- combination of screen and inverse of pen.
    R2_COPYPEN = 13,        -- Pixel is the pen color.
    R2_MERGEPENNOT = 14,    -- combination of pen color and inverse of screen color.
    R2_MERGEPEN = 15,       -- combination of pen color and the screen color.
    R2_WHITE = 16,          -- Pixel is always 1.
    R2_LAST = 16,


    GDI_ERROR = #FFFF,
    HGDI_ERROR = #FFFF,

-- error with color
    CLR_INVALID = #0000FFFF,
    CLR_DEFAULT = #FF000000,
    CLR_NONE    = #FFFFFFFF,


-- Global Memory Flags
    GMEM_FIXED = #0,
    GMEM_MOVEABLE = #2,
    GMEM_NOCOMPACT = #10,
    GMEM_NODISCARD = #20,
    GMEM_ZEROINIT = #40,
    GMEM_MODIFY = #80,
    GMEM_DISCARDABLE = #100,
    GMEM_NOT_BANKED = #1000,
    GMEM_SHARE = #2000,
    GMEM_DDESHARE = #2000,
    GMEM_NOTIFY = #4000,
    GMEM_LOWER = GMEM_NOT_BANKED,
    GMEM_VALID_FLAGS = #7F72,
    GMEM_INVALID_HANDLE = #8000,
    GMEM_CLIPBOARD = w32or_all({GMEM_MOVEABLE,GMEM_DDESHARE}),

    GHND = w32or_all({GMEM_MOVEABLE, GMEM_ZEROINIT}),
    GPTR = w32or_all({GMEM_FIXED, GMEM_ZEROINIT}),


-- PRINTDLG structure
    PD_ALLPAGES                     = 0,
    PD_COLLATE                      = 16,
    PD_DISABLEPRINTTOFILE           = 524288,
    PD_ENABLEPRINTHOOK              = 4096,
    PD_ENABLEPRINTTEMPLATE          = 16384,
    PD_ENABLEPRINTTEMPLATEHANDLE    = 65536,
    PD_ENABLESETUPHOOK              = 8192,
    PD_ENABLESETUPTEMPLATE          = 32768,
    PD_ENABLESETUPTEMPLATEHANDLE    = 131072,
    PD_HIDEPRINTTOFILE              = 1048576,
    PD_NOPAGENUMS                   = 8,
    PD_NOSELECTION                  = 4,
    PD_NOWARNING                    = 128,
    PD_PAGENUMS                     = 2,
    PD_PRINTSETUP                   = 64,
    PD_PRINTTOFILE                  = 32,
    PD_RETURNDC                     = 256,
    PD_RETURNDEFAULT                = 1024,
    PD_RETURNIC                     = 512,
    PD_SELECTION                    = 1,
    PD_SHOWHELP                     = 2048,
    PD_USEDEVMODECOPIES             = 262144,
    PD_USEDEVMODECOPIESANDCOLLATE   = 262144,


-- DIB color table identifiers
    DIB_RGB_COLORS = 0,         --  color table in RGBs
    DIB_PAL_COLORS = 1,         --  color table in palette indices
    DIB_PAL_INDICES = 2,        --  No color table indices into surf palette
    DIB_PAL_PHYSINDICES = 2,    --  No color table indices into surf palette
    DIB_PAL_LOGINDICES = 4,     --  No color table indices into DC palette


-- Loading Bitmaps
    LR_LOADFROMFILE = 16,
    IMAGE_BITMAP = 0,
    IMAGE_ICON = 1,

    LR_COPYDELETEORG = 8,
    LR_COPYRETURNORG = 4,
    LR_MONOCHROME = 1,
    LR_CREATEDIBSECTION = 8192,
    LR_DEFAULTSIZE = 64,

    SS_LEFT             = #00000000,
    SS_CENTER           = #00000001,
    SS_RIGHT            = #00000002,
    SS_ICON             = #00000003,
    SS_BLACKRECT        = #00000004,
    SS_GRAYRECT         = #00000005,
    SS_WHITERECT        = #00000006,
    SS_BLACKFRAME       = #00000007,
    SS_GRAYFRAME        = #00000008,
    SS_WHITEFRAME       = #00000009,
    SS_USERITEM         = #0000000A,
    SS_SIMPLE           = #0000000B,
    SS_LEFTNOWORDWRAP   = #0000000C,
    SS_OWNERDRAW        = #0000000D,
    SS_BITMAP           = #0000000E,
    SS_ENHMETAFILE      = #0000000F,
    SS_ETCHEDHORZ       = #00000010,
    SS_ETCHEDVERT       = #00000011,
    SS_ETCHEDFRAME      = #00000012,
    SS_TYPEMASK         = #0000001F,
    SS_NOPREFIX         = #00000080,
    SS_NOTIFY           = #00000100,
    SS_CENTERIMAGE      = #00000200,
    SS_RIGHTJUST        = #00000400,
    SS_REALSIZEIMAGE    = #00000800,
    SS_SUNKEN           = #00001000,
    SS_ENDELLIPSIS      = #00004000,
    SS_PATHELLIPSIS     = #00008000,
    SS_WORDELLIPSIS     = #0000C000,
    SS_ELLIPSISMASK     = #0000C000,



    STM_SETICON         = #0170,
    STM_GETICON         = #0171,
    STM_SETIMAGE        = #0172,
    STM_GETIMAGE        = #0173,

    STN_CLICKED         = 0,
    STN_DBLCLK          = 1,
    STN_ENABLE          = 2,
    STN_DISABLE         = 3,


-- Class field offsets for GetClassLong() and GetClassWord()
    GCL_MENUNAME = (-8),
    GCL_HBRBACKGROUND = (-10),      -- background brush
    GCL_HCURSOR = (-12),
    GCL_HICON = (-14),
    GCL_HMODULE = (-16),
    GCL_CBWNDEXTRA = (-18),
    GCL_CBCLSEXTRA = (-20),
    GCL_WNDPROC = (-24),
    GCL_STYLE = (-26),
    GCW_ATOM = (-32),

-- System Colors
    COLOR_SCROLLBAR             = 0,
    COLOR_BACKGROUND            = 1,
    COLOR_DESKTOP               = COLOR_BACKGROUND,
    COLOR_ACTIVECAPTION         = 2,
    COLOR_INACTIVECAPTION       = 3,
    COLOR_MENU                  = 4,
    COLOR_WINDOW                = 5,
    COLOR_WINDOWFRAME           = 6,
    COLOR_MENUTEXT              = 7,
    COLOR_WINDOWTEXT            = 8,
    COLOR_CAPTIONTEXT           = 9,
    COLOR_ACTIVEBORDER          = 10,
    COLOR_INACTIVEBORDER        = 11,
    COLOR_APPWORKSPACE          = 12,
    COLOR_HIGHLIGHT             = 13,
    COLOR_HIGHLIGHTTEXT         = 14,
    COLOR_BTNFACE               = 15,
    COLOR_3DFACE                = COLOR_BTNFACE,
    COLOR_BTNSHADOW             = 16,
    COLOR_3DSHADOW              = COLOR_BTNSHADOW,
    COLOR_GRAYTEXT              = 17,
    COLOR_BTNTEXT               = 18,
    COLOR_INACTIVECAPTIONTEXT   = 19,
    COLOR_BTNHIGHLIGHT          = 20,
    COLOR_3DHILIGHT             = COLOR_BTNHIGHLIGHT,
    COLOR_3DDKSHADOW            = 21,
    COLOR_3DLIGHT               = 22,
    COLOR_INFOTEXT              = 23,
    COLOR_TOOLTIPTEXT           = COLOR_INFOTEXT,
    COLOR_INFOBK                = 24,
    COLOR_TOOLTIPBK             = COLOR_INFOBK,
    -- not used                 = 25,
    COLOR_HOTLIGHT              = 26,
    COLOR_GRADIENTACTIVECAPTION = 27,
    COLOR_GRADIENTINACTIVECAPTION = 28,
    COLOR_MENUHILIGHT           = 29,
    COLOR_MENUBAR               = 30


global constant
-- Key State Masks for Mouse Messages
    MK_LBUTTON = #01,   -- left button is pressed
    MK_RBUTTON = #02,   -- right button is pressed
    MK_SHIFT   = #04,   -- shift key is held down
    MK_CONTROL = #08,   -- control key is held down
    MK_MBUTTON = #10,   -- middle button is pressed

-- constants for CreateDIBitmap
    CBM_CREATEDIB = #2, -- create DIB bitmap
    CBM_INIT = #4,      --  initialize bitmap

    CC_ENABLEHOOK = 16,
    CC_ENABLETEMPLATE = 32,
    CC_ENABLETEMPLATEHANDLE = 64,
    CC_FULLOPEN = 2,
    CC_PREVENTFULLOPEN = 4,
    CC_RGBINIT = 1,
    CC_SHOWHELP = 8,
    CC_SOLIDCOLOR = 128,

    CF_SCREENFONTS  = 1,            -- get screen fonts
    CF_PRINTERFONTS = 2,            -- get printer fonts
    CF_BOTH         = CF_SCREENFONTS + CF_PRINTERFONTS,
    CF_SHOWHELP     = 4,
    CF_ENABLEHOOK   = 8,
    CF_ENABLETEMPLATE = #10,
    CF_ENABLETEMPLATEHANDLE = #20,
    CF_INITTOLOGFONTSTRUCT = #40,
    CF_USESTYLE     = #80,
    CF_EFFECTS      = #100,
    CF_APPLY        = #200,
    CF_ANSIONLY     = #400,
    CF_SCRIPTSONLY  = CF_ANSIONLY,
    CF_NOVECTORFONTS = #800,
    CF_NOOEMFONTS   = CF_NOVECTORFONTS,
    CF_NOSIMULATIONS = #1000,
    CF_LIMITSIZE     = #2000,
    CF_FIXEDPITCHONLY = #4000,
    CF_WYSIWYG        = #8000, -- must also have CF_SCREENFONTS, CF_PRINTERFONTS and CF_SCALABLEONLY
    CF_FORCEFONTEXIST = #10000,
    CF_SCALABLEONLY   = #20000,
    CF_TTONLY       = #40000,
    CF_NOFACESEL    = #80000,
    CF_NOSTYLESEL   = #100000,
    CF_NOSIZESEL    = #200000,
    CF_SELECTSCRIPT = #400000,
    CF_NOSCRIPTSEL  = #800000,
    CF_NOVERTFONTS  = #1000000,


-- constants for onResize
    -- WM_SIZE message wParam values
    SIZE_RESTORED   = 0,
    SIZE_MINIMIZED  = 1,
    SIZE_MAXIMIZED  = 2,
    SIZE_MAXSHOW    = 3,
    SIZE_MAXHIDE    = 4,

    -- Obsolete constant names
    SIZENORMAL      = SIZE_RESTORED,
    SIZEICONIC      = SIZE_MINIMIZED,
    SIZEFULLSCREEN  = SIZE_MAXIMIZED,
    SIZEZOOMSHOW    = SIZE_MAXSHOW,
    SIZEZOOMHIDE    = SIZE_MAXHIDE


-----------------------------------------------------------------------------
-- Win32 Wrappers for mouse flags

global constant
-- Visual Basics Names for the buttons:
    LEFT_BUTTON     = MK_LBUTTON,
    RIGHT_BUTTON    = MK_RBUTTON,
    MIDDLE_BUTTON   = MK_MBUTTON,
    SHIFT_MASK      = MK_SHIFT,
    CTRL_MASK       = MK_CONTROL,

-- Win32Lib names for mouse events
    MOUSE_MOVE          = WM_MOUSEMOVE,
    LEFT_DOWN           = WM_LBUTTONDOWN,
    RIGHT_DOWN          = WM_RBUTTONDOWN,
    LEFT_UP             = WM_LBUTTONUP,
    RIGHT_UP            = WM_RBUTTONUP,
    LEFT_DOUBLECLICK    = WM_LBUTTONDBLCLK,
    RIGHT_DOUBLECLICK   = WM_RBUTTONDBLCLK,
    WHEEL_MOVE          = WM_MOUSEWHEEL,

    MouseMove           = MOUSE_MOVE,
    LeftDown            = LEFT_DOWN,
    RightDown           = RIGHT_DOWN,
    LeftUp              = LEFT_UP,
    RightUp             = RIGHT_UP,
    LeftDoubleClick     = LEFT_DOUBLECLICK,
    RightDoubleClick    = RIGHT_DOUBLECLICK,
    WheelMove           = WM_MOUSEWHEEL,


-----------------------------------------------------------------------------
-- Window field offsets for GetWindowLong() and GetWindowWord()
    GWL_WNDPROC         = -4,
    GWL_HINSTANCE       = -6,
    GWL_HWNDPARENT      = -8,
    GWL_STYLE           = -16,
    GWL_EXSTYLE         = -20,
    GWL_USERDATA        = -21,
    GWL_ID              = -12,

-----------------------------------------------------------------------------
    TA_TOP          = 0,
    TA_LEFT         = 0,
    TA_NOUPDATECP   = 0,
    TA_UPDATECP     = 1,
    TA_RIGHT        = 2,
    TA_CENTER       = 6,
    VTA_CENTER      = 6,
    TA_BOTTOM       = 8,
    TA_BASELINE     = 24,
    VTA_BASELINE    = 24,
    TA_RTLREADING   = 256,

    AlignTop        = TA_TOP,
    AlignBottom     = TA_BOTTOM,
    AlignBaseline   = TA_BASELINE,
    AlignCenter     = TA_CENTER,
    AlignLeft       = TA_LEFT,
    AlignRight      = TA_RIGHT,


    CCM_FIRST               = #2000,
    CCM_SETCOLORSCHEME      = (CCM_FIRST + 2),
    CCM_GETCOLORSCHEME      = (CCM_FIRST + 3),
    CCM_GETDROPTARGET       = (CCM_FIRST + 4),
    CCM_SETUNICODEFORMAT    = (CCM_FIRST + 5),
    CCM_GETUNICODEFORMAT    = (CCM_FIRST + 6),
    CCM_SETBKCOLOR          = (CCM_FIRST + 1),

    LVS_ICON                =  #0,
    LVS_REPORT              =  #1,
    LVS_SMALLICON           =  #2,
    LVS_LIST                =  #3,
    LVS_TYPEMASK            =  #3,
    LVS_SINGLESEL           =  #4,
    LVS_SHOWSELALWAYS       =  #8,
    LVS_SORTASCENDING       =  #10,
    LVS_SORTDESCENDING      =  #20,
    LVS_SHAREIMAGELISTS     =  #40,
    LVS_NOLABELWRAP         =  #80,
    LVS_AUTOARRANGE         =  #100,
    LVS_EDITLABELS          =  #200,
    LVS_OWNERDATA           =  #1000,
    LVS_NOSCROLL            =  #2000,
    LVS_TYPESTYLEMASK       =  #FC00,
    LVS_ALIGNTOP            =  #0,
    LVS_ALIGNLEFT           =  #800,
    LVS_ALIGNMASK           =  #C00,
    LVS_OWNERDRAWFIXED      =  #400,
    LVS_NOCOLUMNHEADER      =  #4000,
    LVS_NOSORTHEADER        =  #8000,

    LVA_DEFAULT             = 0,
    LVA_ALIGNLEFT           = 1,
    LVA_ALIGNTOP            = 2,
    LVA_SNAPTOGRID          = 5,

    LVS_EX_GRIDLINES        = 1,
    LVS_EX_SUBITEMIMAGES    = 2,
    LVS_EX_CHECKBOXES       = 4,
    LVS_EX_TRACKSELECT      = 8,
    LVS_EX_HEADERDRAGDROP   = #10,
    LVS_EX_FULLROWSELECT    = #20,
    LVS_EX_ONECLICKACTIVATE = #40,
    LVS_EX_TWOCLICKACTIVATE = #80,
    LVS_EX_FLATSB           = #100,
    LVS_EX_REGIONAL         = #200,
    LVS_EX_NFOTIP           = #400,
    LVS_EX_UNDERLINEHOT     = #800,
    LVS_EX_UNDERLINECOLD    = #1000,
    LVS_EX_MULTIWORKAREAS   = #2000,

    LVM_FIRST               =  #1000,
    LVM_GETBKCOLOR          =  (LVM_FIRST + 0),
    LVM_SETBKCOLOR          =  (LVM_FIRST + 1),
    LVM_GETIMAGELIST        =  (LVM_FIRST + 2),
    LVM_SETIMAGELIST        =  (LVM_FIRST + 3),
    LVM_GETITEMCOUNT        =  (LVM_FIRST + 4),
    LVM_GETITEMA            =  (LVM_FIRST + 5),
    LVM_GETITEM             =  LVM_GETITEMA,
    LVM_SETITEMA            =  (LVM_FIRST + 6),
    LVM_SETITEM             =  LVM_SETITEMA,
    LVM_INSERTITEMA         =  (LVM_FIRST + 7),
    LVM_INSERTITEM          =  LVM_INSERTITEMA,
    LVM_DELETEITEM          =  (LVM_FIRST + 8),
    LVM_DELETEALLITEMS      =  (LVM_FIRST + 9),
    LVM_GETCALLBACKMASK     =  (LVM_FIRST + 10),
    LVM_SETCALLBACKMASK     =  (LVM_FIRST + 11),
    LVM_GETNEXTITEM         =  (LVM_FIRST + 12),
    LVM_FINDITEM            =  (LVM_FIRST + 13),
    LVM_GETITEMRECT         =  (LVM_FIRST + 14),
    LVM_SETITEMPOSITION     =  (LVM_FIRST + 15),
    LVM_GETITEMPOSITION     =  (LVM_FIRST + 16),
    LVM_GETSTRINGWIDTH      =  (LVM_FIRST + 17),
    LVM_HITTEST             =  (LVM_FIRST + 18),
    LVM_ENSUREVISIBLE       =  (LVM_FIRST + 19),
    LVM_SCROLL              =  (LVM_FIRST + 20),
    LVM_REDRAWITEMS         =  (LVM_FIRST + 21),
    LVM_ARRANGE             =  (LVM_FIRST + 22),
    LVM_EDITLABEL           =  (LVM_FIRST + 23),
    LVM_GETEDITCONTROL      =  (LVM_FIRST + 24),
    LVM_GETCOLUMN           =  (LVM_FIRST + 25),
    LVM_INSERTCOLUMNA       =  (LVM_FIRST + 27),
    LVM_INSERTCOLUMN        =  LVM_INSERTCOLUMNA,
    LVM_DELETECOLUMN        =  (LVM_FIRST + 28),
    LVM_SETCOLUMN           =  4122,
    LVM_GETCOLUMNWIDTH      =  (LVM_FIRST + 29),
    LVM_SETCOLUMNWIDTH      =  (LVM_FIRST + 30),
    LVM_GETHEADER           =  (LVM_FIRST + 31),
    LVM_CREATEDRAGIMAGE     =  (LVM_FIRST + 33),
    LVM_GETVIEWRECT         =  (LVM_FIRST + 34),
    LVM_GETTEXTCOLOR        =  (LVM_FIRST + 35),
    LVM_SETTEXTCOLOR        =  (LVM_FIRST + 36),
    LVM_GETTEXTBKCOLOR      =  (LVM_FIRST + 37),
    LVM_SETTEXTBKCOLOR      =  (LVM_FIRST + 38),
    LVM_GETTOPINDEX         =  (LVM_FIRST + 39),
    LVM_GETCOUNTPERPAGE     =  (LVM_FIRST + 40),
    LVM_GETORIGIN           =  (LVM_FIRST + 41),
    LVM_UPDATE              =  (LVM_FIRST + 42),
    LVM_SETITEMSTATE        =  (LVM_FIRST + 43),
    LVM_GETITEMSTATE        =  (LVM_FIRST + 44),
    LVM_GETITEMTEXTA        =  (LVM_FIRST + 45),
    LVM_GETITEMTEXT         =  LVM_GETITEMTEXTA,
    LVM_SETITEMTEXTA        =  (LVM_FIRST + 46),
    LVM_SETITEMTEXT         =  LVM_SETITEMTEXTA,
    LVM_SETITEMCOUNT        =  (LVM_FIRST + 47),
    LVM_SORTITEMS           =  (LVM_FIRST + 48),
    LVM_SETITEMPOSITION32   =  (LVM_FIRST + 49),
    LVM_GETSELECTEDCOUNT    =  (LVM_FIRST + 50),
    LVM_GETITEMSPACING      =  (LVM_FIRST + 51),
    LVM_GETISEARCHSTRINGA   =  (LVM_FIRST + 52),
    LVM_GETISEARCHSTRING    =  LVM_GETISEARCHSTRINGA,
    LVM_SETICONSPACING      =  (LVM_FIRST + 53),
    LVM_SETEXTENDEDLISTVIEWSTYLE =  (LVM_FIRST + 54),
    LVM_GETEXTENDEDLISTVIEWSTYLE =  (LVM_FIRST + 55),
    LVM_GETSUBITEMRECT      =  (LVM_FIRST + 56),
    LVM_SUBITEMHITTEST      =  (LVM_FIRST + 57),
    LVM_SETCOLUMNORDERARRAY =  (LVM_FIRST + 58),
    LVM_GETCOLUMNORDERARRAY =  (LVM_FIRST + 59),
    LVM_SETHOTITEM          =  (LVM_FIRST + 60),
    LVM_GETHOTITEM          =  (LVM_FIRST + 61),
    LVM_SETHOTCURSOR        =  (LVM_FIRST + 62),
    LVM_GETHOTCURSOR        =  (LVM_FIRST + 63),
    LVM_APPROXIMATEVIEWRECT =  (LVM_FIRST + 64),
    LV_MAX_WORKAREAS        =  16,
    LVM_SETWORKAREAS        =  (LVM_FIRST + 65),
    LVM_GETSELECTIONMARK    =  (LVM_FIRST + 66),
    LVM_SETSELECTIONMARK    =  (LVM_FIRST + 67),
    LVM_SETBKIMAGE          =  (LVM_FIRST + 68),
    LVM_GETBKIMAGE          =  (LVM_FIRST + 69),
    LVM_GETWORKAREAS        =  (LVM_FIRST + 70),
    LVM_SETHOVERTIME        =  (LVM_FIRST + 71),
    LVM_GETHOVERTIME        =  (LVM_FIRST + 72),
    LVM_GETNUMBEROFWORKAREAS=  (LVM_FIRST + 73),
    LVM_SETTOOLTIPS         =  (LVM_FIRST + 74),
    LVM_GETTOOLTIPS         =  (LVM_FIRST + 78),

    LVSCW_AUTOSIZE              = -1,
    LVSCW_AUTOSIZE_USEHEADER    = -2,

    LVFINDINFO_flags        = w32allot( Long ),
    LVFINDINFO_psz          = w32allot( Lpsz ),
    LVFINDINFO_lParam       = w32allot( Long ),
    LVFINDINFO_ptX          = w32allot( Long ),
    LVFINDINFO_ptY          = w32allot( Long ),
    LVFINDINFO_vkDirection  = w32allot( Long ),
    SIZEOF_LVFINDINFO       = w32allotted_size(),
    ID_LVFINDINFO     = {{w32CurrentStructure()}},

    LVFI_PARAM              =  #1,
    LVFI_STRING             =  #2,
    LVFI_PARTIAL            =  #8,
    LVFI_WRAP               =  #20,
    LVFI_NEARESTXY          =  #40,

    LVNI_ALL                = 0,
    LVNI_FOCUSED            = 1,
    LVNI_SELECTED           = 2,
    LVNI_CUT                = 4,
    LVNI_DROPHILITED        = 8,

    LVNI_ABOVE              = #100,
    LVNI_BELOW              = #200,
    LVNI_TOLEFT             = #400,
    LVNI_TORIGHT            = #800,

    LVIF_TEXT               = 1,
    LVIF_IMAGE              = 2,
    LVIF_PARAM              = 4,
    LVIF_STATE              = 8,
    LVIF_INDENT             = #10,
    LVIF_NORECOMPUTE        = #800,
    LVIF_DI_SETITEM         = #1000,

    LVCFMT_LEFT              = 0,
    LVCFMT_RIGHT             = 1,
    LVCFMT_CENTER            = 2,
    LVCFMT_JUSTIFYMASK       = 3,

    LVCF_FMT                 = #1,
    LVCF_WIDTH               = #2,
    LVCF_TEXT                = #4,
    LVCF_SUBITEM             = #8,
    LVCF_IMAGE               = #10,
    LVCF_ORDER               = #20,

-- states
    LVIS_FOCUSED            = #0001,
    LVIS_SELECTED           = #0002,
    LVIS_CUT                = #0004,
    LVIS_DROPHILITED        = #0008,
    LVIS_ACTIVATING         = #0020,
    LVIS_OVERLAYMASK        = #0F00,
    LVIS_STATEIMAGEMASK     = #F000,
    LV_IS_CHECKED           = #2000,

    LVIR_BOUNDS             = 0,
    LVIR_ICON               = 1,
    LVIR_LABEL              = 2,
    LVIR_SELECTBOUNDS       = 3,

    LVHT_NOWHERE            = 1,
    LVHT_ONITEMICON         = 2,
    LVHT_ONITEMLABEL        = 4,
    LVHT_ONITEMSTATEICON    = 8,
    LVHT_ONITEM             = w32or_all({LVHT_ONITEMICON, LVHT_ONITEMLABEL,
	    	          LVHT_ONITEMSTATEICON}),

    LVHT_ABOVE              = 8,
    LVHT_BELOW              = #10,
    LVHT_TORIGHT            = #20,
    LVHT_TOLEFT             = #40,

    LVSIL_NORMAL            = 0,
    LVSIL_SMALL             = 1,
    LVSIL_STATE             = 2,

    LVN_BEGINDRAG = -109,
    LVN_BEGINRDRAG = -111,
    LVN_COLUMNCLICK = -108,
    LVN_DELETEALLITEMS = -104,
    LVN_DELETEITEM = -103,
    LVN_BEGINLABELEDITW = -175,
    LVN_ENDLABELEDITW = -176,
    LVN_GETDISPINFOW = -177,
    LVN_SETDISPINFOW = -178,
    LVN_BEGINLABELEDITA = -105,
    LVN_ENDLABELEDITA = -106,
    LVN_GETDISPINFOA = -150,
    LVN_SETDISPINFOA = -151,
    LVN_INSERTITEM = -102,
    LVN_ITEMCHANGED = -101,
    LVN_ITEMCHANGING = -100,
    LVN_KEYDOWN = -155,
    LVN_GETDISPINFO = -150,
    LVN_SETDISPINFO = -151,
    LVN_ITEMACTIVATE = -114,

    LVN_FIRST               = -100,
    LVN_LAST                = (LVN_FIRST + 99),

    HDM_GETITEMCOUNT        =  #1200,


-- ImageLists
    ILC_MASK                =1,
    ILC_COLOR               =0,
    ILC_COLORDDB            =#FE,
    ILC_COLOR4              =0,
    ILC_COLOR8              =8,
    ILC_COLOR16             =#10,
    ILC_COLOR24             =#18,
    ILC_COLOR32             =#20,

    LPSTR_TEXTCALLBACKA = (-1),
    LPSTR_TEXTCALLBACK  = (-1),

-- Treeview:
    TVS_HASBUTTONS           = 1,
    TVS_HASLINES            = 2,
    TVS_LINESATROOT         = 4,
    TVS_EDITLABELS          = 8,
    TVS_DISABLEDRAGDROP     = #10,
    TVS_SHOWSELALWAYS       = #20,
    TVS_RTLREADING          = #40,
    TVS_NOTOOLTIPS          = #80,
    TVS_CHECKBOXES          = #100,
    TVS_TRACKSELECT         = #200,
    TVS_SINGLEEXPAND        = #400,
    TVS_INFOTIP             = #800,
    TVS_FULLROWSELECT       = #1000,
    TVS_NOSCROLL            = #2000,
    TVS_NONEVENHEIGHT       = #4000,

    TVSIL_NORMAL            = 0,
    TVSIL_STATE             = 2,

    TVIF_TEXT               = 1,
    TVIF_IMAGE              = 2,
    TVIF_PARAM              = 4,
    TVIF_STATE              = 8,
    TVIF_HANDLE             = #10,
    TVIF_SELECTEDIMAGE      = #20,
    TVIF_CHILDREN           = #40,
    TVIF_INTEGRAL           = #80,

    TVIS_DESELECTED_MASK    = #1000,
    TVIS_SELECTED           = #0002,
    TVIS_SELECTED_MASK      = #2000,
    TVIS_CUT                = #0004,
    TVIS_CUT_MASK           = #4000,
    TVIS_DROPHILITED        = #0008,
    TVIS_DROPHILITED_MASK   = #8000,
    TVIS_BOLD               = #0010,
    TVIS_EXPANDED           = #0020,
    TVIS_EXPANDEDONCE       = #0040,
    TVIS_EXPANDPARTIAL      = #0080,
    TVIS_OVERLAYMASK        = #0F00,
    TVIS_STATEIMAGEMASK     = #F000,
    TVIS_USERMASK           = #F000,

    TVI_ROOT                = #FFFF0000,
    TVI_FIRST               = #FFFF0001,
    TVI_LAST                = #FFFF0002,
    TVI_SORT                = #FFFF0003,

    TV_FIRST                = #1100,
    TVM_INSERTITEMA         = (TV_FIRST + 0),
    TVM_INSERTITEM          = TVM_INSERTITEMA,
    TVM_DELETEITEM          = (TV_FIRST + 1),
    TVM_EXPAND              = (TV_FIRST + 2),
    TVM_GETITEMRECT         = (TV_FIRST + 4),
    TVM_GETCOUNT            = (TV_FIRST + 5),
    TVM_GETINDENT           = (TV_FIRST + 6),
    TVM_SETINDENT           = (TV_FIRST + 7),
    TVM_GETIMAGELIST        = (TV_FIRST + 8),
    TVM_SETIMAGELIST        = (TV_FIRST + 9),
    TVM_GETNEXTITEM         = (TV_FIRST + 10),
    TVM_SELECTITEM          = (TV_FIRST + 11),
    TVM_GETITEMA            = (TV_FIRST + 12),
    TVM_GETITEM             = TVM_GETITEMA,
    TVM_SETITEMA            = (TV_FIRST + 13),
    TVM_SETITEM             = TVM_SETITEMA,
    TVM_EDITLABELA          = (TV_FIRST + 14),
    TVM_EDITLABEL           = TVM_EDITLABELA,
    TVM_GETEDITCONTROL      = (TV_FIRST + 15),
    TVM_GETVISIBECOUNT      = (TV_FIRST + 16),
    TVM_HITTEST             = (TV_FIRST + 17),
    TVM_CREATEDRAGIMAGE     = (TV_FIRST + 18),
    TVM_SORTCHILDREN        = (TV_FIRST + 19),
    TVM_ENSUREVISIBLE       = (TV_FIRST + 20),
    TVM_SORTCHILDRENCB      = (TV_FIRST + 21),
    TVM_ENDEDITLABELNOW     = (TV_FIRST + 22),
    TVM_GETISEARCHSTRINGA   = (TV_FIRST + 23),
    TVM_GETISEARCHSTRING    = TVM_GETISEARCHSTRINGA,
    TVM_SETTOOLTIPS         = (TV_FIRST + 24),
    TVM_GETTOOLTIPS         = (TV_FIRST + 25),
    TVM_SETINSERTMARK       = (TV_FIRST + 26),
    TVM_SETITEMHEIGHT       = (TV_FIRST + 27),
    TVM_GETITEMHEIGHT       = (TV_FIRST + 28),
    TVM_SETBKCOLOR          = (TV_FIRST + 29),
    TVM_SETTEXTCOLOR        = (TV_FIRST + 30),
    TVM_GETBKCOLOR          = (TV_FIRST + 31),
    TVM_GETTEXTCOLOR        = (TV_FIRST + 32),
    TVM_SETSCROLLTIME       = (TV_FIRST + 33),
    TVM_GETSCROLLTIME       = (TV_FIRST + 34),
    TVM_SETINSERTMARKCOLOR  = (TV_FIRST + 37),
    TVM_GETINSERTMARKCOLOR  = (TV_FIRST + 38),


    TVGN_ROOT               = 0,
    TVGN_NEXT               = 1,
    TVGN_PREVIOUS           = 2,
    TVGN_PARENT             = 3,
    TVGN_CHILD              = 4,
    TVGN_FIRSTVISIBLE       = 5,
    TVGN_NEXTVISIBLE        = 6,
    TVGN_PREVIOUSVISIBLE    = 7,
    TVGN_DROPHILITE         = 8,
    TVGN_CARET              = 9,
    TVGN_LASTVISIBLE        = #A,

    TVE_COLLAPSE            = 1,
    TVE_EXPAND              = 2,
    TVE_TOGGLE              = 3,
    TVE_EXPANDPARTIAL       = #4000,
    TVE_COLLAPSERESET       = #8000,

    TVHT_NOWHERE            = 1,
    TVHT_ONITEMICON         = 2,
    TVHT_ONITEMLABEL        = 4,
    TVHT_ONITEMINDENT       = #8,
    TVHT_ONITEMBUTTON       = #10,
    TVHT_ONITEMRIGHT        = #20,
    TVHT_ONITEMSTATEICON    = #40,
    TVHT_ONITEM             = w32or_all( {TVHT_ONITEMICON, TVHT_ONITEMLABEL,
	    	        TVHT_ONITEMSTATEICON}),

    TVHT_ABOVE              = #100,
    TVHT_BELOW              = #200,
    TVHT_TORIGHT            = #400,
    TVHT_TOLEFT             = #800,

    TVN_KEYDOWN = -412,
    TVN_BEGINDRAGW = -456,
    TVN_BEGINLABELEDITW = -459,
    TVN_BEGINRDRAGW = -457,
    TVN_DELETEITEMW = -458,
    TVN_ENDLABELEDITW = -460,
    TVN_GETDISPINFOW = -452,
    TVN_ITEMEXPANDEDW = -455,
    TVN_ITEMEXPANDINGW = -454,
    TVN_SELCHANGEDW = -451,
    TVN_SELCHANGINGW = -450,
    TVN_SETDISPINFOW = -453,
    TVN_BEGINDRAG = -407,
    TVN_BEGINLABELEDIT = -410,
    TVN_BEGINRDRAG = -408,
    TVN_DELETEITEM = -409,
    TVN_ENDLABELEDIT = -411,
    TVN_GETDISPINFO = -403,
    TVN_ITEMEXPANDED = -406,
    TVN_ITEMEXPANDING = -405,
    TVN_SELCHANGED = -402,
    TVN_SELCHANGING = -401,
    TVN_SETDISPINFO = -404,
    onTVSelect  = TVN_SELCHANGEDW,
    CBEN_ENDEDIT = -805,


    MCM_FIRST           = #1000,
    MCM_GETCURSEL       = (MCM_FIRST + 1),
    MCM_SETCURSEL       = (MCM_FIRST + 2),
    MCM_GETMAXSELCOUNT  = (MCM_FIRST + 3),
    MCM_SETMAXSELCOUNT  = (MCM_FIRST + 4),
    MCM_GETSELRANGE     = (MCM_FIRST + 5),
    MCM_SETSELRANGE     = (MCM_FIRST + 6),
    MCM_GETMONTHRANGE   = (MCM_FIRST + 7),
    MCM_SETDAYSTATE     = (MCM_FIRST + 8),
    MCM_GETMINREQRECT   = (MCM_FIRST + 9),
    MCM_SETCOLOR        = (MCM_FIRST +10),
    MCM_GETCOLOR        = (MCM_FIRST + 11),
    MCM_SETTODAY        = (MCM_FIRST + 12),
    MCM_GETTODAY        = (MCM_FIRST + 13),
    MCM_HITTEST         = (MCM_FIRST + 14),
    MCM_SETFIRSTDAYOFWEEK = (MCM_FIRST + 15),
    MCM_GETFIRSTDAYOFWEEK = (MCM_FIRST + 16),
    MCM_GETRANGE        = (MCM_FIRST + 17),
    MCM_SETRANGE        = (MCM_FIRST+ 18),
    MCM_GETMONTHDELTA   = (MCM_FIRST + 19),
    MCM_SETMONTHDELTA   = (MCM_FIRST + 20),
    MCM_GETMAXTODAYWIDTH = (MCM_FIRST + 21),

    MCN_FIRST           = -750,
    MCN_LAST            = -759,
    MCN_SELCHANGE       = (MCN_FIRST + 1),
    MCN_GETDAYSTATE     = (MCN_FIRST + 3),
    MCN_SELECT          = (MCN_FIRST + 4),

    MCS_DAYSTATE        = #1,
    MCS_MULTISELECT     = #2,
    MCS_WEEKNUMBERS     = #4,
    MCS_NOTODAYCIRCLE   = #8,
    MCS_NOTODAY         = #10,

    GMR_VISIBLE     = 0,
    GMR_DAYSTATE    = 1,

    MCHT_TITLE                      = #10000,
    MCHT_CALENDAR                   = #20000,
    MCHT_TODAYLINK                  = #30000,
    MCHT_NEXT                       = #1000000,
    MCHT_PREV                       = #2000000,
    MCHT_NOWHERE                    = #0,
    MCHT_TITLEBK                    = (MCHT_TITLE),
    MCHT_TITLEMONTH                 = or_bits( MCHT_TITLE , 1),
    MCHT_TITLEYEAR                  = or_bits( MCHT_TITLE, 2),
    MCHT_TITLEBTNNEXT               = w32or_all({ MCHT_TITLE, MCHT_NEXT, 3}),
    MCHT_TITLEBTNPREV               = w32or_all({ MCHT_TITLE, MCHT_PREV,  0}),
    MCHT_CALENDARBK                 = (MCHT_CALENDAR),
    MCHT_CALENDARDATE                = or_bits( MCHT_CALENDAR , 1),
    MCHT_CALENDARDATENEXT           = or_bits( MCHT_CALENDARDATE, MCHT_NEXT ),
    MCHT_CALENDARDATEPREV           = or_bits( MCHT_CALENDARDATE ,MCHT_PREV ),
    MCHT_CALENDARDAY                = or_bits( MCHT_CALENDAR , 2 ),
    MCHT_CALENDARWEEKNuM            = or_bits( MCHT_CALENDAR , 3),

    MCSC_BACKGROUND   = 0,
    MCSC_TEXT         = 1,
    MCSC_TITLEBK      = 2,
    MCSC_TITLETEXT    = 3,
    MCSC_MONTHBK      = 4,
    MCSC_TRAILINGTEXT = 5,

    ShortMonths                     = 1,
    LongMonths                      = 2,
    Months                          = {
	    	        {
	    	    	"Jan",
	    	    	"Feb",
	    	    	"Mar",
	    	    	"Apr",
	    	    	"May",
	    	    	"Jun",
	    	    	"Jul",
	    	    	"Aug",
	    	    	"Sep",
	    	    	"Oct",
	    	    	"Nov",
	    	    	"Dec"
	    	        },
	    	          {
	    	    	"January",
	    	    	"February",
	    	    	"March",
	    	    	"April",
	    	    	"May",
	    	    	"June",
	    	    	"July",
	    	    	"August",
	    	    	"September",
	    	    	"October",
	    	    	"November",
	    	    	"December"
	    	        }},
    Days        = { "Sunday",
	    	    	"Monday",
	    	    	"Tuesday",
	    	    	"Wednesday",
	    	    	"Thursday",
	    	    	"Friday",
	    	    	"Saturday" },

    CFM_BOLD = 1,
    CFM_COLOR = 1073741824,
    CFM_FACE = 536870912,
    CFM_ITALIC = 2,
    CFM_OFFSET = 268435456,
    CFM_PROTECTED = 16,
    CFM_SIZE =  #80000000,
    CFM_STRIKEOUT = 8,
    CFM_UNDERLINE = 4,

    CFM_ALL = w32or_all( {
    CFM_BOLD,
    CFM_COLOR,
    CFM_FACE,
    CFM_ITALIC,
    CFM_OFFSET,
    CFM_PROTECTED,
    CFM_SIZE,
    CFM_STRIKEOUT,
    CFM_UNDERLINE }),

    CFE_AUTOCOLOR = 1073741824,
    CFE_BOLD = 1,
    CFE_ITALIC = 2,
    CFE_STRIKEOUT = 8,
    CFE_UNDERLINE = 4,
    CFE_PROTECTED = 16,

    EM_DISPLAYBAND  = 1075,
    EM_EXGETSEL = 1076,
    EM_EXLIMITTEXT = 1077,
    EM_EXLINEFROMCHAR = 1078,
    EM_EXSETSEL = 1079,
    EM_FINDTEXT = 1080,
    EM_FORMATRANGE = 1081,
    EM_GETPARAFORMAT = 1085,
    EM_SETPARAFORMAT = 1095,
    EM_STREAMIN = 1097,
    EM_STREAMOUT = 1098,
    EM_GETTEXTRANGE = 1099,
    EM_FINDTEXTEX = 1103,

    FR_DIALOGTERM             =    #40,
    FR_DOWN                   =    #01,
    FR_ENABLEHOOK             =   #100,
    FR_ENABLETEMPLATE         =   #200,
    FR_ENABLETEMPLATEHANDLE   =  #2000,
    FR_FINDNEXT               =    #08,
    FR_HIDEUPDOWN             =  #4000,
    FR_HIDEMATCHCASE          =  #8000,
    FR_HIDEWHOLEWORD          = #10000,
    FR_MATCHCASE              =    #04,
    FR_NOMATCHCASE            =   #800,
    FR_NOUPDOWN               =   #400,
    FR_NOWHOLEWORD            =  #1000,
    FR_REPLACE                =    #10,
    FR_REPLACEALL             =    #20,
    FR_SHOWHELP               =    #80,
    FR_WHOLEWORD              =    #02,

    SF_TEXT = 1,
    SF_RTF = 2,
    SF_RTFNOOBJS = 3,
    SF_TEXTIZED = 4,
    SFF_SELECTION = #8000,
    SFF_PLAINRTF = #4000,
    StreamText = SF_TEXT,
    StreamRTF = SF_RTF,
    StreamRich = SF_RTF,
    StreamSelection = SFF_SELECTION,
    StreamMask = #C007, -- Used force other bits off.

    PFM_ALIGNMENT = 8,
    PFM_NUMBERING = 32,
    PFM_OFFSET = 4,
    PFM_OFFSETINDENT =  #80000000,
    PFM_RIGHTINDENT = 2,
    PFM_STARTINDENT = 1,
    PFM_TABSTOPS = 16,
    PFN_BULLET = 1,

    PFA_LEFT = 1,
    PFA_RIGHT = 2,
    PFA_CENTER = 3,

    UDS_ALIGNLEFT = 8,
    UDS_ALIGNRIGHT = 4,
    UDS_ARROWKEYS = 32,
    UDS_AUTOBUDDY = 16,
    UDS_HORZ = 64,
    UDS_NOTHOUSANDS = 128,
    UDS_SETBUDDYINT = 2,
    UDS_WRAP = 1,

    UD_MAXVAL = 32767,
    UD_MINVAL = -32767,

    UDM_GETACCEL = 1132,
    UDM_GETBASE = 1134,
    UDM_GETBUDDY = 1130,
    UDM_GETPOS = 1128,
    UDM_GETRANGE = 1126,
    UDM_SETACCEL = 1131,
    UDM_SETBASE = 1133,
    UDM_SETBUDDY = 1129,
    UDM_SETPOS = 1127,
    UDM_SETRANGE = 1125,
    UDM_SETRANGE32 = 1135,
    UDM_GETRANGE32 = 1136,

    UDN_DELTAPOS = -722,

    RB_INSERTBANDA  =(WM_USER +  1),
    RB_DELETEBAND   =(WM_USER +  2),
    RB_GETBARINFO   =(WM_USER +  3),
    RB_SETBARINFO   =(WM_USER +  4),
    RB_SETBANDINFOA = (WM_USER +  6),
    RB_SETPARENT    =(WM_USER +  7),
    RB_HITTEST      =(WM_USER +  8),
    RB_GETRECT      =(WM_USER +  9),
    RB_INSERTBANDW  =(WM_USER +  10),
    RB_SETBANDINFOW =(WM_USER +  11),
    RB_GETBANDCOUNT =(WM_USER +  12),
    RB_GETROWCOUNT  =(WM_USER +  13),
    RB_GETROWHEIGHT =(WM_USER +  14),
    RB_IDTOINDEX    =(WM_USER +  16),
    RB_GETTOOLTIPS  =(WM_USER +  17),
    RB_SETTOOLTIPS  =(WM_USER +  18),
    RB_SETBKCOLOR   =(WM_USER +  19),
    RB_GETBKCOLOR   =(WM_USER +  20),
    RB_SETTEXTCOLOR =(WM_USER +  21),
    RB_GETTEXTCOLOR =(WM_USER +  22),
    RB_SIZETORECT   =(WM_USER +  23),
    RB_SETCOLORSCHEME=   CCM_SETCOLORSCHEME,
    RB_GETCOLORSCHEME=   CCM_GETCOLORSCHEME,
    RB_INSERTBAND   = RB_INSERTBANDA,
    RB_SETBANDINFO  = RB_SETBANDINFOA,
    RB_BEGINDRAG    =(WM_USER + 24),
    RB_ENDDRAG      =(WM_USER + 25),
    RB_DRAGMOVE     =(WM_USER + 26),
    RB_GETBARHEIGHT =(WM_USER + 27),
    RB_GETBANDINFOW =(WM_USER + 28),
    RB_GETBANDINFOA =(WM_USER + 29),
    RB_GETBANDINFO  = RB_GETBANDINFOA,
    RB_MINIMIZEBAND =(WM_USER + 30),
    RB_MAXIMIZEBAND =(WM_USER + 31),
    RB_GETDROPTARGET= (CCM_GETDROPTARGET),
    RB_GETBANDBORDERS= (WM_USER + 34),
    RB_SHOWBAND     =(WM_USER + 35),
    RB_SETPALETTE   =(WM_USER + 37),
    RB_GETPALETTE   =(WM_USER + 38),
    RB_MOVEBAND     =(WM_USER + 39),


    RBS_TOOLTIPS        = #0100,
    RBS_VARHEIGHT       = #0200,
    RBS_BANDBORDERS     = #0400,
    RBS_FIXEDORDER      = #0800,
    RBS_REGISTERDROP    = #1000,
    RBS_AUTOSIZE        = #2000,
    RBS_VERTICALGRIPPER = #4000,
    RBS_DBLCLKTOGGLE    = #8000,


    RBBS_BREAK          = #00000001,
    RBBS_FIXEDSIZE      = #00000002,
    RBBS_CHILDEDGE      = #00000004,
    RBBS_HIDDEN         = #00000008,
    RBBS_NOVERT         = #00000010,
    RBBS_FIXEDBMP       = #00000020,
    RBBS_VARIABLEHEIGHT = #00000040,
    RBBS_GRIPPERALWAYS  = #00000080,
    RBBS_NOGRIPPER      = #00000100,

    RBBIM_STYLE         = #00000001,
    RBBIM_COLORS        = #00000002,
    RBBIM_TEXT          = #00000004,
    RBBIM_IMAGE         = #00000008,
    RBBIM_CHILD         = #00000010,
    RBBIM_CHILDSIZE     = #00000020,
    RBBIM_SIZE          = #00000040,
    RBBIM_BACKGROUND    = #00000080,
    RBBIM_ID            = #00000100,
    RBBIM_IDEALSIZE     = #00000200,
    RBBIM_LPARAM        = #00000400,
    RBBIM_HEADERSIZE    = #00000800,

    RBN_HEIGHTCHANGE    = -831,

    TTS_ALWAYSTIP           = #01,
    TTS_NOPREFIX            = #02,
    TTS_NOANIMATE           = #10,
    TTS_NOFADE              = #20,
    TTS_BALLOON             = #40,

    TTF_IDISHWND            = #0001,
    TTF_CENTERTIP           = #0002,
    TTF_RTLREADING          = #0004,
    TTF_SUBCLASS            = #0010,
    TTF_TRACK               = #0020,
    TTF_ABSOLUTE            = #0080,
    TTF_TRANSPARENT         = #0100,
    TTF_DI_SETITEM          = #8000,

    TTDT_AUTOMATIC          = 0,
    TTDT_RESHOW             = 1,
    TTDT_AUTOPOP            = 2,
    TTDT_INITIAL            = 3,

    TTM_ACTIVATE            = (WM_USER + 1),
    TTM_SETDELAYTIME        = (WM_USER + 3),
    TTM_ADDTOOL             = (WM_USER + 4),
    TTM_ADDTOOLW            = (WM_USER + 50),
    TTM_DELTOOL             = (WM_USER + 5),
    TTM_DELTOOLW            = (WM_USER + 51),
    TTM_NEWTOOLRECT         = (WM_USER + 6),
    TTM_NEWTOOLRECTW        = (WM_USER + 52),
    TTM_RELAYEVENT          = (WM_USER + 7),
    TTM_GETTOOLINFO         = (WM_USER + 8),
    TTM_SETTOOLINFO         = (WM_USER + 9),
    TTM_HITTEST             = (WM_USER +10),
    TTM_GETTEXT             = (WM_USER +11),
    TTM_UPDATETIPTEXT       = (WM_USER +12),
    TTM_GETTOOLCOUNT        = (WM_USER +13),
    TTM_ENUMTOOLS           = (WM_USER +14),
    TTM_GETCURRENTTOOL      = (WM_USER + 15),
    TTM_WINDOWFROMPOINT     = (WM_USER + 16),
    TTM_TRACKACTIVATE       = (WM_USER + 17),
    TTM_TRACKPOSITION       = (WM_USER + 18),
    TTM_SETTIPBKCOLOR       = (WM_USER + 19),
    TTM_SETTIPTEXTCOLOR     = (WM_USER + 20),
    TTM_GETDELAYTIME        = (WM_USER + 21),
    TTM_GETTIPBKCOLOR       = (WM_USER + 22),
    TTM_GETTIPTEXTCOLOR     = (WM_USER + 23),
    TTM_SETMAXTIPWIDTH      = (WM_USER + 24),
    TTM_GETMAXTIPWIDTH      = (WM_USER + 25),
    TTM_SETMARGIN           = (WM_USER + 26),
    TTM_GETMARGIN           = (WM_USER + 27),
    TTM_POP                 = (WM_USER + 28),
    TTM_UPDATE              = (WM_USER + 29),

    TTN_FIRST               = -520,
    TTN_GETDISPINFO         = (TTN_FIRST - 0),
    TTN_GETDISPINFOW        = (TTN_FIRST - 10),
    TTN_SHOW                = (TTN_FIRST - 1),
    TTN_POP                 = (TTN_FIRST - 2),
    TTN_NEEDTEXT            = TTN_GETDISPINFO,

    WH_CALLWNDPROC = 4,
    WH_CALLWNDPROCRET = 12,
    WH_CBT = 5,
    WH_DEBUG = 9,
    WH_GETMESSAGE = 3,
    WH_JOURNALPLAYBACK = 1,
    WH_JOURNALRECORD = 0,
    WH_KEYBOARD = 2,
    WH_MOUSE = 7,
    WH_MSGFILTER = -1,
    WH_SHELL = 10,
    WH_SYSMSGFILTER = 6,
    WH_MIN = -1,
    WH_FOREGROUNDIDLE = 11,

    WM_PSD_ENVSTAMPRECT = 1029,
    WM_PSD_FULLPAGERECT = 1025,
    WM_PSD_GREEKTEXTRECT = 1028,
    WM_PSD_MARGINRECT = 1027,
    WM_PSD_MINMARGINRECT = 1026,
    WM_PSD_PAGESETUPDLG = 1024,
    WM_PSD_YAFULLPAGERECT = 1030,

    PSD_DEFAULTMINMARGINS = 0,
    PSD_DISABLEMARGINS = 16,
    PSD_DISABLEORIENTATION = 256,
    PSD_DISABLEPAGEPAINTING = 524288,
    PSD_DISABLEPAPER = 512,
    PSD_DISABLEPRINTER = 32,
    PSD_ENABLEPAGEPAINTHOOK = 262144,
    PSD_ENABLEPAGESETUPHOOK = 8192,
    PSD_ENABLEPAGESETUPTEMPLATE = 32768,
    PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072,
    PSD_INHUNDREDTHSOFMILLIMETERS = 8,
    PSD_INTHOUSANDTHSOFINCHES = 4,
    PSD_INWININIINTLMEASURE = 0,
    PSD_MARGINS = 2,
    PSD_MINMARGINS = 1,
    PSD_NOWARNING = 128,
    PSD_RETURNDEFAULT = 1024,
    PSD_SHOWHELP = 2048,

    TBSTATE_CHECKED         = #01,
    TBSTATE_PRESSED         = #02,
    TBSTATE_ENABLED         = #04,
    TBSTATE_HIDDEN          = #08,
    TBSTATE_INDETERMINATE   = #10,
    TBSTATE_WRAP            = #20,
    TBSTATE_ELLIPSES        = #40,
    TBSTATE_MARKED          = #80,

    TBSTYLE_BUTTON          = #0000,
    TBSTYLE_SEP             = #0001,
    TBSTYLE_CHECK           = #0002,
    TBSTYLE_GROUP           = #0004,
    TBSTYLE_CHECKGROUP      = w32or_all({TBSTYLE_GROUP ,TBSTYLE_CHECK}),
    TBSTYLE_DROPDOWN        = #0008,
    TBSTYLE_AUTOSIZE        = #0010,
    TBSTYLE_NOPREFIX        = #0020,

    TBSTYLE_TOOLTIPS        = #0100,
    TBSTYLE_WRAPABLE        = #0200,
    TBSTYLE_ALTDRAG         = #0400,
    TBSTYLE_FLAT            = #0800,
    TBSTYLE_LIST            = #1000,
    TBSTYLE_CUSTOMERASE     = #2000,
    TBSTYLE_REGISTERDROP    = #4000,
    TBSTYLE_TRANSPARENT     = #8000,
    TBSTYLE_EX_DRAWDDARROWS = #0001,

    TBIMHT_AFTER                = 1,
    TBIMHT_BACKGROUND           = 2,

    TBIF_IMAGE              = #00000001,
    TBIF_TEXT               = #00000002,
    TBIF_STATE              = #00000004,
    TBIF_STYLE              = #00000008,
    TBIF_LPARAM             = #00000010,
    TBIF_COMMAND            = #00000020,
    TBIF_SIZE               = #00000040,

    TBDDRET_DEFAULT         = 0,
    TBDDRET_NODEFAULT       = 1,
    TBDDRET_TREATPRESSED    = 2,


    TB_ENABLEBUTTON         = (WM_USER + 1),
    TB_CHECKBUTTON          = (WM_USER + 2),
    TB_PRESSBUTTON          = (WM_USER + 3),
    TB_HIDEBUTTON           = (WM_USER + 4),
    TB_INDETERMINATE        = (WM_USER + 5),
    TB_MARKBUTTON           = (WM_USER + 6),
    TB_ISBUTTONENABLED      = (WM_USER + 9),
    TB_ISBUTTONCHECKED      = (WM_USER + 10),
    TB_ISBUTTONPRESSED      = (WM_USER + 11),
    TB_ISBUTTONHIDDEN       = (WM_USER + 12),
    TB_ISBUTTONINDETERMINATE= (WM_USER + 13),
    TB_ISBUTTONHIGHLIGHTED  = (WM_USER + 14),
    TB_SETSTATE             = (WM_USER + 17),
    TB_GETSTATE             = (WM_USER + 18),
    TB_ADDBITMAP            = (WM_USER + 19),
    TB_ADDBUTTONS           = (WM_USER + 20),
    TB_INSERTBUTTON         = (WM_USER + 21),
    TB_DELETEBUTTON         = (WM_USER + 22),
    TB_GETBUTTON            = (WM_USER + 23),
    TB_BUTTONCOUNT          = (WM_USER + 24),
    TB_COMMANDTOINDEX       = (WM_USER + 25),
    TB_SAVERESTORE          = (WM_USER + 26),
    TB_CUSTOMIZE            = (WM_USER + 27),
    TB_ADDSTRING            = (WM_USER + 28),
    TB_GETITEMRECT          = (WM_USER + 29),
    TB_BUTTONSTRUCTSIZE     = (WM_USER + 30),
    TB_SETBUTTONSIZE        = (WM_USER + 31),
    TB_SETBITMAPSIZE        = (WM_USER + 32),
    TB_AUTOSIZE             = (WM_USER + 33),
    TB_GETTOOLTIPS          = (WM_USER + 35),
    TB_SETTOOLTIPS          = (WM_USER + 36),
    TB_SETPARENT            = (WM_USER + 37),
    TB_SETROWS              = (WM_USER + 39),
    TB_GETROWS              = (WM_USER + 40),
    TB_SETCMDID             = (WM_USER + 42),
    TB_CHANGEBITMAP         = (WM_USER + 43),
    TB_GETBITMAP            = (WM_USER + 44),
    TB_GETBUTTONTEXT        = (WM_USER + 45),
    TB_REPLACEBITMAP        = (WM_USER + 46),
    TB_SETINDENT            = (WM_USER + 47),
    TB_SETIMAGELIST         = (WM_USER + 48),
    TB_GETIMAGELIST         = (WM_USER + 49),
    TB_LOADIMAGES           = (WM_USER + 50),
    TB_GETRECT              = (WM_USER + 51),
    TB_SETHOTIMAGELIST      = (WM_USER + 52),
    TB_GETHOTIMAGELIST      = (WM_USER + 53),
    TB_SETDISABLEDIMAGELIST = (WM_USER + 54),
    TB_GETDISABLEDIMAGELIST = (WM_USER + 55),
    TB_SETSTYLE             = (WM_USER + 56),
    TB_GETSTYLE             = (WM_USER + 57),
    TB_GETBUTTONSIZE        = (WM_USER + 58),
    TB_SETBUTTONWIDTH       = (WM_USER + 59),
    TB_SETMAXTEXTROWS       = (WM_USER + 60),
    TB_GETTEXTROWS          = (WM_USER + 61),
    TB_GETOBJECT            = (WM_USER + 62),
    TB_GETBUTTONINFO        = (WM_USER + 65),
    TB_SETBUTTONINFO        = (WM_USER + 66),
    TB_GETHOTITEM           = (WM_USER + 71),
    TB_SETHOTITEM           = (WM_USER + 72),
    TB_SETANCHORHIGHLIGHT   = (WM_USER + 73),
    TB_GETANCHORHIGHLIGHT   = (WM_USER + 74),
    TB_MAPACCELERATOR       = (WM_USER + 78),

    TBN_FIRST = -700,
    TBN_BEGINADJUST = -703,
    TBN_BEGINDRAG = -701,
    TBN_CUSTHELP = -709,
    TBN_ENDADJUST = -704,
    TBN_ENDDRAG = -702,
    TBN_GETBUTTONINFOW = -720,
    TBN_GETBUTTONINFO = -700,
    TBN_QUERYDELETE = -707,
    TBN_QUERYINSERT = -706,
    TBN_RESET = -705,
    TBN_TOOLBARCHANGE = -708,
    TBN_LAST = -720,


    CBEIF_TEXT              = #00000001,
    CBEIF_IMAGE             = #00000002,
    CBEIF_SELECTEDIMAGE     = #00000004,
    CBEIF_OVERLAY           = #00000008,
    CBEIF_INDENT            = #00000010,
    CBEIF_LPARAM            = #00000020,
    CBEIF_DI_SETITEM        = #10000000,

    CBEM_INSERTITEM         = (WM_USER + 1),
    CBEM_SETIMAGELIST       = (WM_USER + 2),
    CBEM_GETIMAGELIST       = (WM_USER + 3),
    CBEM_GETITEM            = (WM_USER + 4),
    CBEM_SETITEM            = (WM_USER + 5),
    CBEM_DELETEITEM         = CB_DELETESTRING,
    CBEM_GETCOMBOCONTROL    = (WM_USER + 6),
    CBEM_GETEDITCONTROL     = (WM_USER + 7),
    CBEM_SETEXSTYLE         = (WM_USER + 8),
    CBEM_SETEXTENDEDSTYLE   = (WM_USER + 14),
    CBEM_GETEXSTYLE         = (WM_USER + 9),
    CBEM_GETEXTENDEDSTYLE   = (WM_USER + 9),
    CBEM_HASEDITCHANGED     = (WM_USER + 10),
    CBEM_INSERTITEMW        = (WM_USER + 11),
    CBEM_SETITEMW           = (WM_USER + 12),
    CBEM_GETITEMW           = (WM_USER + 13),
    CBES_EX_NOEDITIMAGE          = #00000001,
    CBES_EX_NOEDITIMAGEINDENT    = #00000002,
    CBES_EX_PATHWORDBREAKPROC    = #00000004,
    CBES_EX_NOSIZELIMIT          = #00000008,
    CBES_EX_CASESENSITIVE        = #00000010,


-------------------------------------------------
    GTL_DEFAULT           = 0,
    GTL_USECRLF           = 1,
    GTL_PRECISE           = 2,
    GTL_CLOSE             = 4,
    GTL_NUMCHARS          = 8,
    GTL_NUMBYTES          = 16,

-------------------------------------------------
    LVBKIF_SOURCE_NONE          = #0,
    LVBKIF_SOURCE_HBITMAP       = #1,
    LVBKIF_SOURCE_URL           = #2,
    LVBKIF_STYLE_NORMAL         = #0,
    LVBKIF_STYLE_TILE           = #10,
    LVBKIF_FLAG_TILEOFFSET      = #100,
    LVBKIF_FLAG_ALPHABLEND      = #200, -- not sure, couldn't find a reference
    LVBKIF_TYPE_WATERMARK       = #10000000,

    MIIM_STATE       = #00000001,
    MIIM_ID          = #00000002,
    MIIM_SUBMENU     = #00000004,
    MIIM_CHECKMARKS  = #00000008,
    MIIM_TYPE        = #00000010,
    MIIM_DATA        = #00000020,
    MIIM_STRING      = #00000040,
    MIIM_BITMAP      = #00000080,
    MIIM_FTYPE       = #00000100,

    GT_DEFAULT           = 0,
    GT_USECRLF           = 1,
    GT_SELECTION         = 2,

    CP_ACP               = 0, -- Use ANSI codepage
    CP_UNICODE           = 1200, -- Use Unicode codepage

    SWP_NOSIZE          = #0001,
    SWP_NOMOVE          = #0002,
    SWP_NOZORDER        = #0004,
    SWP_NOREDRAW        = #0008,
    SWP_NOACTIVATE      = #0010,
    SWP_FRAMECHANGED    = #0020,
    SWP_SHOWWINDOW      = #0040,
    SWP_HIDEWINDOW      = #0080,
    SWP_NOCOPYBITS      = #0100,
    SWP_NOOWNERZORDER   = #0200,
    SWP_NOSENDCHANGING  = #0400,
    SWP_DRAWFRAME       = SWP_FRAMECHANGED,
    SWP_NOREPOSITION    = SWP_NOOWNERZORDER,
    SWP_DEFERERASE      = #2000,
    SWP_ASYNCWINDOWPOS  = #4000,
    SWP_UPDATECACHE     = SWP_NOSIZE+SWP_NOMOVE+SWP_NOZORDER+SWP_FRAMECHANGED,
    HWND_TOP            = 0,
    HWND_BOTTOM         = 1,
    HWND_TOPMOST        = -1,
    HWND_NOTOPMOST      = -2,

-----------------------------------------------------------------------------
-- common control styles
    CCS_ADJUSTABLE      = #20,
    CCS_BOTTOM          = #3,
    CCS_NODIVIDER       = #40,
    CCS_NOMOVEY         = #2,
    CCS_NOPARENTALIGN   = #8,
    CCS_NORESIZE        = #4,
    CCS_TOP             = #1,
    CCS_VERT            = #80,
    CCS_LEFT            = CCS_VERT + CCS_TOP,
    CCS_RIGHT           = CCS_VERT + CCS_BOTTOM,
    ANIMATE_CLASSA      = "SysAnimate32",
    HOTKEY_CLASSA       = "msctls_hotkey32",
    PROGRESS_CLASSA     = "msctls_progress32",
    STATUSCLASSNAMEA    = "msctls_statusbar32",
    TOOLBARCLASSNAMEA   = "ToolbarWindow32",
    TOOLTIPS_CLASSA     = "tooltips_class32",
    TRACKBAR_CLASSA     = "msctls_trackbar32",
    UPDOWN_CLASSA       = "msctls_updown32",
    WC_HEADERA          = "SysHeader32",
    WC_LISTVIEWA        = "SysListView32",
    WC_LISTVIEW         = WC_LISTVIEWA,
    WC_TABCONTROLA      = "SysTabControl32",
    WC_TREEVIEWA        = "SysTreeView32",
    MONTHCAL_CLASS      = "SysMonthCal32",
    REBARCLASSNAME      = "ReBarWindow32",
    ANIMATE_CLASS       = "SysAnimate32",
    DATETIMEPICK_CLASS  = "SysDateTimePick32",
    WC_PAGESCROLLER     = "SysPager",
    WC_NATIVEFONTCTL    = "NativeFontCtl",
    WC_COMBOBOXEX       = "ComboBoxEx32",

-----------------------------------------------------------------------------
-- attributes for EZ_FONTS
    Normal          = 0,
    Bold            = 1,
    Italic          = 2,
    Underline       = 4,
    Strikeout       = 8,
    Superscript     = 16,

-----------------------------------------------------------------------------
-- attributes for showWindow
--  Normal          = 0,
    Modal           = -1

global constant
    Minimize        = SW_SHOWMINIMIZED,
    Maximize        = SW_SHOWMAXIMIZED,
    Minimized       = SW_SHOWMINIMIZED,
    Maximized       = SW_SHOWMAXIMIZED,

-----------------------------------------------------------------------------
-- attributes for shift keys
    NoShift         = #00,
    ShiftMask       = #01,           -- shift key is held down
    ControlMask     = #02,           -- control key is held down
    AltMask         = #04,           -- alt key is held down
    WinMask         = #08,           -- win key is held down
    KeyMask         = #0F,
    LeftBtnMask     = #10,           -- Left Button down
    RightBtnMask    = #20,           -- Right Button Down
    MiddleBtnMask   = #40,           -- Middle Button down
    BtnMask         = #F0

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Classes of Windows: Base Classes
-----------------------------------------------------------------------------
global constant
    WINDOW          = 0,    -- window
    BUTTON          = 1,    -- button
    COMBO           = 2,    -- combo box
    EDIT            = 3,    -- edit
    LISTBOX         = 4,    -- list box
    SCROLLBAR       = 5,    -- scroll bar
    STATIC          = 6,    -- static
    MENU            = 7,    -- menu
    POPUP           = 8,    -- popup menu
    MENUITEM        = 9,    -- menu item
    PIXMAP          = 10,   -- pixmap,
    COMMON_CONTROL  = 11   -- common controls,


-----------------------------------------------------------------------------
-- Classes of Windows: Used for internal identification of window type
-----------------------------------------------------------------------------

constant Classes = next_number(0)
global constant
    Window          = next_number(Classes),

    PushButton      = next_number(Classes),
    CommandButton   = PushButton,
    Button          = PushButton,

    DefPushButton   = next_number(Classes),
    DefButton       = DefPushButton,

    CancelButton    = next_number(Classes),

    CheckBox        = next_number(Classes),

    TriCheckBox     = next_number(Classes),

    Radio           = next_number(Classes),
    RadioButton     = Radio,

    Group           = next_number(Classes),
    GroupBox        = Group,

    List            = next_number(Classes),
    ListBox         = List,

    SortedList      = next_number(Classes),

    Combo           = next_number(Classes),
    ComboBox        = Combo,

    SortedCombo     = next_number(Classes),

    SimpleCombo     = next_number(Classes),

    DropDownList    = next_number(Classes),

    EditText        = next_number(Classes),
    EditBox         = EditText,
    TextBox         = EditText,
    SleText         = EditText,

    MleText         = next_number(Classes),

    LText           = next_number(Classes),
    Label           = LText,

    RText           = next_number(Classes),

    CText           = next_number(Classes),

    HScroll         = next_number(Classes),

    VScroll         = next_number(Classes),

    Icon            = next_number(Classes),

    Bitmap          = next_number(Classes),

    Menu            = next_number(Classes),

    Popup           = next_number(Classes),

    MenuItem        = next_number(Classes),

    MenuSpacer      = next_number(Classes),

    Pixmap          = next_number(Classes),

    ToolBar         = next_number(Classes),

    StatusBar       = next_number(Classes),

    PictureButton   = next_number(Classes),

    ToggleButton    = next_number(Classes),

    TogglePicture   = next_number(Classes),

    HTrackBar       = next_number(Classes),

    VTrackBar       = next_number(Classes),

    TabControl      = next_number(Classes),

    TabItem         = next_number(Classes),

    ProgressBar     = next_number(Classes),

    ListView        = next_number(Classes),

    ImageList       = next_number(Classes),

    TreeView        = next_number(Classes),

    RichEdit        = next_number(Classes),

    MonthCalendar   = next_number(Classes),

    UpDown          = next_number(Classes),

    ReBar           = next_number(Classes),

    ReBarBand       = next_number(Classes),

    ToolTip         = next_number(Classes),

    FlatToolBar     = next_number(Classes),

    SepButton       = next_number(Classes),

    ComboBoxEx      = next_number(Classes)


-- win32lib class attribute flags.
global constant
    w32Clickable  = #0001,  -- Can allow mouseup detection to fire onClick handler
    w32NoConv     = #0002,  -- Must not allow relative dimension conversions
    w32PictCtrl   = #0004,  -- Controls that pass bitmaps in the flags
    w32CtrlTab    = #0008,  -- CTRL-tabkey must be used to move tabstops
    w32AutoSelect = #0010,  -- Control's data gets selected when it gets focus
    w32AutoCancel = #0020,  -- Control has auto hotkey set to ESCAPE
    w32NoRenderDisabled = #0040, -- Control is not shown with different BG when disabled.
    w32UseSubProc = #0080,  -- If using default BG, use the subclassed proc rather than the default proc.
    w32OwnerId    = #0100,  -- Supplies owner's id in createEx() API call
    w32Virtual    = #0200,  -- This is a virtual control. The effective parent is really the grandparent.
    w32Toolbar    = #0400,  -- This acts as a toolbar on top of client area
    w32Statusbar  = #0800,  -- This acts as a statusbar on bottom of client area
    w32HasChildren= #1000   -- This type of control can have children

global function w32NumClasses()
    return current_number(Classes)
end function

global function w32NewClass()
    return next_number(Classes)
end function

-- special win32lib BG color values
global constant
    w32BGTransparent = {},  -- Takes on the parent's BG color.
    w32WinDefColor   = {{}} -- Use Windows default Color

--/topic Constants
--/const kLVSortRtn
--/desc Used by /setLVAttr

global constant
    kLVColTypes = 1,
    kLVSortSeq = 2,
    kLVSortCol = 3,
    kLVSortRtn = 4

-----------------------------------------------------------------------------
--/topic Events
--/const w32HMouse
--/desc Event triggered when a mouse action takes place.
-- /i parms = { integer event, integer x, integer y, integer shift, integer wheelmove } /n
--
-- The /i event parameter will be one of the following values:
--
-- /li /b MouseMove: the mouse was moved
-- /li /b LeftDown: the left mouse button was pressed
-- /li /b RightDown: the right mouse button was pressed
-- /li /b LeftUp: the left mouse button was released
-- /li /b RightUp: the right mouse button was released
-- /li /b LeftDoubleClick: the left mouse button was double clicked
-- /li /b RightDoubleClick: the right mouse button was double clicked
-- /li /b WheelMove: The mouse wheel has moved.
--
-- The /i x and /i y parameters specify where the mouse is located.
-- If the mouse has been /i grabbed (see /captureMouse), the values
-- of /i x and /i y can be negative if the mouse is outside the
-- client area.
--
-- The /i shift parameter has bits set indicating the if the keyboard
-- shift, control, and alt keys are pressed, and which mouse button was
-- pressed. /n
--The masks are:
--
-- /li /b ShiftMask --> Left and/or Right Shift key down
-- /li /b ControlMask --> Left and/or Right Control key down
-- /li /b AltMask --> Left and/or Right Alt key down
-- /li /b WinMask --> Left and/or Right Windows key down
-- /li /b KeyMask --> Any of the Shift/Control/Alt keys down.
-- /li /b LeftBtnMask --> Left mouse button down.
-- /li /b RightBtnMask --> Right mouse button down.
-- /li /b MiddleBtnMask --> Middle mouse down.
-- /li /b BtnMask --> Any mouse button down.
--
--
--
-- /code
--      -- Is one of the shift keys is held down?
--      if and_bits( shift, ShiftMask ) then
--          . . .
--      end if
--      -- Check for the combination Ctrl and Right Mouse.
--      if and_bits( shift, ControlMask+RightBtnMask ) then
--          . . .
--      end if
-- /endcode
--
-- /b NOTE /i "/b wheelmove is not supported for the onXXX interface, only the"
-- /i "setHandler interface is supported." /n
-- The /i WheelMove parameter describes the direction and size of the mouse wheel
-- movement. A value /b greater than 0 means that the wheel moved 'up' or away
-- from the user, and a value /b less than zero means the wheel moved 'down'
-- or towards the user. And of course, a value of /b 0 means that
-- it didn't move at all. /n
-- The speed, or size, of the movement is the absolute value of this parameter. You
-- can use this in conjunction with /getWheelScrollLines() to work out how the
-- mouse wheel movement should effect your application.
--
--Example: /n
--/code
--   TopLine += parms[5] * getWheelScrollLines()
--   RefreshDisplay()
--/endcode
--
-- /b "Special Note:" If you call returnValue(0) inside your mouse handler
-- routine, this has the effect of causing the control that received
-- the mouse event to ignore it. This is only needed in rare circumstances
-- where your processing of the mouse event interferes with the control's
-- normal processing. For example, if you trap a Right Down event to
-- cause a popup menu to show, sometimes you also need to tell the
-- underlying control to ignore the button down event 'cos you used it.


--/topic Events
--/const w32HMouseTrap
--/desc Event triggered when a mouse action takes place inside a defined /MouseTrap for a control.
-- /i parms = { integer event, integer x, integer y, integer z, sequence traps, integer id, integer shift } /n
--
-- The /i event parameter will be one of the following values:
--
-- /li /b MouseMove: the mouse was moved
-- /li /b LeftDown: the left mouse button was pressed
-- /li /b RightDown: the right mouse button was pressed
-- /li /b LeftUp: the left mouse button was released
-- /li /b RightUp: the right mouse button was released
-- /li /b LeftDoubleClick: the left mouse button was double clicked
-- /li /b RightDoubleClick: the right mouse button was double clicked
-- /li /b WheelMove: The mouse wheel has moved.
--
-- The /i x and /i y parameters specify where the mouse is located.
-- If the mouse has been /i grabbed (see /captureMouse), the values
-- of /i x and /i y can be negative if the mouse is outside the
-- client area.
--
-- The /i z parameter only applies to WheelMouse events and is the amount and direction
-- that the wheel moved. Positive values mean it move away from the user (up), and negative
-- values mean that it moved towards the user (down).
--
-- The /i traps parameter is a list of one or more mousetrap areas that are
-- under the mouse pointer. Each mousetrap is a sequence of 8 elements: /n
--/li integer: /b zorder, the higher numbers are further in the background. The
-- initial value is zero when a mousetrap is created.
--/li integer: /b left, the leftmost position of the mousetrap area
--/li integer: /b top, the topmost position of the mousetrap area
--/li integer: /b right, the rightmost position of the mousetrap area
--/li integer: /b bottom, the bottommost position of the mousetrap area
--/li integer: /b id, the id of this mousetrap area.
--/li object: /b userdata, the data set by calling /setTagMouseTrap(). This is
--never used by win32lib and is intended for use by the user for anything.
--/li sequence: /b filters, a list of zero or more mouse event codes that are used
--to filter in this mousetrap. Initially this set to {WM_LBUTTONDOWN} when
--then mousetrap is created. It can be changed by calling /filterMouseTrap().
--
--The /i id parameter is the control id that received the mouse event.
--
-- The /i shift parameter is the same as for the /w32HKeydown event.
--
-- /b Note: This event is only invoked for MouseTraps that are enabled. When
-- a mousetrap is created it is automatically enabled, but this can be changed
-- by calling /enableMouseTrap().
--
-- /code
--      sequence mt
--      mt = {}
--      mt &= /createMouseTrap(vWin, {10,10,30,30})
--      mt &= /createMouseTrap(vWin, {30,10,50,30})
--      mt &= /createMouseTrap(vWin, {10,30,30,50})
--      mt &= /createMouseTrap(vWin, {30,30,50,50})
--      /filterMouseTrap(vWin, mt[2], {WheelMove})
--      /filterMouseTrap(vWin, mt[4], {WheelMove})
--
--      procedure MouseTrap_MyWindow(integer self, integer event, sequence parms)
--          sequence lMsg
--
--          lMsg = sprintf("event=%d x=%d y=%d", parms[1..3])
--          for i = 1 to length(parms[4]) do
--              lMsg &= sprintf("(depth=%d left=%d top=%d right=%d bottom=%d id=%d) ", parms[4][i])
--          end for
--          showMessage(lMsg)
--          -- Only interested in the top mousetrap area...
--          if parms[4][1][6] = mt[2] then
--              -- Wheel moved inside mousetrap #2
--          elsif parms[4][1][6] = mt[1] then
--              -- Left Button down inside mousetrap #1
--          end if
--      end procedure
--      setHandler(vWin, w32HMouseTrap, routine_id("MouseTrap_BasicWindow"))
--
-- /endcode
--
--If the hander for the w32HMouseTrap event returns any value, by calling /returnValue(),
-- the mouse event is not passed through to the underlying control.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HClick
--/desc Invoked when the left mouse button is 'clicked' or a Button control is used.
--/i parms = {  }
--
--This event is triggered when a /PushButton, /CheckBox or /TabItem is clicked,
--or by a MenuItem selection.
--
-- It is /b not the same as a Mousedown event. For a /i click to happen, the left
-- mouse down and up events must be in the same control, be no more than 2 pixels
-- from each other, and the up event must be within a double-click period
-- of the down event.
--
-- The use of accelerator keys, generates a mouse click event.




-----------------------------------------------------------------------------
--/topic Events
--/const w32HPause
--/desc Invoked whenever the Pause key is pressed.
-- /i parms = {integer keyCode, integer shift}

-----------------------------------------------------------------------------
--/topic Events
--/const w32HBreak
--/desc Invoked whenever the Ctrl-Break key is pressed.
-- /i parms = {integer keyCode, integer shift}

-----------------------------------------------------------------------------
--/topic Events
--/const w32HIdle
--/desc Invoked whenever the application is not processing Windows messages.
-- /i parms = {integer Counter, atom MsgAddr}
--
-- Your application will only start getting these events once you have
-- called /setIdle(w32True).
--
-- The /i Counter starts at 1 for each time the handler is invoked after
-- the Windows Message Queue becomes empty again. That is, this handler
-- will be invoked repeatedly, while there are no messages to be processed.
-- You can tell when you application becomes idle when the /i Counter value
-- is 1. Values higher than 1 indicate that the application is /b still idle.
-- When the application becomes active again, the handler is called with a
-- /i Counter value of -1 and the /i MsgAddr contains the message that
-- 'woke up' the application.
--
-- When the value of /i Counter is greater than -1, the /i MsgAddr is the
-- address of the Msg structure that contains the last Windows
-- message before becoming idle. When the /i Counter is -1, this contains
-- the message that is about to be processed.
--
-- If your handler routine calls /returnValue, passing any value, this
-- will immediately wake up your application and cause it to process the
-- information contained in the structure pointer to by /i MsgAddr. This
-- means that you are expected to place into this structure, valid data
-- to simulate a Windows event.
--
-- /b Note: This event is not supported by the onXXX[] interface.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyPress
--/desc "Printable" key is pressed.
-- /i parms = { integer keyCode, integer shift,integer released}
--
-- The /i keyCode is ANSII value of the key. Only "visible" keys are
-- reported with this function. To trap "special" keys (such as the
-- cursor keys), use /w32KeyDown or w32HKeyboard.
-- The third parameter is 1 when the key is released and 0 else.
--
--For example:
--
--/code
--      -- is it the letter 'a'?
--      if keyCode = 'a' then
--          -- it's the letter a
--      end if
--/endcode
--
-- The /i shift parameter has bits set indicating the if the shift,
-- control, and alt keys are pressed. The masks for each key are:
--
-- /li /b ShiftMask
-- /li /b ControlMask
-- /li /b AltMask
--
-- For example, to see if the control key is held down, you could write:
--
-- /code
--      -- control key held down?
--      if and_bits( shift, ControlMask ) then
--          -- control key is held down
--      end if
-- /endcode
--
-- If you want to to Windows to ignore the key, set the return value to -1.
--
-- /code
--      if find(keyCode,"0123456789") then
--          returnValue(-1) -- ignore digits.
--      end if
-- /endcode
--
-- If you want to to Windows to use a different key, set the return value to the new key.
--
-- /code
--     -- collect characters into the password, but don't show them.
--     PassWord &= keyCode
--     returnValue('-') -- return a dash for each character entered.
-- /endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyUp
--/desc Key is released.
-- /i parms = {integer keyCode, integer shift}
--
-- The parameter sequence is the same as for /w32HKeyDown.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HKeyDown
--/desc Key is pressed.
-- /i parms = {integer keyCode, integer shift}
--
-- The /i keyCode is "raw" value of the key. The primary purpose
-- of onKeyDown is to trap "special" keys not reported by /onKeyPress.
--
-- The /i shift parameter has bits set indicating if the shift,
-- control, alt or Windows keys are pressed. The masks for each key are:
--
-- /li /b ShiftMask
-- /li /b ControlMask
-- /li /b AltMask
-- /li /b WinMask
--
-- For example, to see if the Shift+Backspace key was pressed, you could
-- write:
--
-- /code
--      -- shift+backspace?
--      if  and_bits( shift, ControlMask )
--      and keyCode = VK_BACK then
--          -- shift+backspace held
--      end if
-- /endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HResize
--/desc A /Window has been resized.
-- /i parms = { integer style, integer x, integer y, integer delta_x,integer delta_y}
--
-- The /i style is one of the following:
--
-- /li /b SIZE_RESTORED: Window was restored
-- /li /b SIZE_MINIMIZED: Window was minimized
-- /li /b SIZE_MAXIMIZED: Window was maximized
--
-- The /i x and /i y parameters are the new size of the id, not counting title bars and borders. /n
--
-- If your handler returns a value via /returnValue() then the
-- control is forced to be repainted. If it returns a zero (0) then the control's
-- background is not erased before repainting otherwise it is erased first.


--/topic Events
--/const w32HNotify
--/desc A control is forwarding a notification event.
-- /i parms = { integer sender, integer event, object userdata, sequence parms }
--
--A control gets this event when the /i sender control has just processed an
-- event of type /i event with parameters /i parms. This only happens
-- to controls that have told the /i sender that they want to be notified via the
-- /registerNotification() routine. The /i userdata is the same as that passed
-- in the /registerNotification() routine.
--
-- An example of using this facility could be if you wish a control to be notified whenever
-- its parent is resized. Or when a specific control gets focus.
--
--/b Note: This event is not supported by the onXXX interface.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HChange
--/desc Selection or Value in a control is changed.
-- The contents of /i parms varies with the type of control. /b Note that they are
-- only available when using the /setHandler() interface.
--
-- For the List and Combo family of controls the parms are ... /n
-- { Event qualifier (integer), Index of affected item (integer) } /n
--
-- For EditText or RichEdit controls, the parameter sequence is simply {w32CHG_Chg}. In order
-- to get RichEdit controls to fire this event, you must have enabled them by calling --
-- /setREChangeNottification(1).
--
-- For /ListView the parms are ...
--<ul>
--/li   Row Index,
--/li   Column Index,
--/li   New State Flags,
--/li   Changed Flags,
--/li   Mouse's X location,
--/li   Mouse's Y location,
--/li   lParam (user data) field
--</ul>
--
-- For /MonthCalendar the parms are ...
-- if the event is invoked by a date change cuased by pressing one of the
-- prev/next buttons or by paging up/down etc, then the parms are an empty
-- sequence. /n
-- If the event is invoked by an explicit date or date range being clicked then
-- the parms returns two dates. /n
--<ul>
--/li   Earliest Date,
--/li   Latest Date
--</ul>
--
-- /b Note, for /Combo box controls, this is triggered when either the edit box area
-- has been changed by the user, or when the list item selection is about to change.
-- If the user is editing the edit box area then /getText will return the current
-- value of the edit box, but if this event was triggered due to the user selecting
-- a new item, /getText will return the previously selected item and you must
-- use /getItem(id, 0) to retrieve the new selection value.
--
-- To determine the new value of the control, use the appropriate
-- function - /getText, /isChecked, /getIndex etc.
--
-- For Menu and Popup controls, w32HChange is triggered whenever an item is selected.
-- The data sequence is {id of item, state of item} then.
--
-- For UpDown controls, w32HChange is triggered whenever an arrow is clicked.
-- The data sequence is {current position, amount of change} then. If the change is accepted, the new
-- positions depends on the control's range, and on whether it has the UDS_WRAP syle.
--
-- For TabControls, the w32HChange event is fired when an attempt to change the currently selected item is made. The associated data is {new item index,old item index}.
-- If the handler sets the return value, that returned value must be an integer
-- specifying which is the index of the tab to change to. A value of -1 just aborts the change.
--
-- For ComboBoxEx controls, the parameters are: {CHG_SEL,reason}, where /i reason explains why the edit operation ended.
-- This enables ou to monitor semection changes as wel. The reason codes are:
--/li CBENF_KILLFOCUS: control lost focus
--/li CBENF_RETURN: the Enter key was hit to complete the edit operation
--/li CBENF_ESCAPE: the Escape key as hit to cancel the edit operation
--/li CBENF_DROPDOWN: the dropdown button was pressed.
-- If the handler sets the return value, the change will be rejected, and accepted otherwise.


--/topic Events
--/const w32HDataChange
--/desc Value in a List or a Combo's list has changed.
--/i parms is { eventqual, index }
--<ul>
--/li   Event qualifier (integer)
--<ul>
--/li w32CHG_Add = Item added
--/li w32CHG_Chg = Item changed
--/li w32CHG_Del = Item deleted
--</ul>
--/li   Index of affected item (integer)
--</ul>
-- /b Note this event is only available when using the /setHandler() interface.

--/topic Events
--/const w32HDropDown
--/desc The dropdown portion of a combobox is about to be displayed, or the menu is about to be displayed..
-- /i parms = {}  /n
-- This can be used to dynamically load the values into a combobox/menu.


--/topic Events
--/const w32HCloseUp
--/desc The dropdown portion of a combobox has just been closed, or the menu was just closed.
-- /i parms = {}  /n

-----------------------------------------------------------------------------
--/topic Events
--/const w32HGotFocus
--/desc A /control (or /Window) receives focus.
-- /i parms = {}
--
-- /i Focus means that keyboard events are directed to that control.
-- Static controls (such as /LText) cannot get focus.
--
-- When a Win32Lib window gets focus, it will give focus back to the
-- last control in the window that had focus. If there are no controls in
-- the window that can receive focus, the focus will remain with the
-- window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HLostFocus
--/desc A /Window or /control loses focus.
-- /i parms = {focusControl} /n
-- /i focusControl is the id of the control that had the focus. This is normally the
-- same as the /i self parameter but in the case where /i self is a parent Window
-- /i focusControl is the control within that window that had focus.
--
-- /b Note: That /i focusControl parameter is not supported with the onXXX interface.
--
-- /i Focus means that keyboard events are directed to that control. See
-- /w32HGotFocus.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HScroll
--/desc Triggered when scrollbar value has changed, and when user has stopped scrolling.
-- /i parms = { integer position, integer ScrollType, integer WhichBar }
--
-- /i position indicates the new value of a scrollbar or trackbar.
--
-- /i ScrollType is one of <a href="..\win32_constants.htm#scroll Bar Commands">these values</a>. /n

-- /i WhichBar is one of... /n
--<ul>
--/li SB_HORZ
--/li SB_VERT
--</ul>
-- and only applies to the /Window control type.
--
-- /b Note: However, the /i ScrollType and /i WhichBar are only available
-- when using the setHandler() interface.
--
-- This event is only triggered for ... /n
--<ul>
--/li Windows with scrollbars
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--</ul>
-----------------------------------------------------------------------------
--/topic Events
--/const w32HOpen
--/desc A /Window is opened.
-- /i parms = {}
--
-- This is typically triggered by /WinMain, or /openWindow,
-- before the window is visible by the user.
--
-- Typically, code that is run at this point does some sort of
-- initialization.
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HActivate
--/desc Occurs for Windows only and after the window is opened.
--/i parms = {}
--
-- This is typically triggered by /WinMain, or /openWindow. It differs from
-- w32HOpen in that it is triggered /b after a window is opened but before
-- control is returned to your application.
--
-- Typically, code that is run at this point does a setFocus or other
--initialization..
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HClose
--/desc A /Window is closed.
--/i parms = {}
--
-- This typically occurs via /closeWindow, although the user can select
-- the /i close control on the window as well.
--
-- Closing a window does not actually destroy it (unless it is the
-- main window; the window is merely hidden. Refer to /closeWindow for
-- more details.
--
-- If the handler chain sets the return value using /returnValue() with a non-zero parameter,
-- win32lib aborts the Close operation, as if it hadn't been invoked. In this
-- way it is possible to do a conditional close.
--
-- This event is only triggered for a /Window.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HDestroy
--/desc The control is about to be destroyed.
-- /i parms = {}
--
-- This is triggered when /destroy() has been called and before the control
-- is actually destroyed. It is designed for the application to perform any
-- cleaning up that might be required.
--
-- If the event handler return -1, then the control is not destroyed. This
-- enables the application to prevent a control from being destroyed.
--
-- /b Note, when the main window is closed, the /destroy routine is called
-- automatically as well.
--
--/code
--  procedure onDestroy_MsgWnd(integer self, integer event, sequence parms)
--     -- Don't allow it to go until the messages have been
--     -- acknowledged by the operator.
--     if vMsgAcknowledged = w32False then
--        returnValue(-1)
--     end if
--  end procedure
--  setHandler(MsgWnd, w32HDestroy, routine_id("onDestroy_MsgWnd"))
--
--/endcode

-----------------------------------------------------------------------------
--/topic Events
--/const w32HTimer
--/desc A timer is triggered.
-- /i parms = {atom TimerID}
--
-- Timers are clocks that are maintained by Windows, and they trigger these
-- events at a user-specified interval, measured in milliseconds.
--
-- They are created and removed with the calls:
--
-- /li /setTimer( window, TimerID, milliseconds )
-- /li /killTimer( window, TimerID )
--
-- A timer is not treated as an actual control. Rather, the event is sent
-- to the window that the timer is associated with.
--

-----------------------------------------------------------------------------
--/topic Events
--/const w32HPaint
--/desc A portion or all of a /Window needs to be redrawn.
-- /i parms = {atom x1, atom y1, atom  x2, atom  y2}
--
-- The parameters indicate the portion of the window that needs
-- to be updated.
--
-- Not only does {x1,y1,x2,y2} define the area that needs to be redrawn,
-- Windows restricts your application to only being able to draw in those
-- areas! If your application tries to write outside this rectangle on an
-- paint event, nothing will be drawn there.
--
-- Since Windows expects you application to be able to redraw any part
-- of the application's window when responding to an paint event, this
-- means that the paint routine must know how to render any part of the
-- window.
--
-- For programs without any graphics and text drawn on the window, there
-- is no problem - since there are no graphics, there is nothing to update.
--
-- If the application is fairly lightweight (such as a tic-tac-toe game),
-- you simply choose to ignore the parameters passed to your paint handler,
-- and redraw the entire window with each paint event.
--
-- If there is sufficient graphics to make the task of repainting the
-- window complex, the best approach is probably to do double-buffering
-- with a /Pixmap.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HDragAndDrop
--/desc Something has been dragged onto the control or window.
-- /i parms = { integer id, sequence data }
--
-- This is triggered by the user dragging and dropping a file or a /ListView
-- or /TreeView item onto a control or window. /n
--
-- If /i id is zero, then windows is dropping one or more files onto the
-- control or window.  In this case, the handler is called multiple times: /n
-- In the first call, /i data contains one integer. This is the number of
-- files about to be passed to your handler routine. /n
-- Then your handler routine is called once per file being passed, /i data being
-- the named of the passed file. If it returns a
-- nonzero value, the dropping stops with this file./n
-- The final call to the handler is when /i data is an empty sequence. This
-- signifies that no more files will be passed.
--
-- For example, the following code adds the name of the files to TheList.
--
--/code
--      integer vFileCount
--      procedure dropped( integer self, integer event, sequence parms )
--          if parms[1] = 0 then
--              if length(parms[2]) = 1 then
--                  -- Opening call, the file count.
--                  /setEnable(actionButton, w32False)
--                  eraseItems(TheList)
--                  vFileCount = parms[2]
--
--              elsif length(parms[2]) = 0 then
--                  -- Final call.
--                  /setEnable(actionButton, w32True)
--
--              else
--                  -- add the file name to the list
--                  /addItem( TheList, parms[2] )
--              end if
--          end if
--      end procedure
--      setHandler(TheList, w32HDragAndDrop, routine_id("dropped"))
--/endcode
--
-- If /i id is not zero, then it is the Win32Lib id of the control from
-- which items have been dragged.  The second parameter is a sequence of the
-- item id's. Since both the source and the destination are notified,
-- there is a third parameter, 1 for the destination and 0 for the source.

-----------------------------------------------------------------------------
--/topic Events
--/const w32HEvent
--/desc An event (any type) has occured.
-- /i parms = { atom winmsg, atom wParam, atom lParam }
--
-- Before the events are processed by any of the trap routines or
-- default Windows routines, the w32HEvent is triggered.
--
-- If you want to skip the default Windows processing of the /i winmsg,
-- pass a value to the /returnValue() routine.

--/topic Events
--/const w32HAfterEvent
--/desc Occurs after normal Windows processing of an event (any type).
-- /i parms = { atom winmsg, atom wParam, atom lParam, atom lWinReturn }
--
-- After the message is processed by the Windows, Win32lib, and any event
-- handlers, this is triggered.

--/topic Events
--/const w32HKeyboard
--/desc Occurs when keys are held down and about to be released.
-- /i params = {virtual_codes,extended_flags,scan_codes,repeat_count,shifts} where:
--/li virtual_codes is the list of virtual key codes for keys held
--/li extended_flags is a sequence of 1's and 0's. A key has 1 if it is extended (right shift, grey key,...)
--/li scan_codes is the corresponding list of keyboard scan codes;
--/li repeat_counts is the sequence of repeat counts for the keys
--
-- /b Note: this event is not supported by the onXXX[] routines.

global constant
    w32CHG_Add = next_number("w32HChange"),
    w32CHG_Chg = next_number("w32HChange"),
    w32CHG_Del = next_number("w32HChange"),
    w32CHG_Sel = next_number("w32HChange")

global constant
-- open file name common dialog
    OFN_READONLY = #1,
    OFN_OVERWRITEPROMPT = #2,
    OFN_HIDEREADONLY = #4,
    OFN_NOCHANGEDIR = #8,
    OFN_SHOWHELP = #10,
    OFN_ENABLEHOOK = #20,
    OFN_ENABLETEMPLATE = #40,
    OFN_ENABLETEMPLATEHANDLE = #80,
    OFN_NOVALIDATE = #100,
    OFN_ALLOWMULTISELECT = #200,
    OFN_EXTENSIONDIFFERENT = #400,
    OFN_PATHMUSTEXIST = #800,
    OFN_FILEMUSTEXIST = #1000,
    OFN_CREATEPROMPT = #2000,
    OFN_SHAREAWARE = #4000,
    OFN_NOREADONLYRETURN = #8000,
    OFN_NOTESTFILECREATE = #10000,
    OFN_NONETWORKBUTTON = #20000,
    OFN_NOLONGNAMES = #40000,                      --  force no long names for 4.x modules
    OFN_EXPLORER = #80000,                         --  new look commdlg
    OFN_NODEREFERENCELINKS = #100000,
    OFN_LONGNAMES = #200000,                       --  force long names for 3.x modules

    OFN_SHAREFALLTHROUGH = 2,
    OFN_SHARENOWARN = 1,
    OFN_SHAREWARN = 0,

    FILE_ATTRIBUTE_READONLY             = #00000001,
    FILE_ATTRIBUTE_HIDDEN               = #00000002,
    FILE_ATTRIBUTE_SYSTEM               = #00000004,
    FILE_ATTRIBUTE_DIRECTORY            = #00000010,
    FILE_ATTRIBUTE_ARCHIVE              = #00000020,
    FILE_ATTRIBUTE_DEVICE               = #00000040,
    FILE_ATTRIBUTE_NORMAL               = #00000080,
    FILE_ATTRIBUTE_TEMPORARY            = #00000100,
    FILE_ATTRIBUTE_SPARSE_FILE          = #00000200,
    FILE_ATTRIBUTE_REPARSE_POINT        = #00000400,
    FILE_ATTRIBUTE_COMPRESSED           = #00000800,
    FILE_ATTRIBUTE_OFFLINE              = #00001000,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = #00002000,
    FILE_ATTRIBUTE_ENCRYPTED            = #00004000


global constant
-----------------------------------------------------------------------------
    -- Flags for BrowseForFolder
    BIF_RETURNONLYFSDIRS   = #0001, -- For finding a folder to start document searching
    BIF_DONTGOBELOWDOMAIN  = #0002, -- For starting the Find Computer
    BIF_STATUSTEXT         = #0004, -- Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                    -- this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                    -- rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
                                    -- all three lines of text.
    BIF_RETURNFSANCESTORS  = #0008,
    BIF_EDITBOX            = #0010, -- Add an editbox to the dialog
    BIF_VALIDATE           = #0020, -- insist on valid result (or CANCEL)

    BIF_NEWDIALOGSTYLE     = #0040, -- Use the new dialog layout with the ability to resize
                                    -- Caller needs to call OleInitialize() before using this API

    BIF_USENEWUI           = #0050, -- (BIF_NEWDIALOGSTYLE | BIF_EDITBOX)

    BIF_BROWSEINCLUDEURLS  = #0080, -- Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)

    BIF_BROWSEFORCOMPUTER  = #1000, -- Browsing for Computers.
    BIF_BROWSEFORPRINTER   = #2000, -- Browsing for Printers
    BIF_BROWSEINCLUDEFILES = #4000, -- Browsing for Everything
    BIF_SHAREABLE          = #8000, -- sharable resources displayed (remote shares, requires BIF_USENEWUI)

    -- Messages FROM BrowseForFolder
    BFFM_INITIALIZED       = 1,
    BFFM_SELCHANGED        = 2,
    BFFM_VALIDATEFAILEDA   = 3,   -- lParam:szPath ret:1(cont),0(EndDialog)
    BFFM_VALIDATEFAILEDW   = 4,   -- lParam:wzPath ret:1(cont),0(EndDialog)

    -- Message TO BrowseForFolder
    BFFM_SETSTATUSTEXTA    = (WM_USER + 100),
    BFFM_ENABLEOK          = (WM_USER + 101),
    BFFM_SETSELECTIONA     = (WM_USER + 102),
    BFFM_SETSELECTIONW     = (WM_USER + 103),
    BFFM_SETSTATUSTEXTW    = (WM_USER + 104),
    BFFM_SETSTATUSTEXT     = BFFM_SETSTATUSTEXTA,
    BFFM_SETSELECTION      = BFFM_SETSELECTIONA,
    BFFM_VALIDATEFAILED    = BFFM_VALIDATEFAILEDA

global constant
    SFGAO_CANCOPY          = #00000001,     -- objects can be copied
    SFGAO_CANMOVE          = #00000002,     -- objects can be moved
    SFGAO_CANLINK          = #00000004,     -- objects can be linked
    SFGAO_CANRENAME        = #00000010,     -- Objects can be renamed
    SFGAO_CANDELETE        = #00000020,     -- Objects can be deleted
    SFGAO_HASPROPSHEET     = #00000040,     -- Objects have property sheets
    SFGAO_DROPTARGET       = #00000100,     -- Objects are drop target
    SFGAO_CAPABILITYMASK   = #00000177,
    SFGAO_LINK             = #00010000,     -- Shortcut (link)
    SFGAO_SHARE            = #00020000,     -- shared
    SFGAO_READONLY         = #00040000,     -- read-only
    SFGAO_GHOSTED          = #00080000,     -- ghosted icon
    SFGAO_HIDDEN           = #00080000,     -- hidden object
    SFGAO_DISPLAYATTRMASK  = #000F0000,
    SFGAO_FILESYSANCESTOR  = #10000000,     -- It contains file system folder
    SFGAO_FOLDER           = #20000000,     -- a folder.
    SFGAO_FILESYSTEM       = #40000000,     -- is a file system thing (file/folder/root)
    SFGAO_HASSUBFOLDER     = #80000000,     -- Expandable in the map pane
    SFGAO_CONTENTSMASK     = #80000000,
    SFGAO_VALIDATE         = #01000000,     -- invalidate cached information
    SFGAO_REMOVABLE        = #02000000,     -- is this removeable media?
    SFGAO_COMPRESSED       = #04000000,     -- Object is compressed (use alt color)
    SFGAO_BROWSABLE        = #08000000,     -- is in-place browsable
    SFGAO_NONENUMERATED    = #00100000,     -- is a non-enumerated object
    SFGAO_NEWCONTENT       = #00200000,     -- should show bold in explorer tree
    SFGAO_CANMONIKER       = #00400000      -- can create monikers for its objects

global constant
     SHGFI_LARGEICON         = #000000000, -- get large icon
     SHGFI_SMALLICON         = #000000001, -- get small icon
     SHGFI_OPENICON          = #000000002, -- get open icon
     SHGFI_SHELLICONSIZE     = #000000004, -- get shell size icon
     SHGFI_PIDL              = #000000008, -- pszPath is a pidl
     SHGFI_USEFILEATTRIBUTES = #000000010, -- use passed dwFileAttribute
     SHGFI_ADDOVERLAYS       = #000000020, -- apply the appropriate overlays
     SHGFI_OVERLAYINDEX      = #000000040, -- Get the index of the overlay
     SHGFI_ICON              = #000000100, -- get icon
     SHGFI_DISPLAYNAME       = #000000200, -- get display name
     SHGFI_TYPENAME          = #000000400, -- get type name
     SHGFI_ATTRIBUTES        = #000000800, -- get attributes
     SHGFI_ICONLOCATION      = #000001000, -- get icon location
     SHGFI_EXETYPE           = #000002000, -- return exe type
     SHGFI_SYSICONINDEX      = #000004000, -- get system icon index
     SHGFI_LINKOVERLAY       = #000008000, -- put a link overlay on icon
     SHGFI_SELECTED          = #000010000, -- show icon in selected state
     SHGFI_ATTR_SPECIFIED    = #000020000  -- get only specified attributes

-----------------------------------------------------------------------------
-- ShellExecute error codes
global constant SE_ERR_FNF             = 2,       -- file not found
                SE_ERR_PNF             = 3,       -- path not found
                SE_ERR_ACCESSDENIED    = 5,       -- access denied
                SE_ERR_OOM             = 8,       -- out of memory
                SE_ERR_SHARE           = 26,
                SE_ERR_ASSOCINCOMPLETE = 27,
                SE_ERR_DDETIMEOUT      = 28,
                SE_ERR_DDEFAIL         = 29,
                SE_ERR_DDEBUSY         = 30,
                SE_ERR_NOASSOC         = 31,
                SE_ERR_DLLNOTFOUND     = 32

global constant
-- default printer
    PRINTER_ENUM_DEFAULT   = 1,
    PRINTER_ENUM_LOCAL     = 2

-- setPrintJobProperty() constants
global constant
    JP_FromPage           =1,
    JP_ToPage             =2,
    JP_MinPage            =3,
    JP_MaxPage            =4,
    JP_Copies             =5,
    JP_PrintFlags         =6,
    JP_Orientation        =7,
    JP_SetupFlags         =8,
    JP_PaperSize          =9,
    JP_PaperBin           =10,
    JP_Collate            =11,
    JP_Margins            =12

global constant
    -- pen attributes
    PenColor        = 1,
    PenStyle        = 2,
    PenROP2         = 3,
    PenBkMode       = 4,
    PenWidth        = 5,
    PenBkColor      = 6,
    PenBrushColor   = 7

-- options.e

--/topic Miscellaneous
--/func getOpt(sequence pSource, sequence pCategory, sequence pKey, object pDefault)
--/desc Retrieves the data associated with /i pKey in the file /i pSource under the group /i pCategory
--/ret OBJECT: The associtated data.
--/i pSource is the name of a text file in which the data can be found. /n
--/i pCategory is the name of a category, or grouping, found in /i pSource. The categories are coded
-- in the file in the form /b("[" category "]") as the only thing in a line. /n
--/i pKey is the key that will be searched for in the category.  If found the associated string
-- will be returned otherwise /i pDefault is returned. /n
--/i pDefault is a string to be returned if the key is not found in the file.
--
--/b Note that the category and key are not case sensitive.
--
--Any text that begins with "->" is ignored to the end of line. This is how you add comments to the source file.
--
--If the associated data can be converted to a Euphoria atom it will be, otherwise it
-- will be returned as a text string. With the exception that the strings "yes", "true", "on"
-- will be returned as the integer 1 (one), and the strings "no", "false", "off" will be returned
-- as the integer 0 (zero). If you actually need any of these strings to be returned verbatim
-- then enclose them in quotes in the file.
--
--If the associated text contains "\n" or "\t" these are replaced with 10 (newline) and 9 (tab) respectively.
--
--The associated data can span multiple lines. This done by simply having the continuation lines
-- begin in column 2 or greater.
--
--Example: /n
-- Assume we have an options file, App.Ini, containing the following lines ...
--/code
--[COMMS]
--Baud=9600
--Stop=1
--Bits=7
--Parity=Odd
--AutoConnect=yes
--ACKResponse="yes"
--Welcome= "Application V1.0\n"
--         "Welcome to my application.\n"
--         "(c) 2004 HardMacro"
--
--[COLOR]
--Background = White
--Text = Black
--Highlight = Blue
--Selection = Pink
--
--[LIMITS]
--Files = 10
--DBSize = 1024 -> MB
--/endcode
--
-- then we could call this routine ...
--
--/code
--      object lRes
--      lRes = getOpt("App.Ini", "color", "text", "Gray") -- Returns "Black"
--      lRes = getOpt("App.Ini", "comms", "autoconnect", "no") -- Returns 1
--      lRes = getOpt("App.Ini", "comms", "ACKResponse", "none") -- Returns "yes"
--      lRes = getOpt("App.Ini", "comms", "Parity", "even") -- Returns "Odd"
--      lRes = getOpt("App.Ini", "comms", "CRC", "yes") -- Returns "yes"
--      lRes = getOpt("App.Ini", "User", "ID", -1) -- Returns -1
--      lRes = getOpt("App.Ini", "limits", "files", -1) -- Returns 10
--      lRes = getOpt("App.Ini", "limits", "connections", 4) -- Returns 4
--      lRes = getOpt("App.Ini", "limits", "DBSize", 16) -- Returns 1024
--      lRes = getOpt("App.Ini", "comms", "welcome", "") -- Returns ...
--Application V1.0
--Welcome to my application.
--(c) 2004 HardMacro
--/endcode

global function getOpt(sequence pSource, sequence pCategory, sequence pKey, object pDefault)
    integer lFH
    object lData
    sequence lKey
    sequence lOptData
    integer lInCategory
    integer lPos


    lInCategory = 0

    lData = pDefault
    lFH = open(pSource, "r")
    if lFH = -1 then
        if match(".ini", lower(pSource)) = 0 then
            pSource &= ".ini"
        end if
        lFH = open(pSource, "r")
    end if

    if lFH = -1 then
        return lData
    end if

    pCategory = '[' & lower(w32trim(pCategory)) & ']'
    pKey = lower(w32trim(pKey))
    while w32True do
        lData = gets(lFH)
        if atom(lData) then
            close(lFH)
            return pDefault
        end if

        lData = w32trim(lData)
        -- Strip off any comment text
        lPos = match("->", lData)
        if lPos > 0 then
            if lPos = 1 or find(lData[lPos-1], " \n\t") != 0 then
                lData = w32trim(lData[1..lPos-1])
            end if
        end if
        if length(lData) > 0 then
            if lInCategory then
                if lData[1] = '[' then
                    close(lFH)
                    return pDefault
                end if

                lPos = find('=', lData)
                if lPos then
                    lKey = lower(w32trim(lData[1..lPos-1]))
                    if equal(lKey, pKey) then
                        lOptData = lData[lPos+1..length(lData)]
                        if length(lOptData) < 2 or lOptData[1] != '"' or lOptData[$] != '"' then
                            lOptData = w32trim(lOptData)
                        end if
                        -- Check for continuation lines...

                        lData = gets(lFH)
                        while sequence(lData) do
                            if find(lData[1], " \t\n") = 0 then
                                exit
                            end if
                            -- Check for comments on the line.
                            lPos = match("->", lData)
                            if lPos = 1 then
                                -- Just ignore the line
                            else
                                if lPos > 0 then
                                    if find(lData[lPos-1], " \t") != 0 then
                                        -- strip off comment.
                                        lData = w32trim(lData[1..lPos-2])
                                    end if
                                end if
                                lData = w32trim(lData)
                                if length(lData) = 0 then
                                    -- A totally blank line is end of continuation too.
                                    exit
                                end if

                                -- join this to previous text for this key.
                                lOptData &= lData
                            end if
                            lData = gets(lFH)
                        end while
                        exit
                    end if
                end if
            else
                if match(pCategory, lower(lData)) = 1 then
                   lInCategory = 1
                end if
            end if
        end if

    end while

    close(lFH)

    if length(lOptData) >= 2 and lOptData[1] = '"' and lOptData[$] = '"' then
        lData = lOptData[2..length(lOptData)-1]
    else
        lData = w32TextToNumber({lOptData, w32True})
        if lData[2] = 0 then
            lData = lData[1]
        else
            lData = lOptData
            lOptData = lower(lData)
            if find(lOptData,{"true","yes","on"}) then
                lData = w32True
            elsif find(lOptData,{"false","no","off"}) then
                lData = w32False
            end if
        end if
    end if

    if sequence(lData) then
        lData = w32replaceItem(lData, "\\n", '\n')
        lData = w32replaceItem(lData, "\\t", '\t')
    end if
    return lData
end function

-- rttext.e

sequence vUserLang vUserLang = "english"
sequence vContainer vContainer = "msgs.ini"

--/topic Miscellaneous
--/func setUserLanguage(object pNew)
--/desc Defines or returns the language category that is used by /UseText
--/ret SEQUENCE: The previous setting.
--Initially the language is set to "english". You would use this if the messages file contained
-- other language catgories.
--
--If /i pNew is a sequence, it is the category that will be searched by /UseText in the messages file.
--Otherwise, the current language string will be returned.
--
--Example:
--/code
--  -- Get current setting
--  sequence lCurrent
--  lCurrent = setUserLanguage( 0 ) -- Any non-sequence parameter value will do.
--
--  sequence lOld
--  lOld = setUserLanguage( "thai" )
--  -- Note that the category can be anything.
--  lOld = setUserLanguage( "geek jargon" )
--/endcode

------------------------------------------------
global function setUserLanguage(object pNew)
------------------------------------------------
    sequence lOld

    lOld = vUserLang
    if sequence(pNew) then
        vUserLang = pNew
    end if
    return lOld
end function

--/topic Miscellaneous
--/func setContainer(object pNew)
--/desc Defines the message file that is used by /Usetext
--/ret SEQUENCE: The previous setting.
--Initially the file name is set to "msgs.ini". You would use this if the messages file containing
-- the text has a different name or is on a different path.
--
--If /i pNew is a sequence, it is the name and path of the file that will be searched by /UseText.
-- Otherwise, the current file name and path will be returned.
--
--Example:
--/code
--  -- Get current value
--  sequence lCurrent
--  lCurrent = setContainer( 0 ) -- Any non-sequence parameter value will do.
--
--  sequence lOld
--  lOld = setContainer( "Application\\Data\\Message.Text" )
--/endcode

------------------------------------------------
global function setContainer(object pNew)
------------------------------------------------
    sequence lOld

    lOld = vContainer
    if sequence(pNew) then
        vContainer = pNew
    end if
    return lOld
end function

--/topic Miscellaneous
--/func UseText(object pTextCode, sequence pDefault)
--/desc Fetches the text associated with /i pTextCode
--/ret SEQUENCE: The text.
--This searches the current messages file (see /setContainer ) for the text code
-- in the current language category (see /setUserLanguage ) and when found returns the
-- associated text string.
--
-- If no associated text could be found and no default was supplied, it returns the value of /i pTextCode enclosed
-- with /i MSG[ and /i ].
--
--Example: /n
--Assume you have the following messages file ...
--/code
--[english]
--0 = Okay
--1 = File not found
--2 = Record not found
--3 = Record already exists
--9 = Internal error.
--UM = Unit of Measure
--KG = Kilogram
--/endcode
--
--Then we can call this function thus ...
--/code
--      sequence lText
--      lText = UseText(0, "") -- returns "Okay"
--      lText = UseText(9, "") -- returns "Internal error."
--      lText = UseText("KG", "kilo") -- returns "Kilogram"
--      lText = UseText("KM", "") -- returns "MSG[KM]"
--/endcode

------------------------------------------------
global function UseText(object pTextCode, sequence pDefault)
------------------------------------------------
    sequence lTextCode
    sequence lFoundText

    if atom(pTextCode) then
        lTextCode = sprintf("%g", pTextCode)
    else
        lTextCode = pTextCode
    end if

    lFoundText = getOpt(vContainer, vUserLang, lTextCode, pDefault)
    if length(lFoundText) = 0 then
        lFoundText = "MSG[" & lTextCode & "]"
    end if

    return lFoundText
end function

--/topic Miscellaneous
--/func FormatMsg(object pTextCode, sequence pData)
--/desc Fetches the format template associated with /i pTextCode and applies /i pData to it.
--/ret SEQUENCE: The formatted text.
--This searches the current messages file (see /setContainer ) for the text code
-- in the current language category (see /setUserLanguage ) and when found
-- the function uses it as a template with formatting codes in it.
--
--/i pTextCode is either the code (an integer) to search for templates in the messages file, or
-- a message template itself. /n
--/i pData is either a single string or a sequence of strings. /n
--
--A message template can contain zero or more place-holder tokens. Each token is replaced by its
-- respective value from the /i pData to form the final output. A token is either a two-character
-- one in the form of '%N' where 'N' is a digit from 1 to 9, or a token in the form '%{X}' where
-- 'X'
--
--Example: /n
--Assume you have the following messages file ...
--/code
--[english]
--1 = File '%{NAME}' not found in folder '%{PATH}'
--2 = Record ID '%1' not found
--3 = Record ID '%1' already exists
--9 = Internal error: Code '%1'.
--5001 = Unknown error code: '%1'
--/endcode
--
--Then we can call this function thus ...
--/code
--      sequence lText
--      lText = FormatMsg(1, {"PATH=c:\\temp\\", "NAME=link.opt"} ) -- returns "File 'link.opt' not found in folder 'c:\temp\'"
--      lText = FormatMsg(3, "djp") -- returns "Record ID 'djp' already exists"
--      lText = FormatMsg(17, "Some Text") -- returns "Unknown error code: Msg#17, Some Text"
--      lText = FormatMsg("%1 %3, %2", {"Mr", "Derek", "Parnell"}) -- returns "Mr Parnell, Derek"
--/endcode

------------------------------------------------
global function FormatMsg(object pTextCode, sequence pData)
------------------------------------------------
    sequence lMsg
    sequence lToken
    integer  lPos
    sequence lKey
    sequence lVal

    if atom(pTextCode) then
        lMsg = UseText(pTextCode, {""})
        if equal(lMsg, {""}) then
            lMsg = UseText(5001, "Msg#" & sprintf("%g", pTextCode) & ", " & w32to_string(pData))
        end if
    else
        lMsg = pTextCode
    end if

    if w32string(pData) then
        pData = { pData }
    end if

    for i = 1 to length(pData) do
        lPos = find('=', pData[i])
        if lPos > 0 then
            lKey = w32trim(pData[i][1 .. lPos-1])
            lVal = w32trim(pData[i][lPos+1 .. $])
            lToken = "%{" & lKey & "}"
            if match(lToken, lMsg) > 0 then
                lMsg = w32replaceItem( lMsg, lToken, lVal)
                pData[i] = 0 -- Mark as used.
            end if
        end if
    end for


    for i = 1 to length(pData) do
        if i < 10 and sequence(pData[i]) then
            lToken = sprintf("%%%d", i)
            if match(lToken, lMsg) > 0 then
                lMsg = w32replaceItem( lMsg, lToken, pData[i])
                pData[i] = 0 -- Mark as used.
            end if
        end if

        if i >= 10 or sequence(pData[i]) then
            lToken = sprintf("%%{%d}", i)
            if match(lToken, lMsg) > 0 then
                lMsg = w32replaceItem( lMsg, lToken, pData[i])
                pData[i] = 0
            end if
        end if
    end for


    return lMsg
end function

