--  PROGRAM: RunDemos: a Win32Lib Demos Gateway             by Dan Moyer

--  DESCRIPTION:
--  A "Gateway" to the EXAMPLES of programming for Windows with Win32Lib.

--  PURPOSE:
--  Intends to make it easier to use Win32Lib to create Euphoria programs
--  for Windows, by allowing the user to do the following:

-- VERSION HISTORY:  (remove from final distributed version)
-- 57.1 : replaces 52 with 62 in line:
--        limitText(NewDescriptionSLE, 62 - length(fileName))
--        trying to make edit line only hold as much as list will
-- 57.1a  changed : to = in .lst header
--  apparently have to use:
--    VOID = sendMessage(VKList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
--  in conjunction with determined line length in pixels?
--  get line length (in pixels?) of longest line added onOpen
--  57.3a added *.exw to hint for import button
--  57.4 made when no files found to import, don't make new tabfolder

--  57.4z1 is line to work alone in folder, all demos & dat in sub-folder
--  57.4z1c  should have all necessary "InitialDirectory" terms changed to
--           either DemoDirectory or DocsDirectory, as appropriate;
--       also has a redirect include file to get FindFiles.ew from Demo dir
--  57.4z1i  must have been fixing bugs? not sure; also added buttons
--           to allow download from web site of tut & ide.
--  VERSIONS WITH "x" IN FRONT ARE "WORK FROM BASE FOLDER",
--  WITHOUT ANY IMPROVEMENTS.
--  (another line, with "z" *in front* do have further improvements)
--  x57x4z2   same as above, but removed download button, will add later.
--  x57x4z2a  fixed bug: couldn't use "save as" in wordpad;
--            had retained adding "\\" to end of dir name before file name
--            when changed "initDir" to "DemoDirectory"; removed "\\".
--


--  FEATURES:
--  see a LIST of all Win32Lib EXAMPLES, plus DESCRIPTIONS,
--  RUN various Win32Lib EXAMPLES, and VIEW and COPY their source code,
--  READ the Euphoria and Win32Lib MANUALS and a Win32Lib FAQ,
--  ACCESS a Win32Lib TUTORIAL, and
--  RUN the IDE to CREATE PROGRAMS by "point & click" on control icons, and
--  ADD, REMOVE, MOVE DEMOS & change their DESCRIPTIONS,
--  IMPORT groups of demos, ADD & REMOVE CATEGORIES of demos, and
--  see VIRTUAL KEY definitions and EVENTS, CONTROLS, and COLORS constants, --  as well as MOUSE EVENTS,
--  COPY any of the listed definitions or constants to CLIPBOARD by
--  double-clicking on them,
--  or optionally copy events & controls TEMPLATES to clipboard similarly.

--  All from this ONE "Gateway" program.
---------------------------------------------------------------------------

constant Version = "1.2",
         CreationDate = "April 8, 2004"

include win32lib.ew
include groupadv.ew

sequence vTextViewer
vTextViewer = "ed.bat"

-- Original by Dan Moyer

-------------------------------------------------------------------------
--  VARIABLE NAMING CONVENTION:  vars local to a routine start with
--  lower case letter, those local to whole program start with upper case
--  (except for maybe some older useage, maybe not all be changed, &
--   constant xLB_SETHORIZONTALEXTENT, named to prevent conflict?,
--   and some some routines used here created by other people).
------------------------------------------------------------------------

--  ZIP FILE CONTENTS:
--     RunDemos.exw -- this Win32Lib Examples Gateway program
--     FindFile.ew  -- an include with functions to find Tutorial versions
--	 Wstyles.exw  -- demo shows various Window styles
--     ReadMe.txt   -- some information about Win32Lib
--     Colors.dat   -- dat file for pre-defined colors
--     Controls.dat -- dat file for controls
--     Mouse.dat    -- dat file for mouse events
--     W32H.dat     -- dat file for w32H style event constants
--     W32FAQ.htm   -- a Frequently Asked Questions file


--  Note: FindFile.ew is a NEW version (0.15) of "FindFNam.ew", to allow
--        STOPPING a search for a filename in mid-search (as Derek did).

--  code originally generated by Win32Lib IDE v0.8, then hand modified
------------------------------------------------------------------------

--  NEW FEATURES:
--  version 0.57 adds the ability for the user to easily add & remove
--  both demos & categories and to change the description of the demos,
--  and to move demos within & between categories.
--
--  It also allows importing GROUPS of demos, either from the
--  initial directory, or from a user specified one, and allows the user
--  to specifiy a name for the category they are imported to,
--  or uses a default name based on the directory they're from;
--  filters can be optionally be applied to the importing, so that
--  any combination of: any demos already present, or all  known non-demos,
--  or any numbered examples ("ex#.exw"), are not imported.
--
--  It also allows the same "auto/user" locating of IDE as of Tutorial,
--  and stores both in a file, "TutAndIde.dat" which is created if needed.
--
--  The "add" demos & categories functions can be activated either
--  by clicking on buttons, or through key presses:
--  <insert> a demo into the list, <ctrl><insert> make a new category;
--  the "remove" demos & categories functions are activated by key presses:
--  <delete> a demo from the list, <ctrl><delete> a category;
--  and moving a demo in a category is done by <shift> (left/right) arrows,
--  while moving a demo between categories uses <shift> (up/down) arrows.
--
--  There is a now a help system, working from a listbox of topics.
--
--  And there is a "Constants" button which shows a listbox of various
--  useful constants: "Virtual Keys", the new "w32H events", the older
--  "onSomeEvent", "Colors", "Controls", and "Mouse Events".
--  Double clicking on any constant will automatically copy it to the
--  clipboard, for easy pasting into a program. And, for the event and
--  control constants there are options to have templates for their use
--  automatically copied as well.



--------------------------------------------------------------------------

--  PREVIOUS VERSIONS FEATURES:

--  version 0.56, unreleased, was essentially as above, but did not
--  have the "Constants" button & copy features, and it had the
--  "Virtual Key" constants inside the help system.

--  version 0.55 just adds info about right click in tooltip for Tutorial

--  version 0.54 is for running under Win32Lib 0.55, and new features
--  include:  data structures have been created & used to replace
--  multiple logic structures; a single routine handles mouse clicks in
--  all the lists; and a disk file is used to hold the example names
--  and definitions for the data structures, for ease of maintenence, as
--  suggested and mostly provided by Derek Parnell.

-------------------------------------------------------------------------
--  BUGS:

-- "FIXED":  after make move demo down (I think), it causes an error
--           on move mouse (in 9a or 9b; NOT error in 9, I think).
--        "fixed" by "returning" if mouse move, not sure what was erroring

-- in move demo between categories,
-- can't get it to put focus on moved demo if had focus before moved


-- "FIXED":  wouldn't "clear" clipboard by setting "" to it,
--           HAD TO DUMMY IT UP TO  (used " " instead)

---------------------------------------------------------------------------

--  TODO:
--  limit on length of description entry isn't working, may be Win32Lib 57?

--  FUTURE POSSIBILITIES:
--  maybe sometime make it able to list other than just .exw,
--  by storing the extent instead of discarding & replacing it,
--  so other "templates" could be accessed?

--  ability to MERGE additional/alternative .lst lists.

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--                     BEGIN CODE
--------------------------------------------------------------------------
--------------------------------------------------------------------------


-- GLOBAL FLAG TO ALLOW STOPPING AUTO SEARCH FOR TUTORIAL OR IDE:
global integer StopOrNot
StopOrNot = 0 -- 0 means continue the search, 1 will stop it
--  this operates in a function from "FindFile.ew"
--------------------------------------------------------------------------
sequence CmdLine
sequence BaseDirectory, DemoDirectory, DocsDirectory

--------------------------------------------------------------------------
-- INCLUDES:

include std/dll.e
include std/machine.e
include std/sequence.e
include std/os.e
include std/get.e
include std/filesys.e
include std/text.e
include findfile.ew -- used to find where Win32Lib Tutorials are
include std/sort.e -- for sorting results of dir search for Tutorials
include std/win32/msgbox.e

--include print.e -- for testing structured variables by showing them
--------------------------------------------------------------------------
-- FIND WHERE EUPHORIA STUFF IS ON DRIVE:
object EuDir    -- EUDIR environment variable
EuDir = getenv("EUDIR")

------------------------------------------------------------------------
-- GET CURRENT DIRECTORY, TO USE AS DEFAULT FOR RUN/SHOW EXAMPLES
--     AND FOR JUMPS TO TUTORIAL & IDE:
sequence  InitialDirectory
InitialDirectory = current_dir()  -- mostly not used now, mostly replaced
                                  -- by DemoDirectory & DocsDirectory
------------------------------------------------------------------------
-- KNOWN NON-DEMOS, TO ALLOW NOT LOADING FROM AN IMPORT CHOICE:
sequence KnownNonDemos
KnownNonDemos = {"CONV055","EUCOMPRESS","MAKEDOC","RUNDEMOS","RUNTHIS","WDEMOS"}
-------------------------------------------------------------------------
constant xLB_SETHORIZONTALEXTENT = 404  -- used to display Key Constants
object VOID                             -- in VKList with hScroll
------------------------------------------------------------------------
object WhichButton -- IDE or Tutorial right clicked, find where is
------------------------------------------------------------------------
-- SET DEFAULT PATH AND FILE NAME FOR TUTORIAL, and for IDE:
sequence TutorialPathName,TutorialFileName

TutorialPathName = ""
TutorialFileName = "wintutor.exw"

sequence TutorialsAndPaths
TutorialsAndPaths = {}
--------------------------
sequence IdePathName, IdeFileName
IdePathName = ""
IdeFileName = "IDE.EXW"  --

sequence IDEsAndPaths
IDEsAndPaths = {}

------------------------------------------------------------------------

-- PROCEDURE TO GET PATH FOR THE TUTORIAL and for the IDE FROM DAT FILE:

integer AfileHandle  -- to use with reading/writing to .dat file
object DatLine


procedure InitPaths()
integer indx

CmdLine = command_line()
BaseDirectory = CmdLine[2]
if BaseDirectory[2] != ':' and BaseDirectory[1] != '\\' then
    BaseDirectory = current_dir() & '\\' & BaseDirectory
end if
BaseDirectory = reverse(lower(BaseDirectory))
indx = 1
while indx < length(BaseDirectory)-6 do
    if equal(BaseDirectory[indx..indx+5],"\\omed\\") then
        BaseDirectory = BaseDirectory[indx+6 ..length(BaseDirectory)]
        exit
    end if
    indx += 1
end while
BaseDirectory = reverse(BaseDirectory)
DemoDirectory = BaseDirectory & '\\' & "Demo\\"
DocsDirectory = BaseDirectory & '\\' & "Docs\\"

end procedure

procedure GetTutorialAndWin32LibPath()
-- if there is a RunTutor.dat file, read it for Tutorial path & name:
AfileHandle = open(DemoDirectory & "TutAndIde.dat", "r")
if AfileHandle != -1 then  -- is a file there
  while 1 do -- read file until no more:
   DatLine= gets(AfileHandle) -- reads Tutorial path from file
   -- end of file?
      if atom(DatLine) then
         exit
      end if
   DatLine = DatLine[1..length(DatLine)-1]
   if match("TUTPATH:", DatLine) then
       TutorialPathName = DatLine[9..length(DatLine)]
   elsif match("TUTNAME:", DatLine) then
      TutorialFileName = DatLine[9..length(DatLine)]
   elsif match("IDEPATH:", DatLine) then
      IdePathName = DatLine[9..length(DatLine)]
   elsif match("IDENAME:", DatLine) then
      IdeFileName = DatLine[9..length(DatLine)]
   end if
  end while
   close(AfileHandle)
end if

end procedure
-----------------------------------------------------------------
--  SEE IF THERE IS A "RunTutor.dat" FILE with TUTORIAL
--  FOLDER PATHS IN IT; IF NOT, SEARCH FOR THEM & SAVE IN DAT FILE

InitPaths()
GetTutorialAndWin32LibPath()

-----------------------------------------------------------------------

without warning

constant CR = { 13, 10 } -- carriage return, linefeed

integer SelectedTabFolder  --  used in editing list of demos
sequence DemoName, DemoPath
DemoName = {}
DemoPath = {}
SelectedTabFolder = 0   -- could be a mistake!
integer SelectedDemoIndex
SelectedDemoIndex = 0  -- ?
----------------------------------------------------------------------
-- FOR CENTERING A WINDOW:

function xWinPos(atom width)
  return floor((w32Func(xGetSystemMetrics,{SM_CXFULLSCREEN})/2)-(width/2))
end function

function yWinPos(atom height)
  return floor((w32Func(xGetSystemMetrics,{SM_CYFULLSCREEN})/2)-(height/2))
end function
-----------------------------------------------------------------------
-- FOR CENTERING A BUTTON IN A WINDOW:
-- BUTTON x CENTERING FUNCTION:
function xCenterButtonInWindow( integer button_width, integer aWindow )
sequence  windowPos
integer x, windowWidth

windowPos = getClientRect(aWindow)
windowWidth = windowPos[3] - windowPos[1]

x =  floor( (windowWidth/2) - (button_width/2) )

return x
end function

------------------------------------------------------------------------
-----------------------------------------------------------------------
--  MAIN WINDOW:
global constant MainWindow = create( Window, "RunDemos: a Win32Lib Gateway", 0, Default, Default, 788, 475, 0 )
-------------------------------------------------------------------
-- IMPORT DEMOS WINDOW:
global constant ImportWindow = create( Window, "Import Demos", MainWindow, 10, 10, 312, 380,{ WS_DLGFRAME, WS_SYSMENU} ),



RBinitDir = create( RadioButton, "From Initial Directory", ImportWindow, 10, 180, 200, 20, 0),
RBselDir  = create( RadioButton, "Allow Select a Directory", ImportWindow, 10, 200, 200, 20, 0),
RBinfoLabel = create( LText, "", ImportWindow, 10, 220, 300, 45, 0),

CatInfoLabel = create( LText, "Enter name for category for imported demos" & CR & "default is directory path", ImportWindow, 10, 305, 305, 55, 0),
CatNameSLE  = create( EditText, "", ImportWindow, 10, 280, 290, 25, 0)

setCheck(RBinitDir, w32True)  -- default import is from initial directory
-------------------------------------------------------------------------
-- CONSTANTS WINDOW:
global constant ConstantsWindow = create( Window, "Frequently Used Constants", MainWindow, xWinPos(600), 60, 600, 475, { WS_DLGFRAME, WS_SYSMENU} )--xWinPos(atom width)

-- GROUP TO HOLD RADIO BUTTONS FOR COPY LONG OR SHORT TO CLIPBOARD:
constant
  Group1 = create(GroupAdv, "Copy to clipboard",ConstantsWindow,10, 290, 160, 123 , 0 ),
  Group2 = create(GroupAdv, "Copy to clipboard",ConstantsWindow,10, 290, 160,  93 , 0 )

setUserProperty(Group1, "BorderWidth" , -1)
setUserProperty(Group1, "CaptionBorderColor" , BrightBlue)
setUserProperty(Group1, "CaptionBGColor" , BrightWhite)
setUserProperty(Group2, "BorderWidth" , -1)
setUserProperty(Group2, "CaptionBorderColor" , BrightRed)
setUserProperty(Group2, "CaptionBGColor" , BrightWhite)
  
-- was: 10, 320, 160, 93
-- INFO LABLE FOR GROUP:

-- RADIO BUTTONS FOR COPY LONG OR SHORT TO CLIPBOARD:
constant
  JustConRB   = create(Radio, "Just the Constant",Group1, 10, 30, 140, 30, 0 ),
  FullStateRB = create(Radio, "Event Template",   Group1, 10, 60, 140, 30, 0 ),
  BothStateRB = create(Radio, "Proc and Event",   Group1, 10, 90, 140, 30, 0 ),

  CreateRB    = create(Radio, "Create a control", Group2, 10, 30, 140, 30, 0 ),
  ExtendedRB  = create(Radio, "Extended control", Group2, 10, 60, 140, 30, 0 )


  setCheck(FullStateRB, w32True)
  setCheck(CreateRB, w32True)
  setVisible(Group1, 0)
  setVisible(Group2, 0)

-- FREQUENTLY USED CONSTANTS STUFF:
--   list to hold Frequently Used Constants topics:
constant
  ConTopicsList = create(List, "",ConstantsWindow, 10, 10, 160, 120, 0 )

-- LIST BOX TO HOLD VIRTUAL KEYS LISTING:
global constant VKList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )

-- LIST BOX TO HOLD w32H CONSTANTS:
global constant w32HList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )

-- LIST BOX TO HOLD onEvents CONSTANTS:
--global constant onEventsList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )

-- LIST BOX TO HOLD Colors CONSTANTS:
global constant ColorsList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )

-- LIST BOX TO HOLD Controls CONSTANTS:
global constant ControlsList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )

-- LIST BOX TO HOLD MouseEvents CONSTANTS:
global constant MouseEventsList = createEx( List, "", ConstantsWindow, 185, 10, 400, 400, WS_HSCROLL, 0 )
----------------------------
-- LOAD THE VKLIST:
    sequence lTextSize  -- these two used for scrollbar?
    integer lMaxLineSize
    lMaxLineSize = 0
    integer posVKname
    posVKname = 0
AfileHandle = open(BaseDirectory & "\\include\\w32Keys.e", "r") -- in case it gets renamed to this
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if
     posVKname = match("VK_", DatLine)
     if posVKname > 0 then   -- only put lines with "VK_" into list
        if match("--", DatLine) = 1 then -- allows commented vk lines show
        else
          DatLine = " " & DatLine[posVKname..length(DatLine)]--remove comma
        end if
        addItem(VKList, DatLine)
        if lMaxLineSize < length(DatLine) then
            lMaxLineSize = length(DatLine)
        end if
     end if
   end while
    lTextSize = getTextExtent(VKList, "a")
    lMaxLineSize *= lTextSize[1]
    VOID = sendMessage(VKList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
end if
-----------------------------
-- LOAD THE w32HList:
   sequence W32Hparameters -- used for creating routines template, later
   W32Hparameters = {}
   integer posParam
   posParam = 0
    lMaxLineSize = 0
    integer posw32H
    posw32H = 0
AfileHandle = open(DemoDirectory & "w32H.dat", "r")
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if
     posw32H = match("w32H", DatLine)
   -- only put lines starting with "w32H"  or "proc" into list:
     if posw32H = 1  or match("proc", DatLine)= 1 then
        if posw32H = 1 then  -- look for parameters after "**"
           posParam = match("**", DatLine)
           if posParam then
              W32Hparameters &= {DatLine[posParam + 2..length(DatLine)]}
              DatLine = DatLine[1..posParam -2] -- don't put param in list
           else
              W32Hparameters &= {{}} -- a blank, so index from list works
           end if
        end if

         DatLine = " " & DatLine
         addItem(w32HList, DatLine)
        if lMaxLineSize < length(DatLine) then
            lMaxLineSize = length(DatLine)
        end if
     end if
   end while
    lTextSize = getTextExtent(w32HList, "r")
    lMaxLineSize *= lTextSize[1]
    VOID = sendMessage(w32HList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
end if
--print(1, W32Hparameters)


-----------------------------
-- LOAD THE onEventsList:
 --   sequence lTextSize  -- these two used for scrollbar?
  --  integer lMaxLineSize
--     lMaxLineSize = 0
--     integer posConst, posProc, posFunc
--     posConst = 0
--     posProc = 0
--     posFunc = 0
-- 
-- 
-- AfileHandle = open(DemoDirectory & "onEvents.dat", "r")
-- if AfileHandle != -1 then  -- is a file there
--    while 1 do
--      DatLine= gets(AfileHandle) -- reads line of text from file
--      if atom(DatLine) then
--         exit
--      end if
--      if length(DatLine) > 1 then
--         DatLine = DatLine[1..length(DatLine)-1]
--      end if
--      posConst = match("const", DatLine)
--      posProc = match("proc", DatLine)
--      posFunc = match("func", DatLine)
--      if posConst = 1 or posProc = 1 or posFunc = 1 then
--         if posConst = 1 then
--            -- only put lines starting with "const" into list
--            DatLine = DatLine[posConst + 5..length(DatLine)]
--         elsif posProc = 1 then
--            DatLine = DatLine[posProc + 5..length(DatLine)]
--         elsif posFunc = 1 then
--            DatLine = DatLine[posFunc + 5..length(DatLine)]
--         end if
--         addItem(onEventsList, DatLine)
--         if lMaxLineSize < length(DatLine) then
--             lMaxLineSize = length(DatLine)
--         end if
--      end if
--    end while
--     lTextSize = getTextExtent(onEventsList, "r")
--     lMaxLineSize *= lTextSize[1]
--     VOID = sendMessage(onEventsList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
-- end if
-----------------------------
-- LOAD THE ColorsList:
 --   sequence lTextSize  -- these two used for scrollbar?
  --  integer lMaxLineSize
    lMaxLineSize = 0
    integer posRgb
    posRgb = 0
AfileHandle = open(DemoDirectory & "Colors.dat", "r")
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if
     posRgb = match("rgb", DatLine)
     if posRgb then   -- only put lines containing "rgb" into list
         DatLine =  DatLine[4..length(DatLine)]
         addItem(ColorsList, DatLine)
        if lMaxLineSize < length(DatLine) then
            lMaxLineSize = length(DatLine)
        end if
     end if
   end while
    lTextSize = getTextExtent(ColorsList, "r")
    lMaxLineSize *= lTextSize[1]
    VOID = sendMessage(ColorsList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
end if
-----------------------------
-- LOAD THE ControlsList:
 --   sequence lTextSize  -- these two used for scrollbar?
  --  integer lMaxLineSize
    lMaxLineSize = 0
--    integer posRgb
--    posRgb = 0
AfileHandle = open(DemoDirectory & "Controls.dat", "r")
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if

     if equal(' ', DatLine[1]) then   -- only put lines starting with space
                                     -- into list
         DatLine =  DatLine[4..length(DatLine)]
         addItem(ControlsList, DatLine)
        if lMaxLineSize < length(DatLine) then
            lMaxLineSize = length(DatLine)
        end if
     end if
   end while
    lTextSize = getTextExtent(ControlsList, "r")
    lMaxLineSize *= lTextSize[1]
    VOID = sendMessage(ControlsList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
end if
-----------------------------
-- LOAD THE MouseEventsList:
 --   sequence lTextSize  -- these two used for scrollbar?
  --  integer lMaxLineSize
    lMaxLineSize = 0
--    integer posRgb
--    posRgb = 0
AfileHandle = open(DemoDirectory & "Mouse.dat", "r")
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if
 --    posRgb = match("rgb", DatLine)
     if equal(' ', DatLine[1]) then   -- only put lines starting with space
                                     -- into list
         DatLine =  DatLine[4..length(DatLine)]
         addItem(MouseEventsList, DatLine)
        if lMaxLineSize < length(DatLine) then
            lMaxLineSize = length(DatLine)
        end if
     end if
   end while
    lTextSize = getTextExtent(MouseEventsList, "r")
    lMaxLineSize *= lTextSize[1]
    VOID = sendMessage(MouseEventsList, xLB_SETHORIZONTALEXTENT, lMaxLineSize, 0)
end if
----------------------------------------------------------------------
-- HELP WINDOW:
global constant HelpWindow = create( Window, "Help", MainWindow, xWinPos(600), 58, 600, 479, { WS_DLGFRAME, WS_SYSMENU} )--xWinPos(atom width)

-- VIRTUAL KEYS WINDOW:
global constant VKWindow = create( Window, "Virtual Keys Constants used in Win32Lib", MainWindow, 0, 0, 600, 500, { WS_DLGFRAME, WS_SYSMENU} )




global constant VKhiddenSLE =  create( EditText, "", VKWindow, 5, -100, 200, 30, 0)  -- used to allow copy to clipboard of virtual key constants
-----------------------------------------------------------------------
-- STATUS BAR:
constant
    MainStatusBar      = create( StatusBar, "", MainWindow, 0, 25, 20, 20, 0),
    ConStatusBar    = create( StatusBar, "", ConstantsWindow, 0, 25, 20, 20, 0)
-----------------------------------------------------------------------
-- TUTORIAL SELECTION WINDOW:

constant FindTutorialWindow = create( Window, "FIND THE Win32Lib TUTORIAL", MainWindow, xWinPos(400) ,60, 400, 200, #C40000)

------------------------------------------------------------------------
-- AUTO FIND TUTORIAL WINDOW:
constant AutoFindTutorialWindow = create( Window, "SEARCHING FOR Win32Lib TUTORIALS:", MainWindow, xWinPos(450),60 , 450, 250, w32or_all({WS_DLGFRAME, WS_SYSMENU}) )

--------------------------------------------------------------------
-- EDIT DEMOS LISTS WINDOWS:
   -- Add, Remove, or Change Demo Listing:
constant SelectEditWindow = create( Window, "Add, Remove, Change Demo Listing", MainWindow, xWinPos(450) ,60, 450, 250, 0 )

constant SelectListWindow = create( Window, "SELECT CATEGORY to add new demo to", MainWindow, xWinPos(450) ,60, 450, 250, 0 )

constant DescribeNewDemoWindow = create( Window, "DESCRIBE & SAVE NEW DEMO", MainWindow, xWinPos(450) ,60, 450, 250, 0 )

constant ChangeDemoDescriptionWindow =  create( Window, "CHANGE DEMO DESCRIPTION", MainWindow, xWinPos(650) ,60, 650, 250, 0 )

constant AddNewCategoryWindow = create( Window, "ADD NEW CATEGORY", MainWindow, xWinPos(450) ,60, 450, 250, 0 )

------------------------------------------------------------------------
-- EDIT LISTS CONTROLS:
-- categories list:
global constant ListOfCategories = create( List, "Categories List", SelectListWindow, 20, 20, 400, 150, 0 )

-- button to allow use of category selected to add to:
constant Button_UseSelctdCategory = create( PushButton, "Use Selected Category", SelectListWindow, 30, 170, 175, 30, 0 )
constant Button_CancelAddNewDemo = create( PushButton, "Cancel Add", SelectListWindow, 220, 170, 175, 30, 0 )

-- SLE for entering description:
global constant NewDemoDesc = create(EditText,"" ,DescribeNewDemoWindow , 10,50, 700, 30,0)

-- label for instructions for entering description:
global constant Label_NewDemoDesc = create(LText,"Describe the new demo" ,DescribeNewDemoWindow , 10,10, 700, 30,0)

-- buttons for saving new demo data:
global constant Button_SaveNewDemoInfo = create( PushButton, "Save New Demo", DescribeNewDemoWindow, 25, 120, 150, 30, 0 )
global constant Button_CancelSaveAddNewDemo = create( PushButton, "Cancel Add", DescribeNewDemoWindow, 200, 120, 150, 30, 0 )

-- labels for changing demo description:
constant ChDescrLabel1 = create(LText, "Here", ChangeDemoDescriptionWindow, 10,20,500,60,0) -- for category name & demo name
constant ChDescrLabel2 = create(LText, "and here", ChangeDemoDescriptionWindow, 10,60,600,30,0) -- for original description

-- edit line for changing demo description:
constant NewDescriptionSLE =  create(EditText,"" ,ChangeDemoDescriptionWindow , 10,100, 500, 30,0)
limitText(NewDescriptionSLE, 52)


-- buttons for saving demo new description:
global constant Button_SaveDemoNewDescription = create( PushButton, "Save Demo New Description", ChangeDemoDescriptionWindow, 10, 155, 220, 30, 0 )
global constant Button_CancelNewDemoDescription = create( PushButton, "Cancel Change", ChangeDemoDescriptionWindow, 240, 155, 150, 30, 0 )

-- label to instruct add new category name:
constant AddCatLabel = create(LText, "Enter name of new category", AddNewCategoryWindow, 10,20,400,30,0) -- for category name

-- SLE to allow user input new category name:
constant AddCategorySLE =  create(EditText,"" ,AddNewCategoryWindow , 10,70, 150, 30,0)
limitText(AddCategorySLE, 30)

-- buttons to save/cancel add new category:
global constant Button_AddNewCategory = create( PushButton, "Create New Category", AddNewCategoryWindow, 10, 120, 220, 30, 0 )
global constant Button_CancelAddNewCategory = create( PushButton, "Cancel Add", AddNewCategoryWindow, 240, 120, 150, 30, 0 )

-------------------------------------------------------------------------
-- MAIN TAB CONTROL:
global integer Tabs
 Tabs = create( TabControl, "", MainWindow, 100, 150, 600, 350, 0 )
------------------------------------------------------------------------
-- DATA STRUCTURES FOR:  CREATING INDIVIDUAL TABS, LISTS IN FOLDERS,
-- AND NAMES AND DESCRIPTIONS OF EXAMPLE PROGRAMS:
-- idea and 95% of the code provided by Derek Parnell

-- three data structures are created and used:
-- one to hold the handles of each tabbed folder, and the tabs names;
-- one to hold the handles of the lists which go into each tabbed folder;
-- and one to hold the names and descriptions of the example programs

-- if file "RunDemos.LST", gets examples names, descriptions, and tab names
-- from file; otherwise, gets it from interior data:

-- data structure to hold folders handles & tab names:
sequence TabsNames  -- structure will be: {{handle,tabName},{h,tn}...,{h,tn}
TabsNames = {}

-- data structure for creating a list in each folder:
sequence ListsHandles--  holds "handles" for lists in folders
ListsHandles = {}  -- structure will be: {h1,h2,..hn}

-- data structure for names and descriptions of example programs:
sequence Programs  -- ("filename" below is filename minus its extent)
Programs = {}-- structure will be:{{"filename","description"},{"",""}...{}}

-- TabsNames  -- structure will be: {{handle,tabName},{h,tn}...,{h,tn}
-- ListsHandles = {}  -- structure will be: {h1,h2,..hn}
--Programs  structure will be:{{"filename","description"},{"",""}...{}}
---------------------------------------
-- EXAMPLES FILE LIST (RUNDEMOS.LST) HEADER INFO:
sequence FileHeader
FileHeader = {}
FileHeader &={"  LIST OF WIN32LIB EXAMPLE PROGRAMS TO RUN UNDER RunDemos"}
FileHeader &={" "}
FileHeader &={"  DON'T CHANGE THIS FILE UNLESS YOU UNDERSTAND THE FOLLOWING!"}
FileHeader &={""}
FileHeader &={" NOTE: As of March xx, 2002, this file can be edited"}
FileHeader &={"       from within RunDemos, & doesn't need to be hand edited."}
FileHeader &={""}
FileHeader &={"  File Purpose:"}
FileHeader &={"  This file is a STRUCTURED list of all the example programs for Win32Lib,"}
FileHeader &={"    for use by the examples gateway program, RunDemos;"}
FileHeader &={"    it is read by RunDemos to populate lists in tab folders which"}
FileHeader &={"    provide the user with the opportunity to run or view those examples."}
FileHeader &={" "}
FileHeader &={"  IF YOU MESS THIS FILE'S STRUCTURE UP, RunDemos WON'T RUN RIGHT!"}
FileHeader &={" "}
FileHeader &={"  File Structure:"}
FileHeader &={"  LINES IN THIS FILE STARTING WITH A SPACE ARE IGNORED, AS ARE BLANK LINES;"}
FileHeader &={"  lines starting with -- are the names FOR THE TABS in the tab folders;"}
FileHeader &={"  in any other line, text before 1st = is an EXAMPLE FILE NAME minus extent;"}
FileHeader &={"  text after first = is the DESCRIPTION for that example."}
FileHeader &={" "}
FileHeader &={"  Adding new examples or folders:"}
FileHeader &={"      DON'T start a line for an additional example or folder with a space,"}
FileHeader &={"      and DO place EACH ADDITION on a SEPARATE line."}
FileHeader &={"   To add a NEW EXAMPLE,"}
FileHeader &={"    add it somewhere with all the existing examples for that tab name,"}
FileHeader &={"    with the example file name minus its extent first, followed by a colon,"}
FileHeader &={"    then followed by a description of the example, no longer than a line."}
FileHeader &={"   To add a NEW TAB FOLDER NAME,"}
FileHeader &={"    enter two dashes at the beginning of a line,"}
FileHeader &={"    followed by the desired tab folder name;"}
FileHeader &={"    the actual tab folder name will be what you place there,"}
FileHeader &={"     plus the word, \"examples\"."}
FileHeader &={"   To DELETE an example, just delete it from this file"}
FileHeader &={" "}
FileHeader &={" DEMOS LIST:"}
FileHeader &={" "}
--------------------------------------------------------------------------
-- GENERIC PROCEDURE TO WRITE OUT ALL HEADER & DEMO DATA TO RunDemos.lst:
--  (either in initial procedure below, because there wasn't a file,
--   or whenever the user edits & saves the list of examples)

procedure WriteRunDemosListFile()
   AfileHandle = open(DemoDirectory & "RunDemos.lst", "w")
   if AfileHandle >= 0 then
       for n = 1 to length(FileHeader) do
          puts(AfileHandle, FileHeader[n] & "\n")
       end for
       for n = 1 to length(TabsNames) do
          puts(AfileHandle, "--" & TabsNames[n][2] & "\n")

          for m = 1 to length(Programs[n]) do

              puts(AfileHandle, Programs[n][m][1] & "="
                    & Programs[n][m][2] &   "\n")
           end for
       end for
       close(AfileHandle)
    end if
end procedure

--------------------------------------------------------------------------

procedure CreateExamplesDataStructure()

-- READ FILE TO GET DATA:
  -- idea for using a file to hold Examples names & definitions
  -- is from Derek Parnell

integer numOfLists
numOfLists = 0

AfileHandle = open(DemoDirectory & "RunDemos.lst", "r")
if AfileHandle != -1 then  -- is a file there
   while 1 do
     DatLine= gets(AfileHandle) -- reads line of text from file
     if atom(DatLine) then
        exit
     end if
     if length(DatLine) > 1 then
        DatLine = DatLine[1..length(DatLine)-1]
     end if

     if match("--", DatLine)= 1 then -- is a tab name
        numOfLists += 1
        TabsNames = TabsNames & {{
                   create( TabItem, " " &
                   DatLine[3..length(DatLine)] &
                   " Examples ", Tabs, 0, 0, 0, 0, 0 ),
                 DatLine[3..length(DatLine)]
               }}
        ListsHandles = ListsHandles & {
                         createEx( List, sprintf("List%d",numOfLists),
                         TabsNames[numOfLists][1], 50, 50, 500, 275, WS_HSCROLL,0 )
                        }
        Programs = Programs & {{}}

     elsif match(" ",DatLine) != 1 -- ignore lines starting with space
           and length(DatLine) > 1  --also ignore blank lines
      then -- line is an example name and description
        Programs[length(Programs)] = Programs[length(Programs)] &
                                    {{DatLine[1..match("=",DatLine)-1],
                       DatLine[match("=",DatLine) + 1..length(DatLine)]}}
     end if
   end while
   close(AfileHandle)

else  -- NO FILE, USE FOLLOWING DATA AS DEFAULT:
   TabsNames =  {{0, "Numbered"},
                {0, "Named"},
                {0, "More"},
                {0, "New"}
--0  note: to add more tabs, put them here
                                  }
   ----------
   ListsHandles = repeat(0,length(TabsNames))
   -------------

  -- TABS AND LIST BOXES:
  -- creates tabbed folders, with tab names, and also lists for each?
  for i = 1 to length(TabsNames) do
     TabsNames[i][1] = create(TabItem, " " & TabsNames[i][2] & " Examples ",
                                 Tabs, 0, 0, 0, 0, 0 )
      ListsHandles[i]       = create( List, sprintf("List%d",i),
                                 TabsNames[i][1], 50, 50, 500, 275, 0 )
   end for
   -------------
   -- EXAMPLE PROGRAMS NAMES AND DESCRIPTIONS:

   --0 note: this is where you would add new programs names & descriptions:
   -- data structure for names & descriptions of example programs:

   Programs = {
   -- List #1 --
   {
         {"1","Simple Window"},
         {"2", "text in window" },
         {"3", "button in window, no action" },
         {"4", "button closes window"},
         {"5", "two buttons, with message boxes"},
         {"6", "list box with items, button extracts info"},
         {"7", "single line edit box, check box, and status bar"},
         {"8", "makes menu for window"},
         {"9", "displays fonts in window"},
         {"10", "horizontal scroll bar"},
         {"11", "colored lines"},
         {"12", "colored text"},
         {"13", "Simple timer"},
         {"14", "icon & bitmap in window"},
         {"15", "many controls in one window"},
         {"16", "Tiles Bitmaps In Window, & Changes Control's Font"},
         {"17", "Demonstrate hand-built bitmaps"},
         {"18", "game demo: connect"},
         {"19", "game demo: black box"},
         {"20", "popup menus: right clicking window brings up the popup"},
         {"21", "tab controls"}
          -- any extra list 1 contents go here
     },
   -- List #2 --
   {
      {"Generic", "Menus, File dialogs, Printer,Toolbars, & Tooltips"},
      {"ComboBoxEx", "combo with images"},
      {"ListTreeView", "TreeView & ListView"},
      {"MonthCalendar", "Monthly Calendar Demo"},
      {"PageSetupDlg", "Printer Page Setup Dialog"},
      {"ReBar", "ReBar is toolbar, can add other controls to it"},
      {"RichEdit", "enter & edit text, with formatting & embedded ole"},
      {"ToolBar", "flat tool bar"},
      {"Tooltip", "descriptive messages popup when mouse over control"},
      {"UpDown", "arrow buttons increment or decrement a value"}
       -- any extra list 2 contents go here
     },
   -- List #3 --
   {
       {"RtClick", "right click selects item from list box"},
       {"Wstyles", "shows various styles of windows"},
       {"ModalWin", "makes a window which must be closed before main can"},
       {"CenterIt", "centers a modal window inside a main window"},
       {"MsgBox", "shows how to put a Message Box in your program"},
       {"WrtLabel", "writes text to label, and erases it"},
       {"WalkDir", "finds all directories and files in a directory"},
       {"FindFile", "finds what directory a file is in"}
       -- any extra list 3 contents go here
     },
   -- List #4 --
   {
       {"Center1", "centers a window in the screen"},
       {"Buttons5", "more elaborate way to make two buttons"},
       {"Buttons3", "makes a bunch of buttons, auto sizes button labels"},
       {"Menu08", "menu with sub-menus, and popup, and multi-line edit box"},
       {"BitMap14", "puts bitmaps into window, changes with click"},
       {"BkGnd16", "changes background with click"}
   -- list 4 contents go here:               . . .
    }
   -- any NEW tab's contents would get added here
           }

   -- NOW WRITE OUT THIS DATA TO A FILE, RunDemos.Lst:
   WriteRunDemosListFile()


end if
end procedure
--------------------
CreateExamplesDataStructure()-- go back up and do the above procedure
-------------------------------------------------------------------------

-- list box for versions of Tutorials for choosing from:
global constant TutorialList = create( List, "Tutorials Versions", AutoFindTutorialWindow, 20, 40, 400, 150, 0 )

------------------------------------------------------------------------

-- TITLES AND LABELS:
global constant TitleLabel = create( CText, "SOME EXAMPLES FOR USING WIN32LIB", MainWindow, 200, 75, 400, 24, 0 )
global constant InstructionLabel = create( CText, "Left dbl-click to RUN example; Right click to see program CODE", MainWindow, 135, 116, 530, 20, 0 )
--global constant InfoLabel = create( LText, "Pick a directory ", InfoWindow, 20, 10, 580, 70, 0 )

global constant SearchingForTutLabel = create( LText, "Searching... ", AutoFindTutorialWindow, 50, 10, 100, 30, 0 )

-- EDIT DEMOS LISTING:
constant DemosLabel = create( CText, "DEMOS", SelectEditWindow, 10, 20, 200, 30, 0 )
constant CatsLabel = create( CText, "CATEGORIES", SelectEditWindow, 230, 20, 200, 30, 0 )
-----------------------------------------------------------------------

-- BUTTONS:
global constant ImportButton = create( PushButton, "Import Demos", MainWindow, 0, 0, 115, 30, 0 )

global constant ImportAllButton = create( PushButton, "Import Demos as specified below", ImportWindow, 10, 10, 290, 30, 0 )

global constant
-- ImportAllMinusButton = create( PushButton, "Import All .exw EXCEPT non--demos", ImportWindow, 10, 50, 290, 30, 0 )
--ImportWindow, 10, 90, 170, 30, 0 )
--global constant ImportNewMinusButton = create( PushButton, "Import New .exw EXCEPT non-demos", ImportWindow, 10, 130, 290, 30, 0 )

CkImportXdupl  = create( CheckBox, "exclude any already listed here", ImportWindow, 10, 60, 290, 25, 0 ),
CkImportXnon  = create( CheckBox, "exclude known non-demos", ImportWindow,  10, 90, 290, 25, 0),
CkImportXnum  = create( CheckBox, "exclude numbered examples", ImportWindow, 10, 120, 290, 25, 0)

setCheck(CkImportXdupl ,w32True)
setCheck(CkImportXnon ,w32True)
setCheck( CkImportXnum,w32True)
--CkImportXdupl CkImportXnon CkImportXnum

-- EDIT BUTTONS:
global constant EditDemosListsButton = create( PushButton, "Edit Lists", MainWindow, 116, 0, 100, 30, 0 )
global constant AddDemosButton = create(PushButton, "ADD new DEMO to list", SelectEditWindow, 10 , 60, 200, 30, 0)
global constant RemoveDemosButton = create(PushButton, "(REMOVE a DEMO)", SelectEditWindow, 10, 100, 200, 30, 0)
global constant ChangeDescButton = create(PushButton, "CHANGE Description", SelectEditWindow, 10, 140, 200, 30, 0)
global constant MoveDemoButton = create(PushButton, "(MOVE a DEMO)", SelectEditWindow, 10, 180, 200, 30, 0)
global constant AddCatButton = create(PushButton, "ADD new CATEGORY", SelectEditWindow, 230, 60, 200, 30, 0)
global constant DeleteCatButton = create(PushButton, "(REMOVE a CATEGORY)", SelectEditWindow, 230, 100, 200, 30, 0)

global constant EuManualButton = create( PushButton, "Euphoria", MainWindow, 224, 0, 90, 30, 0 )

global constant W32ManualButton = create( PushButton, "Win32Lib", MainWindow, 315, 0, 100, 30, 0 )
global constant Win32FaqButton = create( PushButton, "Win FAQ", MainWindow, 420, 0, 80, 30, 0 )
global constant Tut1Button = create( PushButton, "Tutorial", MainWindow, 501, 0, 80, 30, 0 )
global constant IDEbutton = create( PushButton, "IDE", MainWindow, 582, 0, 50, 30, 0 )

global constant AutoFindTutButton = create( PushButton, "Auto Find Tutorial", FindTutorialWindow, xCenterButtonInWindow(180,FindTutorialWindow), 20, 180, 30, 0 )
global constant UserFindTutButton = create( PushButton, "User Find Tutorial", FindTutorialWindow, xCenterButtonInWindow(180,FindTutorialWindow), 60, 180, 30, 0 )
global constant CancelFindTutButton = create( PushButton, "Cancel Find Tutorial", FindTutorialWindow, xCenterButtonInWindow(180,FindTutorialWindow), 100, 180, 30, 0 )

-- stop button for auto search for Tutorial/Ide:
global constant StopSearchButton = create( PushButton, "Stop Search", AutoFindTutorialWindow, 165, 5, 150 , 30, 0 )

global constant Button_UseSelectedTutorial = create( PushButton, "Use Selected Tutorial", AutoFindTutorialWindow, 40, 185, 160, 30, 0 )
global constant Button_CancelAutoSelect = create( PushButton, "Cancel", AutoFindTutorialWindow, 250, 185, 150, 30, 0 )

global constant ConstantsButton = create( PushButton, "Constants", MainWindow, 640, 0, 80, 30, 0 )

global constant HelpButton = create( PushButton, "Help", MainWindow, 730, 0, 60, 30, 0 )
------------------------------------------------------------------------
-- HELP STUFF: HelpWindow

--   list to hold help topiocs:
constant
  Hlp_List = create(List, "",HelpWindow, 10, 10, 160, 390, 0 )

-- HELP MESSAGES to show in LABEL in help window:
--  (first make the messages, then make the lables to hold the messages)
sequence HlpMessages
HlpMessages = {}

HlpMessages &= {"To RUN an example:" & CR & "LEFT DOUBLE-CLICK on it."}
HlpMessages &={"To VIEW THE CODE implementing an example: " & CR & "RIGHT CLICK on it."}
HlpMessages &={"To COPY useful sections of code from the examples into your program: "  & CR &
	" first VIEW the code, then SELECT a section; COPY it; and then PASTE it into your program; change names as needed."}
HlpMessages &={""}
HlpMessages &={"To add a demo to a category," & CR &
         "either click [Edit Lists]," & CR &
         "and then click [add new demo to list], or," & CR & CR &
         "just select the category you want to add a demo to," & CR &
         "and press the <insert> key;" & CR &
         "in either case a \"select file to add\" dialog will appear."}
HlpMessages &={"To remove a demo from a category," & CR &
         "just select the category you want to remove a demo from," & CR &
         "then select the demo you want to remove," & CR &
         "and press the <delete> key."}
HlpMessages &={"To change the description of a demo," & CR &
         "select the demo you want to change the description for," & CR &
         "then click [Edit List]," & CR &
         "and then click [change description] ," & CR &
         "and then enter the new description in the edit box."}
HlpMessages &={"You can move a demo up or down in a category" & CR &
         "by pressing the <shift><up/downarrow> keys." & CR & CR &
         "You can move a demo to another category" & CR &
         "by pressing the <shift><left/rightarrow> keys"}
HlpMessages &={""}
HlpMessages &={"To add a new category to the tab folder," & CR &
         "either click [Edit Lists]" & CR & "and then click [add new category], or," & CR & CR &
         "just press the <crtl><insert> keys."}
HlpMessages &={"To remove a category from the tab folder," & CR &
         "click on the tabfolder you want to remove," & CR &
         "and press the <crtl><delete> keys."}
HlpMessages &={""}

HlpMessages &={"You can import groups of demos by clicking on the \"Import Demos\" button."
& "  A window will come up giving you a choice of WHAT to IMPORT," & CR &
"WHERE to Import FROM, and what NAME to use as a CATEGORY for those imported programs."
 & CR & CR &
"You can specify WHAT TO IMPORT by setting a check to exclude any combination of :" & CR &
"1. any already listed," & CR &
"2. known non-demo .exw's, or" & CR &
"3. numbered examples." & CR &
"Or you can uncheck all and import all .exw's in the specified directory; "
& "the default is to exclude all dupls and non-demos and numbered examples."

& CR & CR &
"You can import FROM the INITIAL DIRECTORY by default, OR click a radio-button to allow selection of ANOTHER DIRECTORY to IMPORT FROM."
& CR & CR &
"You can specify a NAME for the CATEGORY to save the imported programs in by typing it into the edit box at the bottom of the Import window;"
& " otherwise a default name is created from the specified directory."}
HlpMessages &={""}
HlpMessages &={"There is a TUTORIAL for Win32Lib, by Wolfgang Fritz.  It can be found at http://www.king.igs.net/~wolfritz/tutor.htm."
& CR & " You can run the Tutorial from RunDemos by clicking on the [Tutorial] button."
& CR & CR & "Since you may put the Tutorial wherever you want on your drive, RunDemos provides two different methods to locate it to run it:  "
& CR & CR &
	"when you press the [Tutorial] button, if this program knows where the Tutorial is, it will run it;" & CR &
      "if it doesn't know, it will give you a choice of searching manually or semi-automatically for the Tutorial, " &
	"and if it is found, its location will be saved to a .dat file so that next time you won't have to look for it.  " & CR & CR &
	"If you want to change your location selection after it's been saved, RIGHT CLICK on the [Tutorial] button."}

HlpMessages &={"There is a \"point and click\" visually oriented program for developing Windows applications using Win32Lib, called an \"IDE\", by Judith Evans."
& "  It is available at the RDS site.  You can run the Ide from RunDemos by clicking on the [IDE] button."
& CR & CR & "Although it would usually be loaded in the same directory as Win32Lib, you could load it elsewhere, so RunDemos provides two different methods to locate it to run it:  "  & CR & CR &
"when you press the [IDE] button, if this program knows where the Ide is, it will run it;" & CR &
      "if it doesn't know, it will give you a choice of searching manually or semi-automatically for the Ide, " &
	"and if it is found, its location will be saved to a .dat file so that next time you won't have to look for it.  " & CR & CR &
	"If you want to change your location selection after it's been saved, RIGHT CLICK on the [IDE] button."}

 -- write info for Frequently Used Constants here
HlpMessages &={"The \"Constants\" button will show listings of constants used for: " & CR & CR &
    "   * Virtual Keys," & CR &
    "  ** w32H Handler Events,"  & CR &
    "   * Colors,"   & CR &
    "  ** Controls, and"& CR &
    "   * Mouse Events" & CR & CR &
    "Double-clicking on any constant will copy it to the clipboard."
     & CR & CR &
    "* You can set radio-buttons for these " &
    " to allow just the constant to be copied, or to copy " &
    "an event-trap template, or to copy both " &
    "the event-trap template and a template for the event handling "  &
    "routine." & CR & CR &
    "eg: for the \"w32HClick\" event, clipboard could get:" & CR &
    "  procedure onClick_SomeControl(integer self, integer event, sequence parms)" & CR &
    "  end procedure" & CR &
    "  setHandler(SomeControl, w32HClick," & CR &
    "    routine_id(\"onClick_SomeControl\"))" & CR &
    "  --replace 'SomeControl' above with your relevant controlID name"
    & CR & CR &
    "** can copy templates for creating events/controls to clipboard."


}

HlpMessages &={""}
HlpMessages &={"RunDemos is a gateway to using Win32Lib;" & CR &
	"it provides the opportunity to: " & CR & CR &
	"1. FIND EXAMPLES of Win32Lib programming by DESCRIPTION, and RUN them," & CR &
	"2. SEE the CODE implementing the examples," & CR &
	"3. COPY useful SECTIONS OF CODE from the examples into your own program, " & CR & CR &
      "4. ADD and REMOVE demos and categories, and CHANGE the demo descriptions," & CR &  "and MOVE demos, and IMPORT groups of demos," & CR & CR &
    	"5. READ THE MANUALS for Euphoria and Win32Lib," & CR &
	"6. PERUSE Frequently Asked Questions about Win32Lib," & CR &
	"7. ACCESS a TUTORIAL for Win32Lib," & CR &
	"8. RUN the IDE (a visual programming environment)," & CR &
      "9. and see and easily copy various useful CONSTANTS." & CR & CR &
	" version " & Version & "   " & CreationDate & "    by Dan Moyer " & CR &
	" requires Win32Lib v0.57+  (see also: \"Credits\")"}

HlpMessages &={"RunDemos: "
 & CR & "Al Getz, Wolfgang Fritz, and Derek Parnell helped me implement various features of RunDemos."
& CR & CR & "Win32Lib: "
& CR & "RunDemos was developed using Win32Lib, which was initially created by David Cuny, then extensivly further expanded and maintained by Derek Parnell."
 & CR & CR &
		"Other contributors to the development of Win32Lib include: "
 & CR & "Matt Lewis, David Cuny, Wolfgang Fritz, Davi Figueiredo,"
 & " Renzo Beggia, Travis Beaty, Thomas Parslow, Martin Stachon, Irv Mullins,"
 & " Judith Camping, Guillermo Bonvehi, Jess Harpur, Dan Moyer, and Gwen."}

---------------
sequence HlpTitle HlpTitle = {}
HlpTitle &= {"RUN A DEMO"}
HlpTitle &= {"VIEW DEMO CODE"}
HlpTitle &= {"COPY DEMO CODE"}
HlpTitle &= {""}
HlpTitle &= {"ADD A NEW DEMO"}
HlpTitle &= {"REMOVE A DEMO"}
HlpTitle &= {"CHANGE DEMO DESCRIPTION"}
HlpTitle &= {"MOVE A DEMO"}
HlpTitle &= {""}
HlpTitle &= {"ADD A CATEGORY"}
HlpTitle &= {"REMOVE A CATEGORY"}
HlpTitle &= {""}
HlpTitle &= {"IMPORTING GROUPS OF DEMOS"}
HlpTitle &= {""}
HlpTitle &= {"TUTORIAL"}
HlpTitle &= {"IDE"}
HlpTitle &= {"FREQUENTLY USED CONSTANTS"}
HlpTitle &= {""}
HlpTitle &= {"ABOUT RunDemos version " & Version}
HlpTitle &= {"CREDITS"}


integer HlpInfoLabel
HlpInfoLabel = create(LText ,"Label ",HelpWindow,185,10,400, 475,0 )

-------------------------------------------------------------------------
-- TOOLTIP STUFF:

setHint( ImportButton, "Import Demos into this listing" )
setHint( EditDemosListsButton, "Add or remove Demos from lists")
setHint( EuManualButton, "Euphoria Manual" )
setHint( W32ManualButton, "Win32Lib Manual" )
setHint( Win32FaqButton, " Frequently Asked Questions about Win32Lib" )
setHint( Tut1Button, " Tutorial on Win32Lib (right-click to re-select location)" )
setHint( IDEbutton, " easy (visual) program development (right-click to re-select location)" )
setHint( ConstantsButton, "some Frequently Used Constants: double-click on any to copy to clipboard" )

setHint( AddDemosButton, "select category, press <insert>" )
setHint(RemoveDemosButton,"select category, select demo, press <delete>")
setHint(ChangeDescButton,"select demo first")

setHint(MoveDemoButton,"select demo, <shift> <arrow>")

setHint(AddCatButton, "press <ctrl><insert>" )
setHint( DeleteCatButton, "select category, press <ctrl><delete>" )

setHint(ImportAllButton,"Imports *.exw programs from user selected directory")


---------------------------------------------------------------------------
--  LABELS & LISTS FONTS:


setFont( Tabs, "Arial", 9, Bold )
limitText(NewDescriptionSLE, 52) --STILL DIDN'T LIMIT INPUT LENGTH?

------------------------------------------------------------------------
-- DEFINE FILE TYPES TO BE LOOKED FOR BY "OPEN FILE" DIALOG:
constant FileTypes = {
    "Euphoria Program", "*.EXW;"     }

--  NOTE:  could allow multiple file types, like this:
--constant FileTypes = {
--    "Text File", "*.TXT",
--    "Euphoria Program", "*.EX;*.EXW;*.E;*.EW",
--    "All Files", "*.*" }

------------------------------------------------------------------------
-- ADDED TO ALLOW "RIGHT CLICK SELECTION" IN LIST BOX:
constant zLB_GETITEMHEIGHT=#01A1,
         zLB_GETTOPINDEX=#018E

-- note:  put "z" in front in case they're eventually incorperated into
--	    Win32Lib, so there won't be a "constant reassignment" error.
--	    Thanks for the suggestion Wolfgang!
--------------------------------------------------------------------------
-- STUFF ADDED TO ALLOW RUNNING OTHER PROGRAMS:
-- (wraps ShellExecute fully, provided by Wolfgang Fritz):

-- originally from DaJaRo jumpto.ew
atom lib
integer jJumpto --id
if platform() = WIN32 then
   lib = open_dll("shell32.dll")
   jJumpto = define_c_func(lib,"ShellExecuteA",
   {C_INT,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_INT},C_INT)
   if jJumpto = -1 then
      puts(1,"couldn't find ShellExecuteA\n")
      abort(1)
   end if
end if

procedure Jump_to(integer id,sequence filename,
sequence defaultpath,sequence parameters, integer flag)
sequence command, Filenam, DefaultPath, Parameters
integer Nop
atom command_ptr,Fnm_ptr,Prm_ptr,Dfp_ptr,hw
command = "Open"
Filenam= filename
Parameters=parameters
DefaultPath=defaultpath
command_ptr = allocate_string(command)
Fnm_ptr = allocate_string(Filenam)
Prm_ptr = allocate_string(Parameters)
Dfp_ptr = allocate_string(DefaultPath)
hw= getHandle(id )
Nop=w32Func(jJumpto,{hw,command_ptr,
Fnm_ptr,Prm_ptr,Dfp_ptr,flag})
free(command_ptr)
free(Fnm_ptr)
free(Prm_ptr)
free(Dfp_ptr)
end procedure
-------------------------------------------------------------------------

-------------------------------------------------------------------------

--------------     MAIN PROGRAM ROUTINES:    ----------------------------

---------------------------------------------------------------------------

----------------------------------------------------------------------------
function RemovePathAndExtentFromFullFileName (sequence fullPathAndFileName)
sequence bareFileName, aDemoPath

       bareFileName = fullPathAndFileName-- just in case it's just filename
       --  remove extent, if present (should be!):
       for n = length(fullPathAndFileName) to 1 by -1 do
            if equal(fullPathAndFileName[n], '.') then
               bareFileName = fullPathAndFileName[1..n-1]
               exit
            end if
       end for
       -- remove pathname info:
       for n = length(bareFileName) to 1 by -1 do
            if equal(bareFileName[n], '\\') then
               aDemoPath = bareFileName[1..n]
               bareFileName = bareFileName[n+1..length(bareFileName)]
               exit
            end if
       end for
return {aDemoPath,bareFileName}

end function
---------------------------------------------------------------------------
procedure MainWindow_onOpen (integer self, integer event, sequence params)
sequence aFileName
aFileName = {}

--  add all example programs names & descriptions to appropriate lists:

   for i = 1 to length(ListsHandles) do
       for j = 1 to length(Programs[i]) do
           aFileName = Programs[i][j][1]

         if find('.',aFileName) or find ('\\',aFileName) then
           aFileName = RemovePathAndExtentFromFullFileName(aFileName)
           aFileName = aFileName[2]-- because function returned path too
         end if
           addItem(ListsHandles[i], aFileName & ": " & Programs[i][j][2])
           setIndex(ListsHandles[i],1)
       end for
   end for
   if length(TabsNames) > 0 then
      setFocus(TabsNames[1][1])
   end if

   -- Constants topics:
   addItem(ConTopicsList, "Virtual Keys")
   addItem(ConTopicsList, "w32H Events")
--   addItem(ConTopicsList, "onSomeEvent")
   addItem(ConTopicsList, "Colors")
   addItem(ConTopicsList, "Controls")
   addItem(ConTopicsList, "Mouse Events")

   -- Help Topics:
   addItem(Hlp_List, "Run a Demo")
   addItem(Hlp_List,"See Demo Code" )
   addItem(Hlp_List,"Copy Demo Code" )
   addItem(Hlp_List,"===================" )
   addItem(Hlp_List,"Add a Demo" )
   addItem(Hlp_List, "Remove a Demo")
   addItem(Hlp_List, "Change Description")
   addItem(Hlp_List, "Move a Demo")
   addItem(Hlp_List,"-------------------" )
   addItem(Hlp_List,"Add a Category" )
   addItem(Hlp_List,"Remove a Category" )
   addItem(Hlp_List,"-------------------" )
   addItem(Hlp_List,"Import Demos" )
   addItem(Hlp_List,"===================" )
   addItem(Hlp_List,"Tutorial" )
   addItem(Hlp_List,"IDE" )
   addItem(Hlp_List,"Constants" )
   addItem(Hlp_List,"===================" )
   addItem(Hlp_List, "ABOUT")
   addItem(Hlp_List, "Credits")

end procedure

setHandler(MainWindow, w32HOpen, routine_id("MainWindow_onOpen"))

----------------------------------------------------------------------------
-- GENERIC ON MOUSE PROCEDURES & TRAP, FOR ALL 4 LISTS:
-- provided by Derek Parnell
-- all four onMouse traps made with a single procedure...

procedure List_onMouse ( integer self, integer event, sequence params )
   atom lParam,index,bool,height,topindex,indexoffset
   sequence itemtext
   -- above necessary to allow right click selection of item in listbox

   integer itemInList, result
   sequence fName
   integer aFileHandle
   integer FileExists

   integer ListNumber ListNumber = 1
   FileExists = 0 -- false to begin with


-- temporary (?) fix for problem with mouse move in list crashes prgm,
-- after adding move demos from one category to another:
   if params[1] = MouseMove then
      return
   end if


   -- Now process the request.
  index = getIndex(self)-- just use control id, instead of get from var

if index > 0 then  -- only do all following if items exist & 1 selected:

   -- find out which list was clicked on:
   for n = 1 to length(ListsHandles) do
      if self = ListsHandles[n] then
         ListNumber = n
         exit
      end if
   end for

   -- get basic file name:
   fName = Programs[ListNumber][index][1]

  if equal(TabsNames[ListNumber][2], "Numbered") then
--  if ListNumber = 1 then  -- handle numbered examples
     if length(fName) < 2 then-- changed from index<10 in case some removed
        fName = "ex0" & fName
     else
        fName = "ex" & fName
     end if
  end if

  fName = fName & ".EXW"



   -- Here's where you should do some safety checks. (for existence of file?)
   -- check for existance of file:
   if not find('\\', fName) then
    aFileHandle = open(DemoDirectory & fName, "r")
   else
    aFileHandle = open(fName, "r")
   end if
   if aFileHandle != -1 then  -- file exists
      FileExists = 1
      close(aFileHandle)
 --     setText(MainStatusBar, "")
   else
      setText(MainStatusBar, fName & " not present in " & DemoDirectory )
   end if

    if params[1] = LeftDoubleClick and FileExists then
       setText(MainStatusBar, "") -- just to clear it in case something there
       Jump_to(
       -- passing YOUR main window's id:
        MainWindow,
        -- with the program to call:
        "exw.exe",
        -- in the Demo directory:
        DemoDirectory ,
        -- the parameter to pass to exw.exe to run:
        fName,
        -- and last, the 'show' parameter:
        SW_SHOWDEFAULT )

    elsif params[1] = LeftUp and FileExists then
      setText(MainStatusBar, "") -- just to clear it in case something there

    elsif params[1] = RightDown then
       -- start of "housekeeping" to allow right click to work:
       height=sendMessage(self,zLB_GETITEMHEIGHT,0,0)
       topindex=sendMessage(self,zLB_GETTOPINDEX,0,0)
       indexoffset=floor(params[3]/height)
       index=indexoffset+topindex
       bool=sendMessage(self,LB_SETCURSEL,index,0)
       index += 1
       itemtext=getItem(self,index)
       -- end of right click housekeeping

       -- get "root" of fname again, with this index applied:
       fName = Programs[ListNumber][index][1]

   --    if ListNumber = 1 then
       if equal(TabsNames[ListNumber][2], "Numbered") then
          if find(':', itemtext)= 2 then
             fName = "ex0" & fName
          else
             fName = "ex" & fName
          end if
       end if

       fName = fName & ".EXW"

       -- put initial directory pathname in front of filename if none there
       if not find('\\', fName) then
         fName = DemoDirectory & fName
       end if

       FileExists = 0
       -- check for existance of selected file:
       aFileHandle = open(fName, "r")
       if aFileHandle != -1 then  -- file exists
          FileExists = 1
          close(aFileHandle)
       end if

--       if FileExists then -- now check for wordpad:
--          aFileHandle =
--            open("C:\\Program Files\\Accessories\\WORDPAD.EXE", "r")
--          if aFileHandle != -1 then
--             FileExists = 1
--             close(aFileHandle)
--          else
--             FileExists = 0
--          end if
--       end if

       if FileExists then
        setText(MainStatusBar, "") -- just to clear it in case something there
         -- used this instead of "system_exec" so long folder names
         -- could be used and work on "all"(?) systems:
         Jump_to(
         -- passing YOUR main window's id:
          MainWindow,
          -- with the program to call:
          vTextViewer,
          -- in this directory:
          "",
          -- the parameter to pass to wordpad to run:
          fName,
          -- and last, the 'show' parameter:
          SW_SHOWDEFAULT )
       end if
    end if
   end if  -- for testing index > 0
end procedure

setHandler(ListsHandles, w32HMouse, routine_id("List_onMouse"))

procedure List_onKeyPress(integer self, integer event, sequence params)
    if params[1] = VK_RETURN then
        VOID = invokeHandler(self, w32HMouse, {LeftDoubleClick})
        returnValue(-1)
    end if
end procedure
setHandler(ListsHandles, w32HKeyPress, routine_id("List_onKeyPress"))
----------------------------------------------------------------------------
-- BUTTON ROUTINES:
--------------------------------------------------------------------------
procedure onClickEditDemosListsButton(integer self, integer event, sequence params)
  openWindow(SelectEditWindow , Modal )
end procedure
setHandler(EditDemosListsButton, w32HClick, routine_id("onClickEditDemosListsButton"))
--------------------------------------------------------------------------
procedure onClickEuManualButton(integer self, integer event, sequence params)
object result
  -- open the HTML version of refman.doc
AfileHandle = open(EuDir &  "\\HTML\\Refman.htm", "r")
if AfileHandle != -1 then  -- see if Euphoria manual present
   close(AfileHandle)
  shellExecute("open",  EuDir & "\\HTML\\Refman.htm", SW_SHOWMAXIMIZED)
else
   result = message_box(
           "Euphoria Manual not present in Euphoria directory",
           "Euphoria Manual NOT PRESENT", 0 )
end if
end procedure

setHandler(EuManualButton, w32HClick, routine_id("onClickEuManualButton"))
--------------------------------------------------------------------------
procedure onClickW32ManualButton(integer self, integer event, sequence params)
object result
  -- open the HTML version of Win32Lib manual
AfileHandle = open(DocsDirectory &  "\\index.htm", "r")
if AfileHandle != -1 then  -- see if Win32Lib manual present
   close(AfileHandle)
    shellExecute("open", DocsDirectory & "\\index.htm",
               SW_SHOWMAXIMIZED)

else
  AfileHandle = open(DocsDirectory &  "\\Win32lib.htm", "r")
  if AfileHandle != -1 then  -- see if Win32Lib manual present
     close(AfileHandle)
  shellExecute("open", DocsDirectory & "\\Win32lib.htm",
                     SW_SHOWMAXIMIZED)

  else
       result = message_box(
           "Win32Lib Manual not present in this directory",
           "Win32Lib Manual NOT PRESENT", 0 )
  end if
end if
end procedure

setHandler(W32ManualButton, w32HClick, routine_id("onClickW32ManualButton"))
----------------------------------------------------------------------------

procedure onClickWin32FaqButton(integer self, integer event, sequence params)
object result
  -- open an HTML FAQ

AfileHandle = open(DocsDirectory &  "\\W32faq.htm", "r")
if AfileHandle != -1 then  -- see if faq present
   close(AfileHandle)

  shellExecute("open", DocsDirectory &  "\\W32faq.htm", SW_SHOWMAXIMIZED)
else
  result = message_box(
           "FAQ not present in this directory",
           "FAQ NOT PRESENT", 0 )
end if
end procedure

setHandler(Win32FaqButton, w32HClick, routine_id("onClickWin32FaqButton"))
-------------------------------------------------------------------
-- PROCEDURES RELATING TO FINDING/JUMPING TO TUTORIAL:

-- JUMP TO TUTORIAL:
procedure JumpToTutorial(sequence aPathName, sequence aFileName)
object result

AfileHandle = open(aPathName & "\\" &  aFileName, "r")
if AfileHandle != -1 then  -- see if tutorial present
   close(AfileHandle)

    Jump_to(
    -- passing YOUR main window's id:
    MainWindow,
    -- with the program to call:
    "exw.exe",
    -- with this path:
    aPathName,  --    "c:\\Euphoria\\Win32Lib\\A new Tutorial\\",
    -- with this file to run:
        aFileName,--"c:\\Euphoria\\Win32Lib\\Tutorial\\Tutor3.exw",
    -- and last, the 'show' parameter:
    SW_SHOWDEFAULT )
else
 if WhichButton = Tut1Button then
  result = message_box(
           "Tutorial not present in specified directory" & CR &
           "RIGHT CLICK on Tutorial button to re-select",
           "Tutorial NOT PRESENT", 0 )
 elsif WhichButton = IDEbutton then
  result = message_box(
           "IDE not present in specified directory" & CR &
           "RIGHT CLICK on IDE button to re-select",
           "IDE NOT PRESENT", 0 )
 end if
end if
end procedure
----------------------------------------------------
--  USER FIND TUTORIAL OR IDE:

--  GENERAL PROCEDURE TO SAVE DATA TO TutAndIde.DAT FILE:

procedure SaveDataToDatFile (sequence aPathName, sequence aFileName)
sequence previousData
previousData = {{},{}}

    if WhichButton = Tut1Button then
       TutorialPathName = aPathName
       TutorialFileName = aFileName

       -- have to find out if data from other already in file, to save:
       AfileHandle = open(DemoDirectory & "TutAndIde.dat", "r")
       if AfileHandle != -1 then  -- is a file there
         while 1 do -- read file until no more:
            DatLine= gets(AfileHandle) -- reads Tutorial path from file
            -- end of file?
            if atom(DatLine) then
               exit
             end if
            DatLine = DatLine[1..length(DatLine)-1]
            if match("IDEPATH:", DatLine) then
               previousData[1]= DatLine[9..length(DatLine)]
            elsif match("IDENAME:", DatLine) then
                previousData[2]= DatLine[9..length(DatLine)]
            end if
          end while
          close(AfileHandle)
       end if

       --  SAVE pathName and then fileName to .dat file, both if present:
       AfileHandle= open(DemoDirectory & "TutAndIde.dat","w")
       puts(AfileHandle, "TUTPATH:" & aPathName & "\n")-- write to .dat file
       puts(AfileHandle, "TUTNAME:" & aFileName & "\n")-- write to .dat file
       if length(previousData[1]) then
          puts(AfileHandle, "IDEPATH:" & previousData[1] & "\n")
          puts(AfileHandle, "IDENAME:" & previousData[2] & "\n")
       end if
       close(AfileHandle)

    elsif WhichButton = IDEbutton then
       IdePathName = aPathName
       IdeFileName = aFileName

       -- have to find out if data from other already in file, to save:
       AfileHandle = open(DemoDirectory & "TutAndIde.dat", "r")
       if AfileHandle != -1 then  -- is a file there
         while 1 do -- read file until no more:
            DatLine= gets(AfileHandle) -- reads Tutorial path from file
            -- end of file?
            if atom(DatLine) then
               exit
             end if
            DatLine = DatLine[1..length(DatLine)-1]
            if match("TUTPATH:", DatLine) then
               previousData[1]= DatLine[9..length(DatLine)]
            elsif match("TUTNAME:", DatLine) then
                previousData[2]= DatLine[9..length(DatLine)]
            end if
          end while
          close(AfileHandle)
       end if


       --  SAVE pathName and then fileName to .dat file, both if present::
       AfileHandle= open(DemoDirectory & "TutAndIde.dat","w")
       puts(AfileHandle, "IDEPATH:" & aPathName & "\n")-- write to .dat file
       puts(AfileHandle, "IDENAME:" & aFileName & "\n")-- write to .dat file
       if length(previousData[1]) then
          puts(AfileHandle, "TUTPATH:" & previousData[1] & "\n")
          puts(AfileHandle, "TUTNAME:" & previousData[2] & "\n")
       end if
       close(AfileHandle)
    end if
end procedure
------------------------------------------------

-- LET USER FIND TUTORIAL:

procedure OnClick_UserFindTutButton(integer self, integer event, sequence params)
sequence pathAndFileName,fileName,pathName, previousData
integer position
previousData = {{},{}}

--  open a "open file" dialog:
   pathAndFileName = getOpenFileName( MainWindow, "", FileTypes )

    -- entered a file name? if not, stay in dialog
    if length( pathAndFileName ) = 0 then
        return
    else
	--separate the path & the file name:
	fileName = {}
	for p = length(pathAndFileName) to 1 by -1 do
	   if equal(pathAndFileName[p],'\\') then
		exit
	   end if
	   position = p  -- find position of LAST \, right before filename
	   fileName = prepend(fileName,pathAndFileName[p])  -- build filename
	end for
      pathName = pathAndFileName[1..position-1]
    end if

    closeWindow(FindTutorialWindow)

--  SAVE pathName and then fileName to .dat file, including any other data:
    SaveDataToDatFile(pathName, fileName)

    setFocus(MainWindow)

 -- now USE it all to jump to Tutorial (or whatever):
   JumpToTutorial(pathName, fileName)

end procedure

setHandler(UserFindTutButton, w32HClick, routine_id("OnClick_UserFindTutButton"))

-----------------------------------------------
-- CENTER THE MODAL "CHOICE" WINDOW:
-- GOT THIS FROM WOLF'S TUTORIAL, MAYBE GetSystemMetricsIS IN WIN32LIB NOW?
procedure center_win_Horiz(atom win_id)
 sequence loc
 atom xsize,ysize,posx,posy
 loc=getSize(win_id)
 xsize=loc[3]-loc[1]
 ysize=loc[4]-loc[2]
 posx=floor((getSystemMetrics(SM_CXFULLSCREEN)/2)-(xsize/2))
 posy= 60  -- decided to over-ride the y centering
 moveWindow(win_id,posx,posy,xsize,ysize,1 )
end procedure
------------------------------------------------
-- AUTO FIND TUTORIAL:
procedure OnClick_AutoFindTutButton(integer self, integer event, sequence params)
sequence lookFor, inHere, tempFu
sequence idePaths, tutPaths -- just for if test here
integer tempPos
lookFor = {}
inHere = {}
tempFu = {} -- to strip "C:/" from return of findFuphoria
tempPos = 0

  setVisible(Button_UseSelectedTutorial,0)
  setVisible(Button_CancelAutoSelect,0)
  setVisible(StopSearchButton,1)
  StopOrNot = 0  -- don't stop search, unless it gets set from stop button


  setVisible(TutorialList, 0)
  center_win_Horiz(AutoFindTutorialWindow)  -- center it
  eraseItems(TutorialList) -- clear it

  -- SET UP TO LOOK FOR THESE FILES:
 if WhichButton = Tut1Button then
  lookFor = {"TUTOR3.EXW","WINTUTOR.EXW"}
  setText(AutoFindTutorialWindow, "SEARCHING FOR Win32Lib TUTORIALS")
  setText(Button_UseSelectedTutorial, "Use selected Tutorial")
  -- IN THESE DIRECTORIES:
  tempFu = FindFuphoria() -- get path of "Fuphoria" directory
  if length(tempFu) then
      -- remove "C:\"  & add drive from initial directory:
      tempFu = InitialDirectory[1..2] & "\\" & tempFu[4..length(tempFu)]
  end if
  inHere = {getenv("EUDIR"), tempFu}--,"C:\\"
  --FindFuphoria() gets path of Fuphoria (is in FFnx.ew)

 elsif WhichButton = IDEbutton then
  tempFu = FindFuphoria() -- get path of "Fuphoria" directory
  if length(tempFu) then
      -- remove "C:\"  & add drive from initial directory:
      tempFu = InitialDirectory[1..2] & "\\" & tempFu[4..length(tempFu)]
  end if
  lookFor = {"IDE.EXW"}
  inHere = {getenv("EUDIR"), tempFu}--,"C:\\"
  setText(AutoFindTutorialWindow, "SEARCHING FOR IDE's")
  setText(Button_UseSelectedTutorial, "Use selected IDE")
 end if

  -- MAKE A MODAL WINDOW:
  openWindow(AutoFindTutorialWindow , Modal )
  setFocus(AutoFindTutorialWindow)
  setText( SearchingForTutLabel ,"Searching...")


   -- NOW LOOK FOR THE FILES SET UP FOR ABOVE:
   -- (FindAll... is in FFnx.ew)
   -- last parameter: 1 says to search all sub dirs, 0 says just search root
  idePaths = {}
  tutPaths = {}
  if WhichButton = Tut1Button then
    TutorialsAndPaths  = FindAllSpecifiedFiles(lookFor, inHere, 1)
      tutPaths = TutorialsAndPaths
  elsif WhichButton = IDEbutton then
    IDEsAndPaths  = FindAllSpecifiedFiles(lookFor, inHere, 1)
    idePaths = IDEsAndPaths
  end if

  if StopOrNot then -- had clicked the "stop search" button sometime
       closeWindow(AutoFindTutorialWindow)
       return
  end if


  if length(tutPaths) > 0 or length(idePaths) > 0 then
  -- found some tutorials
   setText( SearchingForTutLabel ,"FOUND:")
   setVisible(StopSearchButton,0)
   if WhichButton = Tut1Button then -- reset window label to say "found"
      setText(AutoFindTutorialWindow, "FOUND Win32Lib TUTORIALS")
      for n = 1 to length(TutorialsAndPaths) do
         addItem(TutorialList,TutorialsAndPaths[n][2]
                    & "\\"& TutorialsAndPaths[n][3])
      end for


   elsif WhichButton = IDEbutton then
      setText(AutoFindTutorialWindow, "FOUND IDE's")
      for n = 1 to length(IDEsAndPaths) do
         addItem(TutorialList,IDEsAndPaths[n][2]
                    & "\\"& IDEsAndPaths[n][3])
      end for
   end if

   setVisible(TutorialList, 1)
   setVisible(Button_UseSelectedTutorial,1)

  else  -- no tutorials found
    if StopOrNot then
       closeWindow(AutoFindTutorialWindow)
       return
    end if
    setVisible(StopSearchButton,0)
    if WhichButton = Tut1Button then
      setText( SearchingForTutLabel ,"NO  TUTORIAL(s)  FOUND")
    elsif WhichButton = IDEbutton then
      setText( SearchingForTutLabel ,"NO  IDE(s)  FOUND")
    end if
  end if
    setVisible(Button_CancelAutoSelect,1)
end procedure
setHandler(AutoFindTutButton, w32HClick, routine_id("OnClick_AutoFindTutButton"))
---------------------------------------------------------------------
procedure OnClick_StopSearchButton(integer self, integer event, sequence params)
   StopOrNot = 1
end procedure

setHandler(StopSearchButton, w32HClick, routine_id("OnClick_StopSearchButton"))
---------------------------------------------------------------------
procedure JumpToSelectedTutorial(integer self, integer event, sequence params)
integer theIndex
theIndex =0

--  uses index of selected tutorial to reference to tuts in paths in include
  theIndex = getIndex(TutorialList)
  if theIndex > 0 then

   if WhichButton = Tut1Button then
     TutorialPathName = TutorialsAndPaths[theIndex][2]
     TutorialFileName = TutorialsAndPaths[theIndex][3]
     --  SAVE PathName and then FileName to .dat file, including any other:
     SaveDataToDatFile (TutorialPathName,TutorialFileName)
     closeWindow(AutoFindTutorialWindow)
     closeWindow(FindTutorialWindow)
     setFocus(MainWindow)
     JumpToTutorial(TutorialPathName , TutorialFileName )

   elsif WhichButton = IDEbutton then
     IdePathName = IDEsAndPaths[theIndex][2]
     IdeFileName = IDEsAndPaths[theIndex][3]
     --  SAVE PathName and then FileName to .dat file, including any other:
     SaveDataToDatFile (IdePathName,IdeFileName)
    closeWindow(AutoFindTutorialWindow)
    closeWindow(FindTutorialWindow)
    setFocus(MainWindow)
    JumpToTutorial(IdePathName , IdeFileName )
   end if
  end if

end procedure
setHandler(Button_UseSelectedTutorial, w32HClick, routine_id("JumpToSelectedTutorial"))

----------------------------------------------------------------------
-- CANCEL AUTO FINDING THE TUTORIAL:
procedure CancelSelectTutorial(integer self, integer event, sequence params)
    closeWindow(AutoFindTutorialWindow)
end procedure
setHandler(Button_CancelAutoSelect, w32HClick, routine_id("CancelSelectTutorial"))
-------------------------------------------------
-- CANCEL FINDING THE TUTORIAL:
procedure OnClick_CancelFindTutButton(integer self, integer event, sequence params)
    closeWindow(FindTutorialWindow)
  setFocus(MainWindow)
end procedure

setHandler(CancelFindTutButton, w32HClick, routine_id("OnClick_CancelFindTutButton"))
---------------------------------------------
procedure onClose_FindTutorialWindow (integer self, integer event, sequence params)
  moveZOrder(MainWindow, HWND_TOP)
end procedure
setHandler(FindTutorialWindow, w32HClose, routine_id("onClose_FindTutorialWindow"))
-------------------------------------------------------
procedure SetUserFindTextForIdeOrTutorial()  -- for IDE or Tutorial:
 if WhichButton = IDEbutton then
      setText(FindTutorialWindow, "Find IDE")
      setText(AutoFindTutButton, "Auto Find IDE")
      setText(UserFindTutButton, "User Find IDE")
      setText(CancelFindTutButton, "Cancel Find IDE")
   elsif WhichButton = Tut1Button then
      setText(FindTutorialWindow, "Find Win32Lib TUTORIAL")
      setText(AutoFindTutButton, "Auto Find Tutorial")
      setText(UserFindTutButton, "User Find Tutorial")
      setText(CancelFindTutButton, "Cancel Find Tutorial")
    end if
end procedure

---------------------------------------------
procedure OnClick_Tut1Button(integer self, integer event, sequence params)
integer fileHandle

fileHandle = open(TutorialPathName & "\\" & TutorialFileName, "r")
--fileHandle = open("c:\\Euphoria\\Win32Lib\\A new Tutorial\\Tutor3.exw","r")
if fileHandle != -1 then  -- is a file there
    close(fileHandle)
    JumpToTutorial( TutorialPathName, TutorialFileName )
else

   WhichButton = Tut1Button -- so generalized routine can function right
   SetUserFindTextForIdeOrTutorial()
-- GIVE USER CHOICE OF AUTO OR MANUAL SEARCH FOR TUTORIAL:
  center_win_Horiz(FindTutorialWindow)  -- center it
   -- MAKE THE MODAL WINDOW WHICH PRESENTS THE AUTO/MANUAL CHOICES:
  openWindow( FindTutorialWindow, Modal )
 --  (the choices happen on other events in this window)
 end if
end procedure

setHandler(Tut1Button, w32HClick, routine_id("OnClick_Tut1Button"))
-------------------------------------------------------------------------
--RIGHT CLICK ON TUTORIAL BUTTON: skips look for .dat file, brings choice

procedure onMouse_Tut1Button(integer self, integer event, sequence params)

if params[1]=RIGHT_DOWN then
   WhichButton = self
   SetUserFindTextForIdeOrTutorial()

  center_win_Horiz(FindTutorialWindow)  -- center it
-- MAKE A MODAL WINDOW:
  openWindow( FindTutorialWindow, Modal )
end if
end procedure

setHandler({Tut1Button, IDEbutton}, w32HMouse, routine_id("onMouse_Tut1Button"))
------------------------------------------------------------------------
procedure onClick_IDEbutton(integer self, integer event, sequence params)
--atom result

AfileHandle = open(IdePathName & "\\" & IdeFileName, "r")
--AfileHandle = open("Ide.exw", "r")
if AfileHandle != -1 then
   close(AfileHandle)
   Jump_to(
    -- passing YOUR main window's id:
    MainWindow,
    -- with the program to call:
    "exw.exe",
    -- in the current directory:
	IdePathName,
    -- the parameter to pass to exw.exe to run:
	IdeFileName, --"Ide.exw"
    -- and last, the 'show' parameter:
    SW_SHOWDEFAULT )
else
  WhichButton = IDEbutton --so generalized routine can work, when sent there
  SetUserFindTextForIdeOrTutorial()
-- GIVE USER CHOICE OF AUTO OR MANUAL SEARCH FOR TUTORIAL:
  center_win_Horiz(FindTutorialWindow)  -- center it
   -- MAKE THE MODAL WINDOW WHICH PRESENTS THE AUTO/MANUAL CHOICES:
  openWindow( FindTutorialWindow, Modal )
 --  (the choices happen on other events in this window)
end if

end procedure

setHandler(IDEbutton, w32HClick, routine_id("onClick_IDEbutton"))
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-- LIST MAINTENANCE SECTION (USER EDIT LISTS OF DEMOS & CATEGORIES)
-------------------------------------------------------------------------

-- SAVE NAME & DESCRIPTION OF DEMO NEWLY ADDED:
procedure onClick_Button_SaveNewDemoInfo(integer self, integer event, sequence params)
-- needs to know what folder, so as to put info in right place
--  should be SelectedTabFolder
-- add new demo data to Programs var;
-- add same to proper list;
-- write to file
-- close window


 setText(MainStatusBar,DemoPath)
-- add new demo data to Programs var:
-- (don't include path if not necessary)
                  -- had InitialDirectory below
   if not equal(DemoPath, DemoDirectory ) then
      Programs[SelectedTabFolder] &= {{DemoPath  & DemoName, getText(NewDemoDesc)}}
   else
      Programs[SelectedTabFolder] &= {{DemoName, getText(NewDemoDesc)}}
   end if

-- add new demo data to proper list:
addItem(ListsHandles[SelectedTabFolder], DemoName & ": " & getText(NewDemoDesc))

-- select the newly added item:
setIndex(ListsHandles[SelectedTabFolder], getCount(ListsHandles[SelectedTabFolder]))

-- select the tab folder it's added to:
setFocus(TabsNames[SelectedTabFolder][1])

-- now write all the new data to the .lst file:
WriteRunDemosListFile()

-- close the window:
closeWindow(DescribeNewDemoWindow)

end procedure
setHandler(Button_SaveNewDemoInfo, w32HClick, routine_id("onClick_Button_SaveNewDemoInfo"))
----------------------------------
procedure onClick_Button_CancelSaveAddNewDemo(integer self, integer event, sequence params)
  closeWindow(DescribeNewDemoWindow)
end procedure
setHandler(Button_CancelSaveAddNewDemo, w32HClick, routine_id("onClick_Button_CancelSaveAddNewDemo"))
---------------------------------------------
procedure DescribeNewDemo()
  openWindow(DescribeNewDemoWindow, Modal)
  moveZOrder(DescribeNewDemoWindow, HWND_TOP)
end procedure
---------------------------------
procedure SelectDemoToAdd()
sequence pathAndFileName,fileName, test--PathName,
--integer position

-- needs to know what folder, so as to put info in right place
--  should be SelectedTabFolder

--  open a "open file" dialog, starting in DemoDirectory:
   pathAndFileName = getOpenFileName( MainWindow, DemoDirectory & "*.exw", FileTypes & {"Euphoria Include", "*.E;*.EW"} )

-- add this right after FileTypes above if want includes to show:
--   & {"Euphoria Include", "*.E;*.EW"}

    -- entered a file name? if not, stay in dialog
    if length( pathAndFileName ) = 0 then
        return
    else
       setText(MainStatusBar, pathAndFileName)

       -- remove extent and path info from full pathfilename:
       fileName = RemovePathAndExtentFromFullFileName(pathAndFileName)
       DemoPath = fileName[1]  -- DemoPath is used outside this procedure
       fileName = fileName[2]

       setText(MainStatusBar, fileName)
       setText(Label_NewDemoDesc, "DESCRIBE new Demo: " & fileName)
       setText(NewDemoDesc, "")  -- clears edit line
       setText(MainStatusBar, fileName)
       limitText(NewDemoDesc, 50 - length(fileName))
       DemoName = fileName  -- used when saving to file

       if equal(TabsNames[SelectedTabFolder][2], "Numbered") then
          if not equal(upper(DemoName[1..2]), "EX") then  -- NOT "ex##.exw"
             setText(MainStatusBar, "can't add a non-numbered demo into \"numbered\" folder")
            -- don't allow adding any demos to 1st ("numbered") list,
            -- unless they have "ex" in front of a number

          else  -- does have "ex" in front of it, so remove it so not show:
             DemoName = DemoName[3..length(DemoName)]
             test = value(DemoName)
             if test[1] = GET_SUCCESS then  -- not a number after "ex"
               DescribeNewDemo()
             else
                 setText(MainStatusBar,
                  "can't add a non-numbered demo into \"numbered\" folder")
             end if
          end if

       else  -- NOT the "numbered" folder:
         DescribeNewDemo()
       end if
       -- add file info to Programs var?
    end if
end procedure
---------------------------------
procedure onClick_AddDemosButton(integer self, integer event, sequence params)

--  first give opportunity to select which list to add to:
    openWindow(SelectListWindow, Modal)
    moveZOrder(SelectListWindow, HWND_TOP)

--  show list of categories:
    eraseItems(ListOfCategories)
    for n = 1 to length(TabsNames) do
        addItem(ListOfCategories, TabsNames[n][2])
    end for
--  set initial index in list to whatever tab had been selected:
    for n = 1 to length(TabsNames) do
        if TabsNames[n][1] = getTabItem(Tabs) then
           setIndex(ListOfCategories, n)
           SelectedTabFolder = n
        end if
    end for
end procedure

setHandler(AddDemosButton, w32HClick, routine_id("onClick_AddDemosButton"))

----------------------
--  SELECT A CATEGORY TO ADD A DEMO TO:
procedure onMouse_EditList ( integer self, integer event, sequence params )
--sequence PathAndFileName,FileName,PathName
--integer position

   if params[1] = LeftDoubleClick then
      SelectedTabFolder = getIndex(ListOfCategories)
      closeWindow(SelectListWindow)
      SelectDemoToAdd()
   end if
end procedure

setHandler(ListOfCategories, w32HMouse, routine_id("onMouse_EditList"))
---------------------------------
-- same thing as above, but from click on button:
procedure onClick_Button_UseSelctdCategory(integer self, integer event, sequence params)
      SelectedTabFolder = getIndex(ListOfCategories)
      closeWindow(SelectListWindow)
      SelectDemoToAdd()
      setFocus(NewDemoDesc)
end procedure
setHandler(Button_UseSelctdCategory, w32HClick, routine_id("onClick_Button_UseSelctdCategory"))
-----------------------------------------------------------
procedure onClick_Button_CancelAddNewDemo(integer self, integer event, sequence params)
  closeWindow(SelectListWindow)
end procedure
setHandler(Button_CancelAddNewDemo, w32HClick, routine_id("onClick_Button_CancelAddNewDemo"))
--------------------------------------------
-- to make main window open back up from being minimized
procedure onClose_SelectEditWindow(integer self, integer event, sequence params)
    moveZOrder(MainWindow, HWND_TOP)
end procedure

setHandler(SelectEditWindow, w32HClose, routine_id("onClose_SelectEditWindow"))
--------------------------------------------------------------------
-- REMOVE DEMO FROM LIST SECTION:

procedure onClick_RemoveDemosButton(integer self, integer event, sequence params)
atom result

      result = message_box(
               "To remove a demo, click on it to select it," & {13,10} &
               "and press the <delete> key.",
		"Press <delete> to remove a demo", MB_OKCANCEL )
      if result = IDOK then
         closeWindow(SelectEditWindow)
      end if

end procedure

setHandler(RemoveDemosButton, w32HClick, routine_id("onClick_RemoveDemosButton"))
----------------------------------------------------------------------
-- REMOVE A CATEGORY (TAB ITEM):
procedure onClick_DeleteCatButton(integer self, integer event, sequence params)
atom result

      result = message_box(
               "To remove a CATEGORY (tab item), click on it to select it," & {13,10} &
               "and press the <CTRL><delete> key.",
		"Press <CTRL><delete> to remove a CATEGORY", MB_OKCANCEL )
      if result = IDOK then
         closeWindow(SelectEditWindow)
      end if

end procedure

setHandler(DeleteCatButton, w32HClick, routine_id("onClick_DeleteCatButton"))
--------------------------------------------------------------------
procedure onClick_MoveDemoButton(integer self, integer event, sequence params)
atom result
      result = message_box(
         "You can move a demo up or down in a category" & CR &
         "by pressing the <shift><up/downarrow> keys." & CR & CR &
         "You can move a demo to another category" & CR &
         "by pressing the <shift><left/rightarrow> keys",
         "MOVE A DEMO with <shift> <arrow> keys",MB_OKCANCEL )
      if result = IDOK then
         closeWindow(SelectEditWindow)
      end if
end procedure

setHandler(MoveDemoButton, w32HClick, routine_id("onClick_MoveDemoButton"))
----------------------------------------------------------------------
-- ADD NEW CATEGORY:
procedure onClick_AddCatButton(integer self, integer event, sequence params)  -- main button, main routine
   openWindow(AddNewCategoryWindow, Modal)
   setFocus(AddCategorySLE)
    moveZOrder(AddNewCategoryWindow, HWND_TOP)
end procedure
setHandler(AddCatButton, w32HClick, routine_id("onClick_AddCatButton"))
------------------------------
procedure onClick_Button_AddNewCategory(integer self, integer event, sequence params)  -- user says to add it

  if length(getText(AddCategorySLE)) then

      TabsNames = TabsNames & {{
                   create( TabItem, getText(AddCategorySLE),
                             Tabs, 0, 0, 0, 0, 0 ),
                             getText(AddCategorySLE) }}
      ListsHandles = ListsHandles & {
                         create( List, sprintf("List%d",
                         length(ListsHandles)+1),
                         TabsNames[length(ListsHandles)+1][1],
                         50, 50, 500, 275, 0 )}

      Programs = Programs & {{}}

      SelectedTabFolder = length(ListsHandles)

      -- AND INCLUDE THIS LIST IN EVENT TRAP!
      setHandler(ListsHandles[length(ListsHandles)], w32HMouse, routine_id("List_onMouse"))

     closeWindow(AddNewCategoryWindow)
     moveZOrder(MainWindow, HWND_TOP)
  else
    setFocus(AddCategorySLE)
  end if
end procedure
setHandler(Button_AddNewCategory, w32HClick, routine_id("onClick_Button_AddNewCategory"))
------------------------------
procedure onClick_Button_CancelAddNewCategory(integer self, integer event, sequence params)  -- user says DON'T add it
  closeWindow(AddNewCategoryWindow)
  moveZOrder(MainWindow, HWND_TOP)
end procedure
setHandler(Button_CancelAddNewCategory, w32HClick, routine_id("onClick_Button_CancelAddNewCategory"))

--------------------------------------------------------------------
function findActiveTab()
    for n = 1 to length(TabsNames) do
        -- compare tab id in TabsName with control id of selected tab:
        if TabsNames[n][1] = getTabItem(Tabs) then
           return n -- = number, 1..n of tab, NOT "ID"
           exit
        end if
    end for

end function
----------------------------------
-- DELETE DEMO OR CATEGORY BY KEYPRESS:

procedure onEvent_SpecialKeyPressed(integer self, integer event, sequence params)
atom result
sequence CR
integer itemSelected, newSelectedPosition
atom listID
sequence itemsInList, itemToMove

integer listCount

CR = {13,10} -- cr linefeed
itemSelected = 0
newSelectedPosition = 0
itemsInList= {}
itemToMove = {}

 -- if in "change description" etc, exit this procedure so delete key
 --  can work in SLE to remove text that was previous description:
 if self = NewDescriptionSLE or self = AddCategorySLE
    or self = NewDemoDesc  or self = CatNameSLE then
    return
 end if

 if params[1] = VK_DELETE then

     --  find tab, list:  (used in both <delete> and <ctrl><delete>)
    SelectedTabFolder = findActiveTab() -- = number, 1..n of tab, NOT "ID"

   -- <DELETE> KEY:
   if params[2] = 0 then -- just <delete> key, remove demo
     listID = ListsHandles[SelectedTabFolder]  -- should be id of list
     -- get a copy of all items initially in the list:
     for n = 1 to getCount(listID) do
        itemsInList &= {getItem(listID , n)}
     end for

     itemSelected = getIndex(listID)

    -- find tab, list, item; open window, ask if want to delete item;
    --  if yes, slice out of Programs var, re-write file
    if itemSelected > 0 then  -- ask only if an item in list selected
     result = message_box(
              "Do you wish to remove " & CR &
               getItem(ListsHandles[SelectedTabFolder],itemSelected) & CR &
               " from: " & TabsNames[SelectedTabFolder][2] & " Examples?",
               "Remove Demo?", MB_YESNO )
     if result = IDYES then
         -- slice out demo from var:
         if itemSelected = 1 then
             Programs[SelectedTabFolder]=Programs[SelectedTabFolder]
                                   [2..length(Programs[SelectedTabFolder])]
             itemsInList = itemsInList[2..length(itemsInList)]
             newSelectedPosition = 1
         elsif itemSelected = length(Programs[SelectedTabFolder]) then
             Programs[SelectedTabFolder]=Programs[SelectedTabFolder]
                                         [1..itemSelected -1]
             itemsInList = itemsInList[1..itemSelected -1]
             newSelectedPosition = itemSelected -1
         else
            Programs[SelectedTabFolder]= Programs[SelectedTabFolder]
                     [1..itemSelected-1] &
                     Programs[SelectedTabFolder]
                    [itemSelected + 1..length(Programs[SelectedTabFolder])]
            itemsInList = itemsInList[1..itemSelected-1] &
                 itemsInList[itemSelected + 1..length(itemsInList)]
             newSelectedPosition = itemSelected
         end if

         -- repopulate list:
         eraseItems(listID)-- should be listIsListOfCategories

         -- if any IN list!:
         if length(itemsInList) > 0 then -- only if anything now in list
         for n = 1 to length(Programs[SelectedTabFolder])do
             addItem(listID,itemsInList[n])
         end for
         -- re-set index:
         setIndex(listID, newSelectedPosition)
         end if

         -- now write all the new data to the .lst file:
         WriteRunDemosListFile()

     end if
    end if



   -- <CTRL><DELETE>:
   elsif params[2] = ControlMask then  -- <cntrl><delete>, remove category
    -- ask if for sure delete,
     result = message_box(
              "Do you wish to remove " & CR & "Tab Folder: " &
               TabsNames[SelectedTabFolder][2] & "Examples" & CR &
               "and LIST OF ALL DEMOS IN THIS FOLDER?",
               "Remove Tab Folder?", MB_YESNO )

   -- destroy list associated with tab
   destroy(ListsHandles[SelectedTabFolder])

   -- try making the tab item INVISIBLE first?
   setVisible(TabsNames[SelectedTabFolder][1],0)
   setVisible(Tabs, 1)

   -- destroy tab
   destroy(TabsNames[SelectedTabFolder][1])

   -- remove tab name & handle  from TabsNames at [SelectedTabFolder],
   -- and also remove list handle from ListsHandles at same time,
   -- and also remove all demos names & descriptions in folder from Programs

     TabsNames = TabsNames[1..SelectedTabFolder -1] &
                 TabsNames[SelectedTabFolder +1..length(TabsNames)]
     ListsHandles = ListsHandles[1..SelectedTabFolder -1] &
                 ListsHandles[SelectedTabFolder +1..length(ListsHandles)]
     Programs = Programs[1..SelectedTabFolder -1] &
                 Programs[SelectedTabFolder +1..length(Programs)]

     -- now write all the new data to the .lst file:
     WriteRunDemosListFile()

   end if


 elsif params[1] = VK_INSERT then

   if params[2] = 0 then  -- just <insert>, so add a demo:
      onClick_AddDemosButton(-1, -1, {})
   elsif params[2] = 2 then  -- <ctrl><insert>, so add a category:
       -- ask user what name they want for new category:
      onClick_AddCatButton(-1, -1, {})
   end if
   -- now SAVE all data to .dat file so will be used next time:
   WriteRunDemosListFile()


 elsif params[1] = VK_DOWN then
   if params[2] = 1 then  -- MOVE DEMO DOWN ONE in category:
      --  find tab, list:
      SelectedTabFolder = findActiveTab()
          -- SelectedTabFolder is a number, 1..n of tab, NOT "ID" handle!
      listCount = getCount(ListsHandles[SelectedTabFolder])
      itemSelected = getIndex(ListsHandles[SelectedTabFolder])
      itemToMove = getItem(ListsHandles[SelectedTabFolder],itemSelected)

      if  listCount and itemSelected and itemSelected < listCount then
         for n = 1 to listCount do
            itemsInList &= {getItem(ListsHandles[SelectedTabFolder],n)}
         end for
         -- swap postions of items in the list:
         itemToMove = itemsInList[itemSelected + 1]
         itemsInList[itemSelected + 1] = itemsInList[itemSelected]
         itemsInList[itemSelected] = itemToMove
         -- erase the list:
         eraseItems(ListsHandles[SelectedTabFolder])
         -- re do the list:
         for n = 1 to listCount do
             addItem(ListsHandles[SelectedTabFolder], itemsInList[n])
         end for
         -- select the moved item in the list:
         setFocus(ListsHandles[SelectedTabFolder]) -- so keypress can work
         -- was not setting index correctly if move 1st item
         -- immediately after selecting tab,
         --  because tab gets focus when selected?? following if fixes it:
         if equal(self, ListsHandles[SelectedTabFolder]) then
            setIndex(ListsHandles[SelectedTabFolder], itemSelected )
         else
            setIndex(ListsHandles[SelectedTabFolder], itemSelected +1 )
         end if
         -- swap the program name/description data in Programs var:
            -- (re-use var itemToMove)
         itemToMove = Programs[SelectedTabFolder][itemSelected + 1]
         Programs[SelectedTabFolder][itemSelected + 1] =
                        Programs[SelectedTabFolder][itemSelected]
         Programs[SelectedTabFolder][itemSelected] = itemToMove
      end if
   end if


 elsif params[1] = VK_LEFT then -- move demo one cat LEFT
    if params[2] = 1 then
      SelectedTabFolder = findActiveTab()
       -- SelectedTabFolder got tab folder number (NOT handle!)
      itemSelected = getIndex(ListsHandles[SelectedTabFolder])
      itemToMove = getItem(ListsHandles[SelectedTabFolder],itemSelected)

      if SelectedTabFolder > 1 and itemSelected then
         result = deleteItem(ListsHandles[SelectedTabFolder], itemSelected)
         listCount = getCount(ListsHandles[SelectedTabFolder])
         addItem(ListsHandles[SelectedTabFolder - 1], itemToMove)

         if itemSelected > listCount then
             setIndex(ListsHandles[SelectedTabFolder ],listCount)
         else
             setIndex(ListsHandles[SelectedTabFolder ], itemSelected)
         end if

         setIndex(ListsHandles[SelectedTabFolder - 1],
               getCount(ListsHandles[SelectedTabFolder - 1]))

setText(MainStatusBar, sprint(self)& "  " & sprint(ListsHandles[SelectedTabFolder])& "   " & sprint(SelectedTabFolder))
         if equal(self, ListsHandles[SelectedTabFolder]) then
            setFocus(TabsNames[SelectedTabFolder-1][1])
            setFocus(ListsHandles[SelectedTabFolder - 1])
         else  -- can't get it to put focus on moved demo if before focus
--            setFocus(TabsNames[SelectedTabFolder][1])
--            setFocus(ListsHandles[SelectedTabFolder ])
         end if

         -- copy the program name/description data from old to new cat var,
         -- and remove that data from old category variable
         Programs[SelectedTabFolder-1] &=
                  {Programs[SelectedTabFolder][itemSelected]}
         Programs[SelectedTabFolder] =
            Programs[SelectedTabFolder][1..itemSelected - 1] &
                Programs[SelectedTabFolder]
                   [itemSelected + 1..length(Programs[SelectedTabFolder])]


      end if
   end if

 elsif params[1] = VK_RIGHT then -- move demo one cat RIGHT
    if params[2] = 1 then
      SelectedTabFolder = findActiveTab()
       -- SelectedTabFolder got tab folder number (NOT handle!)
      itemSelected = getIndex(ListsHandles[SelectedTabFolder])
      itemToMove = getItem(ListsHandles[SelectedTabFolder],itemSelected)

      if SelectedTabFolder < length(TabsNames) and itemSelected then
         result = deleteItem(ListsHandles[SelectedTabFolder], itemSelected)
         listCount = getCount(ListsHandles[SelectedTabFolder])
         addItem(ListsHandles[SelectedTabFolder + 1], itemToMove)

         if itemSelected > listCount then
             setIndex(ListsHandles[SelectedTabFolder ],listCount)
         else
             setIndex(ListsHandles[SelectedTabFolder ], itemSelected)
         end if

         setFocus(ListsHandles[SelectedTabFolder + 1])
         setIndex(ListsHandles[SelectedTabFolder + 1],
               getCount(ListsHandles[SelectedTabFolder + 1]))

          if equal(self, ListsHandles[SelectedTabFolder]) then
            setFocus(TabsNames[SelectedTabFolder+1][1])
            setFocus(ListsHandles[SelectedTabFolder + 1])
         else  -- can't get it to put focus on moved demo if before focus
--            setFocus(TabsNames[SelectedTabFolder][1])
--            setFocus(ListsHandles[SelectedTabFolder ])
         end if


         -- copy the program name/description data from old to new cat var,
         -- and remove that data from old category variable
         Programs[SelectedTabFolder+1] &=
                  {Programs[SelectedTabFolder][itemSelected]}
         Programs[SelectedTabFolder] =
            Programs[SelectedTabFolder][1..itemSelected - 1] &
                Programs[SelectedTabFolder]
                   [itemSelected + 1..length(Programs[SelectedTabFolder])]
      end if
   end if


 elsif params[1] = VK_UP then    -- move demo up one in category
   if params[2] = 1 then  -- MOVE DEMO *UP* ONE in category:
      --  find tab, list:
      SelectedTabFolder = findActiveTab()
          -- SelectedTabFolder is a number, 1..n of tab, NOT "ID" handle!
      listCount = getCount(ListsHandles[SelectedTabFolder])
      itemSelected = getIndex(ListsHandles[SelectedTabFolder])
      itemToMove = getItem(ListsHandles[SelectedTabFolder],itemSelected)

      if  listCount and itemSelected and itemSelected > 1 then
         for n = 1 to listCount do
            itemsInList &= {getItem(ListsHandles[SelectedTabFolder],n)}
         end for
         -- swap postions of items in the list:
         itemToMove = itemsInList[itemSelected - 1]
         itemsInList[itemSelected - 1] = itemsInList[itemSelected]
         itemsInList[itemSelected] = itemToMove
         -- erase the list:
         eraseItems(ListsHandles[SelectedTabFolder])
         -- re do the list:
         for n = 1 to listCount do
             addItem(ListsHandles[SelectedTabFolder], itemsInList[n])
         end for
         -- select the moved item in the list:
         setFocus(ListsHandles[SelectedTabFolder]) -- so keypress can work
         -- was not setting index correctly if move 1st item
         -- immediately after selecting tab,
         --  because tab gets focus when selected?? following if fixes it:
         if equal(self, ListsHandles[SelectedTabFolder]) then
            setIndex(ListsHandles[SelectedTabFolder], itemSelected )
         else
            setIndex(ListsHandles[SelectedTabFolder], itemSelected -1 )
         end if
         -- swap the program name/description data in Programs var:
            -- (re-use var itemToMove)
         itemToMove = Programs[SelectedTabFolder][itemSelected - 1]
         Programs[SelectedTabFolder][itemSelected - 1] =
                        Programs[SelectedTabFolder][itemSelected]
         Programs[SelectedTabFolder][itemSelected] = itemToMove
      end if
   end if
end if
end procedure

setHandler(Screen, w32HKeyDown, routine_id("onEvent_SpecialKeyPressed"))
-----------------------------------------------------------------------
-----------------------------------------------------------------------
--  CHANGE DEMO DESCRIPTION PROCEDURES:
------------------------------------------
-- to make main window open back up from being minimized
-- when user uses <insert> key to add a demo
procedure onClose_DescribeNewDemoWindow(integer self, integer event, sequence params)
    setText(MainStatusBar, "")
    moveZOrder(MainWindow, HWND_TOP)
end procedure

setHandler(DescribeNewDemoWindow, w32HClose, routine_id("onClose_DescribeNewDemoWindow"))

--------------------------------------------------------------------------
procedure onClick_ChangeDescButton(integer self, integer event, sequence params)
atom listIs
sequence fileName


-- find out which tab, list is active;
-- find out which item is selected;
-- show current description in status bar?
-- open another window, show current description in edit line,
-- with button to save/cancel change

-- on click save button:
-- replace new description in Programs var;
-- save to .lst file

   SelectedTabFolder = findActiveTab()   -- = number, 1..n of tab, NOT "ID"
   listIs = ListsHandles[SelectedTabFolder]  -- should be id of list
   SelectedDemoIndex = getIndex(listIs)
   if SelectedDemoIndex < 1 then
      setText(MainStatusBar, "you must first select a demo")
      return
   end if
   setText(MainStatusBar, Programs[SelectedTabFolder][SelectedDemoIndex][2])
   fileName = getItem(listIs, SelectedDemoIndex)
   fileName = fileName[1..length(fileName)
             - length(Programs[SelectedTabFolder][SelectedDemoIndex][2])-2]
   setText(MainStatusBar, fileName)
   limitText(NewDescriptionSLE, 62 - length(fileName))
   setText(NewDescriptionSLE, Programs[SelectedTabFolder][SelectedDemoIndex][2])
   setText(ChDescrLabel1, "FOLDER: " & TabsNames[SelectedTabFolder][2] & " Examples")
   setText(ChDescrLabel2, "DEMO: " & getItem(listIs, SelectedDemoIndex))

   openWindow(ChangeDemoDescriptionWindow, Modal)
   moveZOrder(ChangeDemoDescriptionWindow, HWND_TOP)
   setText(MainStatusBar, "if you DON'T want to change THIS demo's description, CANCEL, and select the one you want to change")

end procedure

setHandler(ChangeDescButton, w32HClick, routine_id("onClick_ChangeDescButton"))
------------------------------------------
procedure onClick_Button_SaveDemoNewDescription(integer self, integer event, sequence params)
atom listIs
sequence copyOfList
copyOfList = {}

-- to save to .lst file, do:

   -- replace new description in Programs var:
   Programs[SelectedTabFolder][SelectedDemoIndex][2]=
                                getText(NewDescriptionSLE)

   -- repopulate list to include new description:
   listIs = ListsHandles[SelectedTabFolder]  -- should be id of list
   for n = 1 to length(Programs[SelectedTabFolder]) do
       copyOfList &= {getItem(listIs,n)}
   end for
   eraseItems(listIs)
   for n = 1 to length(Programs[SelectedTabFolder]) do
      if n != SelectedDemoIndex then
         addItem(listIs, copyOfList[n])
      else-- add everything up to colon from copy, then from SLE
         addItem(listIs, copyOfList[n][1..find(':',copyOfList[n]) + 1]
                         & getText(NewDescriptionSLE))
      end if
    end for

    -- set changed demo selected again:
    setIndex(listIs, SelectedDemoIndex)

    -- save info to RunDemos.Lst file:
    WriteRunDemosListFile()

    -- close both windows:
    closeWindow(ChangeDemoDescriptionWindow)
    closeWindow(SelectEditWindow)

end procedure

setHandler(Button_SaveDemoNewDescription, w32HClick, routine_id("onClick_Button_SaveDemoNewDescription"))
-------------------------------------------
procedure onClose_ChangeDemoDescriptionWindow(integer self, integer event, sequence params)
  setText(MainStatusBar, "")
end procedure

setHandler(ChangeDemoDescriptionWindow, w32HClose, routine_id("onClose_ChangeDemoDescriptionWindow"))

-------------------------------------------
procedure onClick_Button_CancelNewDemoDescription(integer self, integer event, sequence params)
    closeWindow(ChangeDemoDescriptionWindow)
end procedure

setHandler(Button_CancelNewDemoDescription, w32HClick, routine_id("onClick_Button_CancelNewDemoDescription"))

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--  IMPORT DEMOS PROCEDURES:
--------------------------------------
procedure OnClick_ImportButton(integer self, integer event, sequence params)
--atom result

  openWindow(ImportWindow, Modal)
  setFocus(CatNameSLE)  -- didn't seem to work
  setText(MainStatusBar, "")

end procedure

setHandler(ImportButton, w32HClick, routine_id("OnClick_ImportButton"))
--------------------------------------------------------------------------
procedure onClose_ImportWindow (integer self, integer event, sequence params)
  setText(MainStatusBar, "")
  setText(ImportWindow, "Import Demos")
  moveZOrder(MainWindow, HWND_TOP)
end procedure
setHandler(ImportWindow, w32HClose, routine_id("onClose_ImportWindow"))
--------------------------------------------------------------------------
procedure ImportDemos(integer self, integer event, sequence params)
object button
sequence dirToUse
sequence pathAndFileName
integer position
object allFiles
sequence allEuInDir, tempFiles
sequence newCatName, catNameFromSle
sequence test

allEuInDir = {}
dirToUse = DemoDirectory -- just to be safe (had InitialDirectory here)
catNameFromSle = getText(CatNameSLE)
setText(MainStatusBar, "")

-- since there may not be a "select directory" dialog,
-- either just do it for current directory,
-- or try to use "open file" & just use the directory part?

--is "use initial directory" or "allow user select directory" checked?
  if isChecked(RBinitDir) then
     dirToUse = DemoDirectory
  elsif isChecked(RBselDir) then
   --open a "open file" dialog:
   pathAndFileName = getOpenFileName( MainWindow, "", FileTypes )
    -- entered a file name? if not, stay in dialog
    if length( pathAndFileName ) = 0 then
        return
    else
	--separate the path from the path & file name:
	for p = length(pathAndFileName) to 1 by -1 do
	   if equal(pathAndFileName[p],'\\') then
	      position = p  -- find position of LAST \, right before filename
		exit
	   end if
	end for
      dirToUse = pathAndFileName[1..position-1]  -- just the dir path
    end if
  end if

  -- no matter what's checked, have to get all files to begin with:
  allFiles = dir(dirToUse & "\\*.exw") -- returns -1 if nothing found
  --handle it?!
  if not sequence(allFiles) and allFiles = -1 then
     setText(MainStatusBar, "no .exw files found")
     return
  end if
  -- remove the files extent, to be consistent
  for n = 1 to length(allFiles) do
     allFiles[n][1] = allFiles[n][1][1..length(allFiles[n][1]) - 4]
     allEuInDir &= {allFiles[n][1]}
  end for

  newCatName = "ALL Eu programs from " & dirToUse -- gets changed if necess.

  -- REMOVE KNOWN NON-DEMOS:
  if isChecked(CkImportXnon) then -- remove known non-demos
     position = 0
     for n = 1 to length(KnownNonDemos) do
       position = find(upper(KnownNonDemos[n]), upper(allEuInDir))
       if position then
          allEuInDir = allEuInDir[1..position-1]
             & allEuInDir[position + 1..length(allEuInDir)]
       end if
     end for
     newCatName = "All Eu EXCEPT non-demos from " & dirToUse
  end if

  -- REMOVE ANY ALREADY IN LISTS:
  if isChecked(CkImportXdupl) then
     position = 0
     for m = 1 to length(Programs) do
         for n = 1 to length(Programs[m]) do
             position = find(upper(Programs[m][n][1]), upper(allEuInDir))
             if position then
                allEuInDir = allEuInDir[1..position-1]
                            & allEuInDir[position + 1..length(allEuInDir)]
             end if
         end for
     end for
     newCatName = "All NEW Eu programs from " & dirToUse
  end if

  -- REMOVE NUMBERED EXAMPLES:
  if isChecked(CkImportXnum) then
    position = 0
    while position < length(allEuInDir) do
      position +=1
      if match("EX", upper(allEuInDir[position])) = 1 then
         test = value(allEuInDir[position][3..length(allEuInDir[position])])
         if test[1] = GET_SUCCESS then
             allEuInDir = allEuInDir[1..position-1]
                  & allEuInDir[position + 1..length(allEuInDir)]
             position -= 1
         end if
      end if
    end while
       newCatName = "All Eu programs EXCEPT numbered from " & dirToUse
  end if

 -- IF NO FILES FOUND, REMAIN IN IMPORT; OTHERWISE PUT THEM INTO TABFOLDER:
 if length(allEuInDir) = 0 then -- no files found meeting filter conditions
     setText(MainStatusBar,
      "no files to import found in this directory, using filters specified")
     setText(CatNameSLE, "")
     setText(ImportWindow, "Import Demos:    none found")
     setFocus(CatNameSLE)

 else  -- there are files found, so go ahead & make new folder & fill it:

  -- SET THE CATEGORY NAME FOR NEW FOLDER:
  if isChecked(CkImportXdupl) and isChecked(CkImportXnum)
    and isChecked(CkImportXnon)then
    newCatName = "All NEW Eu programs EXCEPT numbered and non-demos, from " & dirToUse
  elsif isChecked(CkImportXnon) and isChecked(CkImportXdupl) then
       newCatName = "All NEW Eu programs EXCEPT non-demos, from " & dirToUse
  elsif isChecked(CkImportXnon) and isChecked(CkImportXnum) then
    newCatName = "All Eu programs EXCEPT non-demos and numbered, from " & dirToUse
  elsif isChecked(CkImportXdupl) and isChecked(CkImportXnum) then
    newCatName = "All NEW Eu programs EXCEPT numbered, from " & dirToUse
  end if

  ---------------
  -- now do following for whichever ones got through:

  -- get a name for the new category, if user supplied one:
  if length(catNameFromSle) > 0 then
     newCatName = catNameFromSle
     setText(CatNameSLE, "")
  end if

  -- make new tab/category & a list for it:
  TabsNames = TabsNames & {{
                   create( TabItem, newCatName, Tabs, 0, 0, 0, 0, 0 ),
                             newCatName }}
  ListsHandles = ListsHandles & {
                         create( List, sprintf("List%d",
                         length(ListsHandles)+1),
                         TabsNames[length(ListsHandles)+1][1],
                         50, 50, 500, 275, 0 )}

  Programs = Programs & {{}}

  SelectedTabFolder = length(ListsHandles)

  -- INCLUDE THIS NEW LIST IN EVENT TRAP!
  setHandler(ListsHandles[length(ListsHandles)], w32HMouse, routine_id("List_onMouse"))

  -- put the files found earlier into the Programs var:
  for n = 1 to length(allEuInDir) do
     if equal(dirToUse,DemoDirectory) then
        Programs[SelectedTabFolder] &= {{allEuInDir[n],""}}
     else
        Programs[SelectedTabFolder] &= {{dirToUse & "\\"
                                       & allEuInDir[n],""}}
     end if
     addItem(ListsHandles[SelectedTabFolder], allEuInDir[n] & ": " )--"test"
  end for

  -- now SAVE all data to .dat file so will be used next time!
  WriteRunDemosListFile()

  setFocus(CatNameSLE)  -- so is auto selected for user when return
  closeWindow(ImportWindow)

end if
end procedure

setHandler(ImportAllButton, w32HClick, routine_id("ImportDemos"))
---------------------------------------------------------------------------
---------------------------------------------------------------------------
--  SHOW OR DON'T SHOW HOW TO USE OPEN FILE TO SELECT DIRECTORY:
procedure ShowGetDirectoryInfo (integer self, integer event, sequence params)

  if isChecked(RBinitDir) then
     setText(RBinfoLabel, "")
  elsif isChecked(RBselDir) then
     setText(RBinfoLabel, "Note: after selecting a directory in dialog," & CR & "select ANY file to close dialog.")
  end if
  setFocus(CatNameSLE)

end procedure

setHandler({RBselDir, RBinitDir}, w32HClick, routine_id("ShowGetDirectoryInfo"))
setHandler(ImportWindow, w32HOpen, routine_id("ShowGetDirectoryInfo"))
---------------------------------------------------------------------------
---------------------------------------------------------------------------
-- CONSTANTS PROCEDURES:
procedure OnClick_ConstantsButton(integer self, integer event, sequence params)
  openWindow(ConstantsWindow, Modal)
end procedure

setHandler(ConstantsButton, w32HClick, routine_id("OnClick_ConstantsButton"))
---------------------------------------------------------------------------
--  HELP PROCEDURES:
------------------------------
procedure OnClick_HelpButton(integer self, integer event, sequence params)
  openWindow(HelpWindow, Modal)
end procedure

setHandler(HelpButton, w32HClick, routine_id("OnClick_HelpButton"))
-------------------------------------------------------
procedure onChange_Hlp_List (integer self, integer event, sequence params)
integer index

    setText(MainStatusBar, "")
    index = getIndex(Hlp_List)
    if index > 0 then
        setText(HlpInfoLabel, HlpMessages[index])
        if length(HlpTitle[index]) = 0 then
            setText(HelpWindow, "Help")
        else
            setText(HelpWindow, "Help Topic:    " & HlpTitle[index])
        end if
    end if
end procedure

setHandler(Hlp_List, w32HChange, routine_id("onChange_Hlp_List"))
--------------------------------------------------------------------------

--------------------------------------------------------------------------
integer HlpFirstTimeFlag  -- for first time open help window, sets "about"
HlpFirstTimeFlag = 1
procedure onOpen_HelpWindow(integer self, integer event, sequence params)

 if HlpFirstTimeFlag then

   setText(HelpWindow, "Help:                        ABOUT RunDemos     version " & Version)
   setIndex(Hlp_List, 19)
   setText(HlpInfoLabel, HlpMessages[19])
   HlpFirstTimeFlag = 0
 end if

end procedure
setHandler(HelpWindow, w32HOpen, routine_id("onOpen_HelpWindow"))
-------------------------------------------------------------------------
procedure onClose_HelpWindow(integer self, integer event, sequence params)
   setText(MainStatusBar, " ")
   moveZOrder(MainWindow, HWND_TOP)
--   setText(MainStatusBar, " ")
end procedure
setHandler(HelpWindow, w32HClose, routine_id("onClose_HelpWindow"))
---------------------------------------------------------------------------

-------------------------------------------------------------------------
sequence VKconstant  -- used in and below following procedure
VKconstant = {}
-----------------------------------
procedure GetVKconstant()
integer index, posDash, posVK
sequence aLine
    index = getIndex(VKList)
    aLine= getItem(VKList,index)
    posDash = match("--", aLine)
    posVK  = match("VK_", aLine)
    if posDash = 1 or posVK = 0 then
      setText(ConStatusBar,"" )
      VKconstant = {}
    elsif posVK then
      aLine = aLine[posVK..length(aLine)]
      aLine = aLine[1..find(' ', aLine)-1]
      VKconstant = aLine  -- may not need this HERE; or maybe do?
       setText(ConStatusBar,aLine
            & " : double-click on it in list to copy it to clipboard")
    end if
end procedure
----------------------------------------------------
sequence W32Hconstant
W32Hconstant = {}

procedure GetW32Hconstant()
integer index ,posProc
sequence aLine
    index = getIndex(w32HList)
    aLine= getItem(w32HList,index)
    aLine= aLine[2..length(aLine)-1]
    posProc = match("proc", aLine)
    if match("w32H", aLine) = 1 then
      aLine = aLine[1..find(' ', aLine)]  -- truncate at first space
      W32Hconstant = aLine  -- may not need this HERE; or maybe do?
       setText(ConStatusBar,aLine
            & " : double-click on it in list to copy it to clipboard")
      if isChecked(FullStateRB) then
         W32Hconstant =  "setHandler(SomeControlID,"
            & aLine & ", routine_id( \"on" & aLine[5..length(aLine)]
            & "_SomeControl\" ))"
       setText(ConStatusBar,aLine
            & " -- to copy EVENT TEMPLATE, double-click on item in list")

      elsif isChecked(BothStateRB) then
          W32Hconstant = "procedure on" & aLine[5..find(' ',aLine)-1] &
                "_SomeControl (" & W32Hparameters[index] & ")" & CR
                 & "end procedure" & CR
          aLine = aLine[1..find(' ',aLine)-1]
          W32Hconstant&= "setHandler( SomeControl, " & aLine
             & ", routine_id( \"on" & aLine[5..length(aLine)]
             & "_SomeControl\" ))" & CR
             & "--replace \"SomeControl\" above"
             & " with your relevant controlID name"
          setText(ConStatusBar,aLine
             & " -- to copy PROCEDURE and EVENT template,"
             & " double-click on item in list")
      end if

    elsif posProc = 1 then
      aLine = aLine[6..find(')', aLine)]
      W32Hconstant = aLine
       setText(ConStatusBar,aLine[1..find('(',aLine)] & " parameters )"
            & " : double-click on it in list to copy it to clipboard")

    else
      setText(ConStatusBar,"" )
      W32Hconstant = {}
    end if
end procedure

----------------------------------------------
-- sequence OnEventsConstant  -- used in and below following procedure
-- OnEventsConstant = {}
-- 
-- procedure GetOnEventsConstant()
-- integer index
-- sequence aLine
--     index = getIndex(onEventsList)
--     aLine= getItem(onEventsList,index)
--     aLine = aLine[2..find(')',aLine)]  -- truncate at last parenthesis
-- 
--     if isChecked(FullStateRB) then
--        aLine = aLine[1..find('(',aLine)-1] -- truncate at FIRST parenthe
--         OnEventsConstant = aLine & "[SomeControl] = routine_id(\""
--             & aLine & "_SomeControl\")"
--        setText(ConStatusBar,aLine
--             & " -- to copy EVENT TEMPLATE, double-click on item in list")
-- 
--     elsif isChecked(BothStateRB) then
--         OnEventsConstant = "procedure " & aLine[1..find('(',aLine)-1]
--             & "_SomeControl" & aLine[find('(',aLine)..find(')',aLine)]
--             & CR & "end procedure" & CR
--        aLine = aLine[1..find('(',aLine)-1]
--        OnEventsConstant &= aLine
--             & "[SomeControl] = routine_id(\"" & aLine & "_SomeControl\")"
--             & CR & "--replace \"SomeControl\" above"
--             & " with your relevant controlID name"
--        setText(ConStatusBar,aLine
--             & " -- to copy PROCEDURE and EVENT template,"
--             & " double-click on item in list")
-- 
--     else
--       OnEventsConstant = aLine  -- may not need this HERE; or maybe do?
--       setText(ConStatusBar,aLine
--             & " : double-click on it in list to copy it to clipboard")
--     end if
-- end procedure
-- 
-----------------------------------------
sequence ColorsConstant  -- used in and below following procedure
ColorsConstant = {}

procedure GetColorsConstant()
integer index
sequence aLine
    index = getIndex(ColorsList)
    aLine= getItem(ColorsList,index)
    aLine = aLine[2..length(aLine) -1]
    if not match("--",aLine)= 1 then
      aLine = aLine[1..find(' ',aLine)]
      ColorsConstant = aLine  -- may not need this HERE; or maybe do?
      setText(ConStatusBar,aLine
            & " : double-click on it in list to copy it to clipboard")
    else
      aLine = aLine[3..find(')',aLine)]
      ColorsConstant = aLine[match("rgb",aLine)..length(aLine)]
      setText(ConStatusBar,aLine
            & " : double-click on it in list to copy RGB to clipboard")
    end if
end procedure
----------------------------------------------
sequence ControlsConstant  -- used in and below following procedure
ControlsConstant = {}

procedure GetControlsConstant()
integer index
sequence aLine
    index = getIndex(ControlsList)
    aLine= getItem(ControlsList,index)

      aLine = aLine[2..length(aLine)]
      aLine = aLine[1..find(' ',aLine)]
      ControlsConstant = aLine
      if isChecked(CreateRB) then
         aLine = aLine[1..find(' ',aLine)-1] -- truncate at first space
         ControlsConstant = "=create(" & aLine & ", \"aCaption\",ownerID,x,y,w,h,aStyle)"
         setText(ConStatusBar,aLine
            & " : double-click to copy CREATE template to clipboard")

      elsif isChecked(ExtendedRB) then
         aLine = aLine[1..find(' ',aLine)-1]
         ControlsConstant = "=createEx(" & aLine & ", \"aCaption\",ownerID,x,y,w,h,aStyle,anExtendedStyle)"
         setText(ConStatusBar,aLine
            & " : double-click to copy EXTENDED create template to clipboard")

      else
         setText(ConStatusBar,aLine
            & " : double-click on it in list to copy it to clipboard")
      end if


end procedure

--------------------------------------------------------------------------

sequence MouseEventsConstant
MouseEventsConstant = {}

procedure GetMouseEventsConstant()
integer index ,posFunc
sequence aLine
    index = getIndex(MouseEventsList)
    aLine= getItem(MouseEventsList,index)
    if length(aLine) > 1 then
      aLine= aLine[2..length(aLine)-1]
      posFunc = match("func", aLine)
      if posFunc = 0 then
        aLine = aLine[1..find(' ', aLine)]
        MouseEventsConstant = aLine  -- may not need this HERE; or maybe do?
        setText(ConStatusBar,aLine
            & " : double-click on it in list to copy it to clipboard")
      elsif posFunc = 1 then
        aLine = aLine[6..find(')', aLine)]
        MouseEventsConstant = aLine
        setText(ConStatusBar,aLine[1..find('(',aLine)] & " parameters )"
            & " : double-click on it in list to copy it to clipboard")
      end if
    else
      setText(ConStatusBar,"" )
      MouseEventsConstant = {}
    end if
end procedure
--------------------------------------------------------------------------

procedure onChange_aConstantsList(integer self, integer event, sequence params)
  if self = VKList then
     GetVKconstant()
  elsif self = w32HList then
     GetW32Hconstant()
--   elsif self = onEventsList then
--      GetOnEventsConstant()
  elsif self = ColorsList then
     GetColorsConstant()
  elsif self = ControlsList then
     GetControlsConstant()
  elsif self = MouseEventsList then
     GetMouseEventsConstant()
  end if
end procedure

setHandler({VKList, w32HList, ColorsList, ControlsList, MouseEventsList}, --onEventsList, 
    w32HChange, routine_id("onChange_aConstantsList"))

--------------------------------------------------------------------------
procedure onMouse_aConstantsList( integer self, integer event, sequence params )
object dummy
sequence aConstant
aConstant = {}

  if params[1] = LeftDoubleClick  then
     if self = VKList then
        aConstant = VKconstant
     elsif self = w32HList then
        aConstant = W32Hconstant
--      elsif self = onEventsList then
--         aConstant = OnEventsConstant
     elsif self = ColorsList then
        aConstant = ColorsConstant
     elsif self = ControlsList then
        aConstant = ControlsConstant
     elsif self = MouseEventsList then
        aConstant = MouseEventsConstant
     end if

     if length(aConstant) then
        setText(VKhiddenSLE, aConstant )
     else
        setText(VKhiddenSLE, " " ) -- had to do this to clear clipboard!
     end if

    -- select the text in the hidden edit line:
    dummy = sendMessage( VKhiddenSLE,EM_SETSEL, 0, -1 )
    copy( VKhiddenSLE )
    if length(aConstant) then
       setText(ConStatusBar, aConstant & " has been copied to the clipboard")
    else
        setText(ConStatusBar, "")
    end if
  end if
end procedure

setHandler({VKList, w32HList, ColorsList, ControlsList, MouseEventsList}, --onEventsList,
    w32HMouse, routine_id("onMouse_aConstantsList"))
---------------------------------------------------------------------------
procedure onChange_ConTopicsList(integer self, integer event, sequence params)
integer index

   setVisible(Group1, 0)
   setVisible(Group2, 0)
   setText(ConStatusBar, "  ")

   index = getIndex(ConTopicsList)
   if index = 1 then
      setVisible(Group1, 0)
      setVisible(Group2, 0)
      setText(ConstantsWindow, "Frequently Used Constants:  Virtual Keys")
      setVisible(w32HList, 0)
      --setVisible(onEventsList, 0)
      setVisible(ColorsList, 0)
      setVisible(ControlsList, 0)
      setVisible(MouseEventsList, 0)
      setVisible(VKList, 1)
      if getIndex(VKList) = 0 then
        setIndex(VKList, 1)
      end if
      GetVKconstant()

   elsif index = 2 then
      setText(ConstantsWindow, "Frequently Used Constants:  w32H Event Handler Constants")
      setVisible(Group1, 1)
      setVisible(Group2, 0)
      setVisible(VKList, 0)
      --setVisible(onEventsList, 0)
      setVisible(ColorsList, 0)
      setVisible(ControlsList, 0)
      setVisible(MouseEventsList, 0)
      setVisible(w32HList, 1)
      if getIndex(w32HList) = 0 then
        setIndex(w32HList, 1)
      end if
      
      setCheck(JustConRB, 0)
      setCheck(FullStateRB, 0)
      setCheck(BothStateRB, 1) -- default
      GetW32Hconstant()

--    elsif index = 3 then
--       setText(ConstantsWindow, "Frequently Used Constants:  onSomeEvent Constants")
--       setVisible(Group1, 1)
--       setVisible(Group2, 0)
--       setVisible(VKList, 0)
--       setVisible(w32HList, 0)
--       setVisible(ColorsList, 0)
--       setVisible(ControlsList, 0)
--       setVisible(MouseEventsList, 0)
--       setVisible(onEventsList, 1)
--       if getIndex(onEventsList) = 0 then
--         setIndex(onEventsList, 1)
--       end if
--       setCheck(JustConRB, 0)
--       setCheck(FullStateRB, 0)
--       setCheck(BothStateRB, 1)
--       GetOnEventsConstant()
-- 
   elsif index = 3 then
      setVisible(Group1, 0)
      setVisible(Group2, 0)
      setText(ConstantsWindow, "Frequently Used Constants:  Colors")
      setVisible(VKList, 0)
      setVisible(w32HList, 0)
      --setVisible(onEventsList, 0)
      setVisible(ControlsList, 0)
      setVisible(MouseEventsList, 0)
      setVisible(ColorsList, 1)
      if getIndex(ColorsList) = 0 then
        setIndex(ColorsList, 1)
      end if
      GetColorsConstant()

   elsif index = 4 then
      setText(ConstantsWindow, "Frequently Used Constants:  Controls")
      setVisible(Group1, 0)
      setVisible(Group2, 1)
      setVisible(VKList, 0)
      setVisible(w32HList, 0)
      --setVisible(onEventsList, 0)
      setVisible(ColorsList, 0)
      setVisible(MouseEventsList, 0)
      setVisible(ControlsList, 1)
      if getIndex(ControlsList) = 0 then
        setIndex(ControlsList, 1)
      end if
      setCheck(ExtendedRB, 0)
      setCheck(CreateRB, 1 )
      GetControlsConstant()

   elsif index = 5 then
     setVisible(Group1, 0)
     setVisible(Group2, 0)
     setText(ConstantsWindow, "Frequently Used Constants:  Mouse Events")
     setVisible(VKList, 0)
     setVisible(w32HList, 0)
     --setVisible(onEventsList, 0)
     setVisible(ColorsList, 0)
     setVisible(ControlsList, 0)
     setVisible(MouseEventsList, 1)
     if getIndex(MouseEventsList) = 0 then
        setIndex(MouseEventsList, 1)
     end if
     GetMouseEventsConstant()
   end if
end procedure
setHandler(ConTopicsList, w32HChange, routine_id("onChange_ConTopicsList"))
---------------------------------------------------------------------------
with trace
procedure onClick_Group1(integer self, integer event, sequence params)

  if isVisible(w32HList) then
        GetW32Hconstant()
--   elsif isVisible(onEventsList) then
--         GetOnEventsConstant()
  elsif isVisible(ControlsList) then
        GetControlsConstant()
  end if
end procedure
setHandler({FullStateRB, JustConRB, BothStateRB, CreateRB, ExtendedRB}, w32HClick, routine_id("onClick_Group1"))

---------------------------------------------------------------------------

integer ConFirstTimeFlag  -- for first time open constants window,
                          -- opens VK list
ConFirstTimeFlag = 1
procedure onOpen_ConstantsWindow(integer self, integer event, sequence params)
integer index

   setVisible(VKList, 0)
   setVisible(w32HList, 0)
   --setVisible(onEventsList, 0)
   setVisible(ColorsList, 0)
   setVisible(ControlsList, 0)
   setVisible(MouseEventsList, 0)
   setText(ConStatusBar, "  ")

   if ConFirstTimeFlag then
      setIndex(ConTopicsList,1)
      setVisible(VKList, 1)
      setIndex(VKList, 1)
      GetVKconstant()
      ConFirstTimeFlag = 0
   end if

   index = getIndex(ConTopicsList)
   if index = 1 then
      setVisible(VKList, 1)
      GetVKconstant()
   elsif index = 2 then
      setVisible(w32HList, 1)
      GetW32Hconstant()
--    elsif index = 3 then
--       setVisible(onEventsList, 1)
--       GetOnEventsConstant()

   elsif index = 3 then
      setVisible(ColorsList, 1)
      GetColorsConstant()
   elsif index = 4 then
      setVisible(ControlsList, 1)
      GetControlsConstant()
   elsif index = 5 then
      setVisible(MouseEventsList, 1)
      GetMouseEventsConstant()
   end if
   
end procedure
setHandler(ConstantsWindow, w32HOpen, routine_id("onOpen_ConstantsWindow"))
---------------------------------------------------------------------------
procedure onClose_ConstantsWindow (integer self, integer event, sequence params)
  setText(MainStatusBar, "")
  moveZOrder(MainWindow, HWND_TOP)
end procedure
setHandler(ConstantsWindow, w32HClose, routine_id("onClose_ConstantsWindow"))


---------------------------------------------------------------------------
--  SAVE ALL DATA to dat file, IN CASE ANY WAS CHANGED?:
--  hadn't put any saves in "moves" section, would be too many writes!
procedure onClose_MainWindow(integer self, integer event, sequence params)
   WriteRunDemosListFile()
end procedure
setHandler(MainWindow, w32HClose, routine_id("onClose_MainWindow"))
--=========================================================================

WinMain( MainWindow, Maximize )
