<html>
<head>
<!-- Generated by MAKEDOC v1.1, (c) 2000,2003 by David Cuny, Derek Parnell, Matt Lewis -->
<!-- on 2009/07/23 at 00h20m32 -->
<style>h4 {text-align: right}</style>
<title>Documentation for Win32lib v0.70.18</title>
</head>
<body>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h1><a name="UTILITIE">Utilities</a></h1>
<p><h3>These are useful routines that don't seem to fit in any other category.
</h3><br>

</p>
<li><a href="#ADDSTYLE"><i>proc</i> addStyle</a>( id, style ) &nbsp;&nbsp;Add a style to a control.
<li><a href="#GETCLIPBOARD"><i>func</i> getClipboard</a>(integer format) &nbsp;&nbsp;Retrieves data in the clipboard with this format
<li><a href="#GETHANDLE"><i>func</i> getHandles</a>() &nbsp;&nbsp;Gets all the hWnd handles for every control created in your application.
<li><a href="#GETRECENT"><i>func</i> getRecent</a>(integer owner_type) &nbsp;&nbsp;Gets the most recently defined control of a specifc kind, and returns the requested id.
<li><a href="#GETSTYLEFLAG"><i>func</i> getStyleFlags</a>( id ) &nbsp;&nbsp;Retrieves the standard and extra style flags for a control.
<li><a href="#HITTESTTT"><i>func</i> hitTestTT</a>() &nbsp;&nbsp;Tests to see if the mouse is currently over a control that has a tooltip.
<li><a href="#PLAYSOUND"><i>func</i> playSound</a>( sequence FileParm ) &nbsp;&nbsp;Play the .WAV file.
<li><a href="#REMOVESTYLE"><i>proc</i> removeStyle</a>( id, style ) &nbsp;&nbsp;Remove a style from a control.
<li><a href="#SETCLIPBOARD"><i>func</i> setClipboard</a>(object data,integer format,integer is_handle,integer size) &nbsp;&nbsp; Sets the clipboard to <em>data</em> using the other parameters.
<li><a href="#SHELLEXECUTE"><i>proc</i> shellExecute</a>( command, file, style ) &nbsp;&nbsp;Launch a Windows application
<li><a href="#SHELLEXECUTEEX"><i>func</i> shellExecuteEx</a>( object verb, sequence file, object params, object defdir, object style, object struct ) &nbsp;&nbsp;Launch a Windows application
<li><a href="#W32BOUND"><i>func</i> w32bounds</a>(sequence items,integer flags) &nbsp;&nbsp; Returns index(es) or value(s) of the minimal/maximal element in a sequence 
<li><a href="#W32SLEEP"><i>proc</i> w32Sleep</a>(atom milliseconds) &nbsp;&nbsp; Puts current thread to sleep for <em>milliseconds</em> milliseconds, if another OS thread is ready to run.
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="ADDSTYLE">[<i>proc</i>]<br>addStyle</a> ( id, style )</h2>
<h3>Add a style to a control.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> If <em>style</em> is an atom then only the normal Windows style is modified,
but if style is a sequence, it must be a two-atom sequence. The first is
the normal styles, and the second is the extended styles.
<p>
A special use of this is to set a control to close its parent window. To
 do this call the routine using the style <em>w32AUTOCLOSE</em>. It should not be combined with any other style.
<p>
Example
<pre>
        addStyle(w1, {
                 -- normal styles
                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
                 -- extended styles
                 (WS_EX_CLIENTEDGE)
                })
      -- Set the control to close the window
      addStyle( BtnClose, w32AUTOCLOSE)
</pre>
<p>See Also: 
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="GETCLIPBOARD">[<i>func</i>]<br>getClipboard</a> (integer format)</h2>
<h3>Retrieves data in the clipboard with this format</h3>
<h3>Returns: (OBJECT) Either a string for text formats, or a data handle otherwise.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p>If getting a data handle, you should not free it, and copy the referred contents to some other place, because you do not own the returned handle.
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="GETHANDLE">[<i>func</i>]<br>getHandles</a> ()</h2>
<h3>Gets all the hWnd handles for every control created in your application.</h3>
<h3>Returns: A sequence of atoms.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p>Handles for destroyed controls, or controls that don't exist, appear as 0.
<pre>
        addBtn = create(PushButton, "", 100,100, 40,40,0)
        allHandles = getHandles()
        otherfunc( allHandles[ addBtn ], ... )
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="GETRECENT">[<i>func</i>]<br>getRecent</a> (integer owner_type)</h2>
<h3>Gets the most recently defined control of a specifc kind, and returns the requested id.</h3>
<h3>Returns: INTEGER: the id of the most recently created control of the specified type, or 0 if none was created so far.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p><p>
The supported owner type specifications are:
 <li> <strong>w32RecentMenu</strong>: id of the most recently created menu, or 0;
 <li> <strong>w32RecentWindow</strong>: id of the most recently created window, or 0;
 <li> <strong>w32RecentTabControl</strong>: id of the most recently created TabControl, or 0;
 <li> <strong>w32RecentForms</strong>: id of the most recently created form window, or {-1}.
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="GETSTYLEFLAG">[<i>func</i>]<br>getStyleFlags</a> ( id )</h2>
<h3>Retrieves the standard and extra style flags for a control.</h3>
<h3>Returns: SEQUENCE: {ATOM: standard, ATOM: extra}</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p>Example
<pre>
      sequence lFlags
      lFlags = getStyleFlags(myButton)
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="HITTESTTT">[<i>func</i>]<br>hitTestTT</a> ()</h2>
<h3>Tests to see if the mouse is currently over a control that has a tooltip.</h3>
<h3>Returns: w32False or the id of a control.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p><p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="PLAYSOUND">[<i>func</i>]<br>playSound</a> ( sequence FileParm )</h2>
<h3>Play the .WAV file.</h3>
<h3>Returns:  <strong>w32True</strong> if succeeds, <strong>w32False</strong> if fails.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> This is a wrapper around the Win32 <strong>PlaySound</strong> command. <br>
 <em>FileName</em> can take one of four forms. <br>
 <li> The value 0 or an empty sequence. Use this to immediately stop playing
any sound.
 <li> A simple filename, such as a ".WAV" file to play. This sets up the
 flags as SND_FILENAME and SND_ASYNC. <br>
 <li> The form {FileName, Flags} which gives you more control over the flag settings.
 The <em>Flags</em> can be either a single atom or a sequence of sound flags.
 <li> The form  {FileName, Flags, ResourceId} is available the sound you need to
 play is contained in the resources of an executable file. In this case <em>FileName</em>
 is is a sequence with one element in it; a handle to an executable file. <em>ResourceId</em>
is the id of the resource to play.
<p>
Example:
<pre>
      -- Play a sound file and return before it ends.
      VOID = playSound("announce.wav")
<p>
      -- Play a sound file and wait until it ends.
      VOID = playSound({"announce.wav",{SND_FILENAME,SND_SYNC})
<p>
      -- Play a sound file continuously in the background
      VOID = playSound({"background.wav", {SND_FILENAME,SND_ASYNC,SND_LOOP})
<p>
      -- Play a sound file but only if no other sound is already playing.
      VOID = playSound({"hit.wav",{SND_FILENAME,SND_ASYNC,SND_NOSTOP})
<p>
      -- Play a sound named in the system registry.
      VOID = playSound({"MailBeep",{SND_ALIAS})
<p>
      -- Stop playing any sound.
      VOID = playSound({"",SND_PURGE})
      -- or
      VOID = playSound(0)
<p>
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="REMOVESTYLE">[<i>proc</i>]<br>removeStyle</a> ( id, style )</h2>
<h3>Remove a style from a control.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> If <em>style</em> is an atom then only the normal Windows style is modified,
but if style is a sequence, it must be a tw-atom sequence. The first is
the normal styles, and the second is the extended styles.
<p>
Example
<pre>
        removeStyle(w1, {
                 -- normal styles
                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
                 -- extended styles
                 (WS_EX_CLIENTEDGE)
                   })
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="SETCLIPBOARD">[<i>func</i>]<br>setClipboard</a> (object data,integer format,integer is_handle,integer size)</h2>
<h3> Sets the clipboard to <em>data</em> using the other parameters.</h3>
<h3>Returns: w32False on failure, w32True on success.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> <em>format</em> is a <a href="..\win32_constants#Clipboard formats">clipboard format</a>, for instance CF_TEXT.
 The way <em>data</em> is interpreted depends on the other parameters:
 If <em>data</em> is a sequence, and the format is any of CF_TEXT, CF_DSPTEXT, CF_OEMTEXT, CF_UNICODETEXT, then the procedure takes care of all the memory work, and <em>is_handle</em> is ignored.
 Otherwise, if is_handle is nonzero, it means that <em>data</em> is a Window memory handle.
 You may have acquired it through <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_HANDLE">w32acquire_handle</a>().
 Otherwise, <em>data</em> points to the data you wish to send, and <em>size</em> is the size of the data buffer.
 For the CF_DIB and CF_PALETTE format, the routine is able to figure <em>size</em> out, and will do so if <em>size</em> is 0. Other formats may be supported in this way in the future.
 For the CF_BITMAP, private GDI formats, and  formats, the only allowable value <em>data</em> may have is a handle, so that <em>is_anndle</em> and <em>size</em> are both ignored.
If you provide a handle, you no longer own this handle on return.
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="SHELLEXECUTE">[<i>proc</i>]<br>shellExecute</a> ( command, file, style )</h2>
<h3>Launch a Windows application</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p><p>
 This is a wrapper around the Win32 <strong>ShellExecute</strong> command.
 <em>command</em> is usually "open". <br>
 <em>file</em> is the file or directory to open or run. <br>
 <em>style</em> is usually SW_SHOWNORMAL, but can be SW_SHOWMINIMIZED or
SW_SHOWMAXIMIZED
<p>
<pre>
       -- Start up MSAcess on the database.
       shellExecute("open", "myDB.mdb", SW_SHOWNORMAL)
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="SHELLEXECUTEEX">[<i>func</i>]<br>shellExecuteEx</a> ( object verb, sequence file, object params, object defdir, object style, object struct )</h2>
<h3>Launch a Windows application</h3>
<h3>Returns: ATOM: Success code. 0 to 32 are errors; successful invocation returns a process handle.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p><p>
 This is a wrapper around the Win32 <strong>ShellExecute</strong> command.
<p>
 The <em>verb</em> parameter is the action you are trying to execute. In nearly
all cases this is "open". The actions possible are defined in your Windows
File Associations definitions. If this parameter is not a sequence then
 the default action for the <em>file</em> is used.
<p>
 The <em>file</em> parameter is the file to perform the action upon. This is
usually a .EXE file but can be any file type that has a defined action in
the Window File Associations.
<p>
 The <em>params</em> is the parameters passed to the program. If there are no parameters
 then <em>params</em> should be 0 <br>
 If you need to pass parameters, <em>params</em> is either a string containing the
parameters (as if typed on the console), or it is a list of zero or more parameters
 that can be strings or numbers. When using <em>params</em> as a list of parameters,
any string in the list that contains spaces will be passed to the program enclosed
in double-quotes.
<p>
 When opening an EXE file, <em>params</em> is the parameters for that program.
<p>
 When opening a document file instead of an EXE, <em>params</em> must be 0.
<p>
 The <em>defdir</em> is the default directory to change to before openning the
file. If this is not a sequence the the current directory is used.
<p>
 The <em>style</em> parameter is a window style flag.
 These can be ... <br>
 <li> SW_HIDE
 <li> SW_SHOWNORMAL
 <li> SW_NORMAL
 <li> SW_SHOWMINIMIZED
 <li> SW_SHOWMAXIMIZED
 <li> SW_MAXIMIZE
 <li> SW_SHOWNOACTIVATE
 <li> SW_SHOW
 <li> SW_MINIMIZE
 <li> SW_SHOWMINNOACTIVE
 <li> SW_SHOWNA
 <li> SW_RESTORE
 <li> SW_SHOWDEFAULT
 <li> SW_MAX
<p>
 The <em>struct</em> parameter is used when you need to manage the memory allocation
for the routine. This can be a performance advantage if the same shellExecute
 action is required repeatedly. <br>
If this is given as zero, then the routine allocates RAM for
the other parameters and frees it again just before returning to your application.
But if you supply either a single RAM address or a sequence of four RAM addresses,
the routine uses your allocation and does not free any RAM. Instead it is your
 application's responsibility to free the RAM. <br>
 When <em>struct</em> is supplied as a set of four RAM addresses, the routine assumes
 that they represent the RAM location of the <em>verb</em>, <em>file</em>, <em>parms</em>, and
 <em>defdir</em> strings (0-terminated) you have already set up. <br>
 When <em>struct</em> is a single RAM address, the routine assumes that it points to
a set of four RAM addresses as specified above. In the C programming langauge
this would be equivalent to ...
<pre>
   struct SEStrings {
      char *verb;
      char *file;
      char *parms;
      char *defdir;
   }
   struct SEStrings ms;
    * Example settings */
   ms.verb = "open";
   ms.file = "iexplorer.exe";
   ms.parms = 0;
   ms.defdir = 0;
</pre>
<p>
 The return codes for this function are... <br>
 <li> SE_ERR_FNF                    -- file not found
 <li> SE_ERR_PNF                    -- path not found
 <li> SE_ERR_ACCESSDENIED           -- access denied
 <li> SE_ERR_OOM                    -- out of memory
 <li> SE_ERR_SHARE
 <li> SE_ERR_ASSOCINCOMPLETE
 <li> SE_ERR_DDETIMEOUT
 <li> SE_ERR_DDEFAIL
 <li> SE_ERR_DDEBUSY
 <li> SE_ERR_NOASSOC
 <li> SE_ERR_DLLNOTFOUND
<p>
Example 1:
<pre>
  res = shellExecuteEx("open", "iexplorer", 0, 0, SW_NORMAL, 0)
</pre>
<p>
Example 2:
<pre>
  atom pVerb = allocate_string("open")
  atom pFile = allocate_string("iexplorer.exe")
  res = shellExecuteEx(0, 0, 0, 0, SW_NORMAL, {pVerb, pFile, 0, 0})
</pre>
<p>
Example 3:
<pre>
  atom pVerb = allocate_string("open")
  atom pFile = allocate_string("iexplorer.exe")
  atom pStruct = allocate(16) -- room for four 32-bit addresses.
  memset(pStruct, 16, 0)
  poke4(pStruct + 0, pVerb)
  poke4(pStruct + 4, pFile)
  res = shellExecuteEx(0, 0, 0, 0, SW_NORMAL, pStruct)
</pre>
<p>
Example 4:
<pre>
  res = shellExecuteEx("open", "ex.exe", "dirutil -C c:\\temp\\ e:\\backup\\", 0, SW_NORMAL, 0)
</pre>
<p>
Example 5:
<pre>
  res = shellExecuteEx("open", "ex.exe", {"dirutil", "-C", sourcedir, backupdir}, 0, SW_NORMAL, 0)
</pre>
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#W32BOUND">w32bounds</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32BOUND">[<i>func</i>]<br>w32bounds</a> (sequence items,integer flags)</h2>
<h3> Returns index(es) or value(s) of the minimal/maximal element in a sequence </h3>
<h3>Returns: (OBJECT) One or two indices, or one or two values, depending on flags.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> <em>flags</em> is the sum of zero or more of:
 <li> w32BOUNDS_MIN=0: return a minimum index or value;
 <li> w32BOUNDS_MAX=1: return a maximum index or value;
 <li> w32BOUNDS_INDEX=0,
 <li> w32BOUNDS_VALUE=2,
 <li> w32BOUNDS_PAIR=4,
 <li> w32BOUNDS_INDEX_FIRST=w32BOUNDS_INDEX
 <li> w32BOUNDS_VALUE_FIRST=w32BOUNDS_VALUE
Obviously, only some combinations make sense.
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32SLEEP">w32Sleep</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32SLEEP">[<i>proc</i>]<br>w32Sleep</a> (atom milliseconds)</h2>
<h3> Puts current thread to sleep for <em>milliseconds</em> milliseconds, if another OS thread is ready to run.</h3>
Category: <a href="#UTILITIE">Utilities</a><br>
<p><p> "thread" here refers to an <strong>OS thread</strong>, not to an Euphoria task. exw.exe runs two separate threads./n
 Passing a value of #FFFFFFFF puts the thread to sleep until some specific action is taken to wake the thread up./n 
 Passing a value of 0 attempts to run another thread of same priority immediately./n 
Passing any other values puts the thread to sleep for that many milliseconds. If another thread has the same priority
and is ready to run, it gets control.
<p>See Also: 
<a href="#ADDSTYLE">addStyle</a>,
<a href="#GETCLIPBOARD">getClipboard</a>,
<a href="#GETHANDLE">getHandles</a>,
<a href="#GETRECENT">getRecent</a>,
<a href="#GETSTYLEFLAG">getStyleFlags</a>,
<a href="#HITTESTTT">hitTestTT</a>,
<a href="#PLAYSOUND">playSound</a>,
<a href="#REMOVESTYLE">removeStyle</a>,
<a href="#SETCLIPBOARD">setClipboard</a>,
<a href="#SHELLEXECUTE">shellExecute</a>,
<a href="#SHELLEXECUTEEX">shellExecuteEx</a>,
<a href="#W32BOUND">w32bounds</a>
<hr>
