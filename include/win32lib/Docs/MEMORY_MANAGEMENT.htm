<html>
<head>
<!-- Generated by MAKEDOC v1.1, (c) 2000,2003 by David Cuny, Derek Parnell, Matt Lewis -->
<!-- on 2009/07/23 at 00h20m32 -->
<style>h4 {text-align: right}</style>
<title>Documentation for Win32lib v0.70.18</title>
</head>
<body>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h1><a name="MEMORY_MANAGEMENT">Memory management</a></h1>
<p><h3>Routines to allocate, use, and release of Random Access Memory (RAM).
</h3><br>
Normally, a Euphoria program doesn't have to worry about this as it is handled quietly
in the background. However, when working with external systems, such as the Windows API,
the coder often needs to explicitly manage RAM as resource, primarily when sharing data
 between your application and Windows. <br>/n
<p>
How the structure engine works.
 Memory structures are a set of fields. You define a structure by calling <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>()
passing the fields in sequence, and retrieving a field descriptor which can be used
 to access the field. When done, call the <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SIZE">w32allotted_size</a>(). This function does two things:
 <li> It returns the size of the structure, or at least its fixed stub size (read below).
 <li> As a side effect, it <strong>registers the structure template you just defined</strong> and
cleans up so as to possibly start another structure definition later.
 In addition, you can define a structure identifier. This is returned by <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>(),
 and is used by the bulk load/store routines. 
w32define_this_struct() is also useful to define shorter variants of a maximal structure.
For instance, Windows XP uses more fields than Windows 98 in some cases. You don't need
to define two different structures: just insert a w32define_this_struct() call at the
"break points" so as to retrieve structure ids for the various versions.
 <br>
Variable length members.
Some Windows API structure include arrays or strings of variable length. In that case,
only the length of the part of the structure preceding the first variable length field
is known and reported. The library supports a wide range of schemes and special alignment fields
 to deal with these beasts. Please read further under <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>().
 <br>
Unions are also supported. The only limitation is that no alternative field description
 can be a union itself. Read further under <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_UNION">w32define_union</a>().

</p>
<li><a href="#ISFIELDOF"><i>func</i> isFieldOf</a>(sequence field,sequence struct_type) &nbsp;&nbsp; Determines whether <em>field</em> is a field of the <em>struct_type</em> structure type.
<li><a href="#SETPREPROCESSDATAIN"><i>proc</i> setPreProcessDataIn</a>(sequence id,integer rid) &nbsp;&nbsp; Sets up a routine to preprocess data fed to <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORY">w32to_memory</a>() for a given type of structure.
<li><a href="#SETSTARTWITHSIZE"><i>proc</i> setStartWithSize</a>(sequence struct_id) &nbsp;&nbsp;Indicates to w32to_memory() that, when filling a structure of this type, its size should be plugged in as the first field.
<li><a href="#W32ACQUIRE_HANDLE"><i>func</i> w32acquire_handle</a>(atom flags,integer size) &nbsp;&nbsp;Gets a Windows memory handle to memory of the requested size.
<li><a href="#W32ACQUIRE_MEM"><i>func</i> w32acquire_mem</a>( atom Owner, object structure ) &nbsp;&nbsp;Allocate memory for structure, and initialize to zero.
<li><a href="#W32ADDRES"><i>func</i> w32address</a>( structure address, field ) &nbsp;&nbsp; Get address of <em>field</em> in structure.
<li><a href="#W32ALLOT"><i>func</i> w32allot</a>( object FldDefn ) &nbsp;&nbsp;Allocate space in structure for a new field.
<li><a href="#W32ALLOTTED_BUFFER"><i>func</i> w32allotted_buffer</a>(hDefn) &nbsp;&nbsp; Returns a modified field so as to <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>() the address of the supplied buffer
<li><a href="#W32ALLOTTED_HANDLE"><i>func</i> w32allotted_handle</a>(hDefn) &nbsp;&nbsp;Returns the address of the supplied handle, but with fetch instructions
<li><a href="#W32ALLOTTED_LENGTH"><i>func</i> w32allotted_length</a>(hDefn) &nbsp;&nbsp; Returns a modified field so as to <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>() the length of the supplied buffer
<li><a href="#W32ALLOTTED_SIZE"><i>func</i> w32allotted_size</a>() &nbsp;&nbsp;Return allocate size of structure, and reset for new structure.
<li><a href="#W32ALLOTTED_SOFAR"><i>func</i> w32allotted_sofar</a>() &nbsp;&nbsp;Return size allotted sofar to the structure
<li><a href="#W32BUFFER_ADDRES"><i>func</i> w32buffer_address</a>(atom struct,sequence bDefn) &nbsp;&nbsp; Returns the address of the buffer, while <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a> would return the string stored there.
<li><a href="#W32BUFFER_LENGTH"><i>func</i> w32buffer_length</a>(atom struct,sequence bDefn) &nbsp;&nbsp;Returns the stored length of the buffer.
<li><a href="#W32COPY_FIELD"><i>proc</i> w32copy_field</a>(atom struct,sequence s,atom origin) &nbsp;&nbsp; Copies contents of the field of the structure at <em>origin</em> described by <em>s</em> to <em>struct</em>.
<li><a href="#W32COPY_STRUCT"><i>proc</i> w32copy_struct</a>(atom struct,sequence id,atom origin) &nbsp;&nbsp; Copies the structure whose base address is <em>origin</em> to <em>struct</em>, its type being <em>id</em>.
<li><a href="#W32DEFINE_THIS_STRUCT"><i>func</i> w32define_this_struct</a>() &nbsp;&nbsp;Returns an identifier for the currently defined structure at the current point.
<li><a href="#W32DEFINE_UNION"><i>func</i> w32define_union</a>(sequence fields,integer selector, integer data_assess) &nbsp;&nbsp; Defines a union structure: the structure is any of the ones given in <em>fields</em>.
<li><a href="#W32FETCH"><i>func</i> w32fetch</a>( structure address, field ) &nbsp;&nbsp;Fetch field from structure.
<li><a href="#W32FROM_MEMORY"><i>func</i> w32from_memory</a>(atom struct,sequence s) &nbsp;&nbsp;Returns the fields of a structure.
<li><a href="#W32FROM_MEMORYEX"><i>func</i> w32from_memoryEx</a>(atom struct,sequence s,integer level) &nbsp;&nbsp;Returns the fields of a structure.
<li><a href="#W32HANDLE_TO_MEMORY"><i>func</i> w32handle_to_memory</a>(atom handle) &nbsp;&nbsp;Gives current task exclusive access to the referenced memory block.
<li><a href="#W32LLSETABORT"><i>func</i> w32llSetAbort</a>( i ) &nbsp;&nbsp;Possibly sets the routine id of an Abort routine.
<li><a href="#W32MANAGE_MEM"><i>func</i> w32manage_mem</a>( atom Owner, object Address) &nbsp;&nbsp;Records an acquired memory for garbage collection.
<li><a href="#W32NEW_MEMSET"><i>func</i> w32new_memset</a>( ) &nbsp;&nbsp;Allocates a unique id for a memory set.
<li><a href="#W32PEEK2"><i>func</i> w32peek2</a>(object pos) &nbsp;&nbsp;Retrieves a sequence of double byte encoded characters as a regular sequence
<li><a href="#W32PEEK_STRING"><i>func</i> w32peek_string</a>( address ) &nbsp;&nbsp;Get sequence from address holding C-style string.
<li><a href="#W32PEEK_STRING16"><i>func</i> w32peek_string16</a>(atom addr) &nbsp;&nbsp; Returns a 0000 terminated DBCS encoded string starting at <em>addr</em>.
<li><a href="#W32POKE_WORD"><i>proc</i> w32poke_words</a>(atom at,object words) &nbsp;&nbsp; Poke one or more words at <em>at</em>.
<li><a href="#W32REALISE"><i>func</i> w32realise</a>(atom struct,integer flag) &nbsp;&nbsp;Rebuilds a contiguous memory structure, possibly discarding virtual info
<li><a href="#W32RELEASE_HANDLE"><i>proc</i> w32release_handle</a>(atom handle,integer flag) &nbsp;&nbsp;Releases the referenced memory block, and optionally frees it.
<li><a href="#W32RELEASE_MEM"><i>proc</i> w32release_mem</a>( atom structure ) &nbsp;&nbsp; Returns the memory allocated by <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>() back to the system.
<li><a href="#W32SET_MEMORY"><i>proc</i> w32set_memory</a>(atom struct,sequence id,sequence data) &nbsp;&nbsp; Performs the same function as <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORY">w32to_memory</a>(), but stores data at address <em>struct</em>.
<li><a href="#W32SPECIALISE"><i>func</i> w32specialise</a>(sequence union,object variant) &nbsp;&nbsp;Returns a structure field descriptor that can be translated into an actual variant of a union.
<li><a href="#W32STORE"><i>proc</i> w32store</a>( structure, field, value ) &nbsp;&nbsp;Store a value into a structure.
<li><a href="#W32TO_MEMORY"><i>func</i> w32to_memory</a>(sequence id,sequence data) &nbsp;&nbsp;Initialises memory structiure of given type with supplied data.
<li><a href="#W32TO_MEMORYEX"><i>func</i> w32to_memoryEx</a>(atom mem,sequence id,sequence data,integer flag) &nbsp;&nbsp;Initialises memory structiure of given type with supplied data.
<li><a href="#W32USINGSAFECODE"><i>Var</i> w32UsingSafeCode</a> &nbsp;&nbsp;Determines whether or not the 'safe' versions of peek and poke are used.
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="ISFIELDOF">[<i>func</i>]<br>isFieldOf</a> (sequence field,sequence struct_type)</h2>
<h3> Determines whether <em>field</em> is a field of the <em>struct_type</em> structure type.</h3>
<h3>Returns: (INTEGER) w32True if the field belongs to the structure, else w32False.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>field</em> may be a nested field, in which case the leading field only is tested./n
 <em>struct_type</em> is a structure identifier, an ID_* constant or anything created by <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>().
<p>See Also: 
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="SETPREPROCESSDATAIN">[<i>proc</i>]<br>setPreProcessDataIn</a> (sequence id,integer rid)</h2>
<h3> Sets up a routine to preprocess data fed to <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORY">w32to_memory</a>() for a given type of structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>The preprocess routine must take a sequence and return a sequence.
 Preprocess routines apply to all short structures derived from/from which derives <em>id</em>.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="SETSTARTWITHSIZE">[<i>proc</i>]<br>setStartWithSize</a> (sequence struct_id)</h2>
<h3>Indicates to w32to_memory() that, when filling a structure of this type, its size should be plugged in as the first field.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> Once taken, this decision cannot be rolled back. It simply avoids repetitively specifying the size as the first data item./n 
The following structure identifiers are already marked for this optimisation:
 <li> ID_OSVERSIONINFOEX
 <li> ID_INITCOMMONCONTROLSEX
 <li> ID_WINDOWINFO
 <li> ID_MENUITEMINFO
 <li> ID_WNDCLASSEX
 <li> ID_SCROLLINFO
 <li> ID_COLORDLG
 <li> ID_DOCINFO
 <li> ID_DRAWTEXTPARAMS
 <li> ID_OPENFILENAME
 <li> ID_BITMAPINFOHEADER
 <li> ID_PAGESETUPDLG
 <li> ID_CHARFORMAT
 <li> ID_TOOLINFO
 <li> ID_REBARBANDINFO
 <li> ID_OUTLINETEXTMETRIC
 <li> ID_PARAFORMAT
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ACQUIRE_HANDLE">[<i>func</i>]<br>w32acquire_handle</a> (atom flags,integer size)</h2>
<h3>Gets a Windows memory handle to memory of the requested size.</h3>
<h3>Returns: (ATOM) Handle to memory.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> This is a very low level routine. <br>
 To access the memory, you must call <a href="MEMORY_MANAGEMENT.htm#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>(returned_handle). When you are
 done with the memory operation, call the <a href="MEMORY_MANAGEMENT.htm#W32RELEASE_HANDLE">w32release_handle</a>(returned_handle,free_also) procedure. <br>
 <li> <a href="..\win32_constants.htm#w32acquire_handle() flags">Here</a> are the known flags to or tohether as required.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ACQUIRE_MEM">[<i>func</i>]<br>w32acquire_mem</a> ( atom Owner, object structure )</h2>
<h3>Allocate memory for structure, and initialize to zero.</h3>
<h3>Returns: Address of allocated memory, or array of such addresses.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> The memory allocated is linked to the <em>Owner</em> and all the
 owner's memory can be released by one call. <br>
 <em>owner</em> may have been returned by <a href="MEMORY_MANAGEMENT.htm#W32NEW_MEMSET">w32new_memset</a>(), or it may be the address of a structure.
 In both cases, releasing the owner will also release the acquired memory. <br>
 If <em>structure</em> is a string, it is copied to the memory
location along with a zero byte.
<p>
 <em>structure</em> may also be a structure identifier
 previously returned by <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>(). In this case, it is recommended to
 <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>() objects inside it rather than poke()ing them. If you attempt to poke a field
 whose address is not known, or to <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>() one that you didn't fill yet, an error
will occur.
<p>
 If <em>structure</em> is an atom, it specifies that amount of memory to acquire
(a minimum of 4 bytes will always be acquired) and
the memory is set to all zeros. This atom may be a predefined size specifier.
Using aszText or uszText will cause 0 to be returned, since these field types have
an unknown data address until actually filled.
<p>
If the second argument has the form {{count,allocation_unit}}, and count is above 0 (0 will be returned if not greater),
then the memory specified by allocation_unit will be allocated count times. In case the allocation
 unit has a variable length, the whole array of positions is returned. Each allocated unit can be freed individually. <br>
Example:
<pre>
atom mset, pt, pstr
<p>
-- Establish a new memory set.
 mset = <a href="MEMORY_MANAGEMENT.htm#W32NEW_MEMSET">w32new_memset</a>()
-- get enough memory to hold a UInt datatype
xy = w32acquire_mem( UInt )
-- allocate a point structure
pt = w32acquire_mem( mset, SIZEOF_POINT )
-- copy a Euphoria string to a 'C' string area.
 pstr = <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>( mset, "My String Data" )
. . .
give all the memory area in 'mset' back
w32release_mem(mset)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ADDRES">[<i>func</i>]<br>w32address</a> ( structure address, field )</h2>
<h3> Get address of <em>field</em> in structure.</h3>
<h3>Returns: ATOM: Address of the field in the structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>This is typically used if the structure contains an array.
<p>
 In this snippet, the <strong>memBitmapInfo</strong> structure contains an array
 of <strong>RGBQUAD</strong> colors. The array is populated with the values in
the pal:
<p>
<pre>
-- get the start of the rgbQuad array
rgbQuad = w32address( memBitmapInfo, bmiColors )
<p>
-- copy the pal to memory
for i = 1 to colors do
<p>
-- store values
 <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rgbQuad, rgbRed,      pal[i][1] )
 <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rgbQuad, rgbGreen,    pal[i][2] )
 <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rgbQuad, rgbBlue,     pal[i][3] )
 <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rgbQuad, rgbReserved, 0 )
<p>
-- move to next quad
rgbQuad += SIZEOF_RGBQUAD
<p>
end for
<p>
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOT">[<i>func</i>]<br>w32allot</a> ( object FldDefn )</h2>
<h3>Allocate space in structure for a new field.</h3>
<h3>Returns: SEQUENCE: Definition of allotted memory.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>FldDefn</em> is either:
 <li> a number of bytes to allocate,
 <li> one of the predefined datatypes (listed below),
 <li> a structure identifier, predefined or returned by <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>(),
 <li> a 2-element sequence containing a repeat count and any of the above.
<p>
The repeat count is either:
 <li> a positive number;
 <li> a field definition previously returned by this function. In that case, the length of the
array is assumed to equal the contents of the supplied field in the structure;
 <li> a sequence holding a sequence of bytes. The length of the array is not known, and its end
is marked by this sequence of bytes. For instance, a C-string could be defined using w32allot({{{0}},Byte}).
 <li> a sequence holding a sequence holding a sequence made of two routine_ids. The length
of the array is not known, and the routine_ids are respectively used to determine and mark
when an item is the last item.
If a number of bytes is supplied, the field is aligned to the next 32-bit
 boundary before allocation. <br>
 If a {{{id_check_last,id_set_last}}} is supplied as a length, <em>id_check_last</em> is the
routine_id of a function that takes an atom and returns zero if not last item, nonzero for
 last item (each item is examined in turn). <em>id_set_last</em> is the routine_id of a procedure
that takes a single atom as argument (the address of the item at which to apply some end mark).
<p>
 The returned allotment definition is used by <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a> and <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>. It has the
 following structure. <br>
 The definition has seven items: <br>
 A <em>structure field</em>, an <em>fieldOffset</em>, a <em>datatype</em>, a <em>repeat length</em>, a
 structure type, a flag (1 if member has variable length) and a <em>unit bytesize</em> <br>
 Allowable types are: <br>
 <li> <strong>Byte</strong>: 8 bit value
 <li> <strong>Int8</strong>: Signed 8 bit integer, same as <strong>Byte</strong>.
 <li> <strong>Word</strong>: 16 bit value
 <li> <strong>Integer</strong>: 16 bit value, same as <strong>Word</strong>
 <li> <strong>Int16</strong>: 16 bit value, same as <strong>Word</strong>
 <li> <strong>Long</strong>: Signed 32 bit value
 <li> <strong>DWord</strong>: 32 bit value, same as <strong>Long</strong>
 <li> <strong>Int32</strong>: 32 bit value, same as <strong>Long</strong>
 <li> <strong>UInt</strong>: Unsigned 32 bit value.
 <li> <strong>Ptr</strong>: 32 bit value, same as <strong>UInt</strong>
 <li> <strong>ULong</strong>: 32 bit value, same as <strong>UInt</strong>
 <li> <strong>Hndl</strong>: 32 bit value,
 <li> <strong>HndlAddr</strong>: 32 bit value, a pointer to a pointer
 <li> <strong>Lpsz</strong>: Long pointer (32 bits) to zero delimited string
 <li> <strong>Strz</strong>: Fixed size buffer that holds a zero-delim string
 <li> <strong>Single</strong>: 32-bit IEEE floating point value
 <li> <strong>Float</strong>: Same as Single
 <li> <strong>Double</strong>: 64-bit IEEE floating point value
 <li> <strong>Upsz</strong>: Long pointer to 0000 delimited UTF-16 encoded string
 <li> <strong>Ustrz</strong>: Fixed size buffer that holds a 0000 delimited DBCS encoded string
 <li> <strong>aszText</strong>: An <strong></strong>/i actual 0 terminated string
 <li> <strong>uszText</strong>: An <strong></strong>/i actual 0000 terminated UTF-16 encoded string
 <li> <strong>asBuffer</strong>: A pointer to an UTF-8 encoded string, followed by a dword storing its length
 <li> <strong>usBuffer</strong>: A pointer to an UTF-16 encoded string, followed by a dword storing its length in TCHARs
 <li> <strong>Align</strong>: A pseudo field that forces the next field address to be aligned on a
multiple of the size passed. If no size is provided, 8 is assumed.
 <li> <strong>AlignRel</strong>: A pseudo field that forces the next field offset to be aligned on a
multiple of the size passed. If no size is provided, 4 is assumed.
 <li> <strong>ByteFill</strong>: An unaccessible byte. If no size is specified, 1 is assumed. <br>
 You cannot fetch/store the contents of an Align, AlignRel or ByteFill field. <br>
Arrays of Strz or Ustrz are not currently supported.
<p>
Example:
<p>
<pre>
constant
msLeft           = w32allot( Long ),
msTop            = w32allot( Long ),
msRight          = w32allot( Long ),
msBottom         = w32allot( Long ),
 ID_BARERECT      = <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>()
msVelocity       = w32allot( Single ),
msXYZ            = w32allot( {4, DWord} ),
msReserved       = w32allot( 5 ),
msName           = w32allot( Lpsz ),
msBuffer         = w32allot( {128, Strz} ),
 SIZEOF_MYSTRUCT  = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SIZE">w32allotted_size</a>(),
 ID_MYSTRUCT      = <a href="MEMORY_MANAGEMENT.htm#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>()
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOTTED_BUFFER">[<i>func</i>]<br>w32allotted_buffer</a> (hDefn)</h2>
<h3> Returns a modified field so as to <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>() the address of the supplied buffer</h3>
<h3>Returns: SEQUENCE: Handle's "fieldOffset" into a structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>w32fetch(), when given a field that represents an asBuffer or usBuffer, returns the string
in the buffer. Use this function on the field, and w32fetch() will return the buffer address instead
 when using the returned field. This is similar to how <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_HANDLE">w32allotted_handle</a>() works.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOTTED_HANDLE">[<i>func</i>]<br>w32allotted_handle</a> (hDefn)</h2>
<h3>Returns the address of the supplied handle, but with fetch instructions</h3>
<h3>Returns: SEQUENCE: Handle's "fieldOffset" into a structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> to get the address from the handle, rather than the handle itself. <br>
An empty sequence is returned if the parameter was invalid.
<p>
Example:
<p>
<pre>
constant
 hDemo            = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Hndl ),
 pDemo            = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_HANDLE">w32allotted_handle</a>( hDemo ),
 SIZEOF_DEMO      = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SIZE">w32allotted_size</a>()
. . .
x = w32acquire_mem(w32new_memset(),SIZEOF_DEMO)
initDEMO(x)
<p>
h = w32fetch(x, hDemo)
a = w32fetch(x, pDemo)
-- 'h' will contain the handle, and 'a' the address from the handle.
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOTTED_LENGTH">[<i>func</i>]<br>w32allotted_length</a> (hDefn)</h2>
<h3> Returns a modified field so as to <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>() the length of the supplied buffer</h3>
<h3>Returns: INTEGER: Buffer length "fieldOffset" into a structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>w32fetch(), when given a field that represents an asBuffer or usBuffer, returns the string
in the buffer. Use this function on the field, and w32fetch() will return the buffer length instead
 when using the returned field. This is similar to how <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_HANDLE">w32allotted_handle</a>() works.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOTTED_SIZE">[<i>func</i>]<br>w32allotted_size</a> ()</h2>
<h3>Return allocate size of structure, and reset for new structure.</h3>
<h3>Returns: INTEGER: Allotted size of structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p><p>
Example:
<p>
<pre>
constant
 rectLeft            = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 rectTop             = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 rectRight           = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 rectBottom          = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 SIZEOF_RECT        = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SIZE">w32allotted_size</a>()
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32ALLOTTED_SOFAR">[<i>func</i>]<br>w32allotted_sofar</a> ()</h2>
<h3>Return size allotted sofar to the structure</h3>
<h3>Returns: INTEGER: Allotted size of structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p><p>
Example:
<p>
<pre>
constant
 rectLeft            = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 rectTop             = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 SIZEOF_LT           = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SOFAR">w32allotted_sofar</a>()
 rectRight           = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 rectBottom          = <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a>( Long ),
 SIZEOF_RECT        = <a href="MEMORY_MANAGEMENT.htm#W32ALLOTTED_SIZE">w32allotted_size</a>()
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32BUFFER_ADDRES">[<i>func</i>]<br>w32buffer_address</a> (atom struct,sequence bDefn)</h2>
<h3> Returns the address of the buffer, while <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a> would return the string stored there.</h3>
<h3>Returns: (ATOM) The address of the buffer.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>bDefn</em> must be a field definition defining an Lpsz, Upsz, asBuffer or usBuffer field.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32BUFFER_LENGTH">[<i>func</i>]<br>w32buffer_length</a> (atom struct,sequence bDefn)</h2>
<h3>Returns the stored length of the buffer.</h3>
<h3>Returns: (INTEGER) The length of the buffer.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>bDefn</em> must be a field definition defining an asBuffer or usBuffer field.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32COPY_FIELD">[<i>proc</i>]<br>w32copy_field</a> (atom struct,sequence s,atom origin)</h2>
<h3> Copies contents of the field of the structure at <em>origin</em> described by <em>s</em> to <em>struct</em>.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p><p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32COPY_STRUCT">[<i>proc</i>]<br>w32copy_struct</a> (atom struct,sequence id,atom origin)</h2>
<h3> Copies the structure whose base address is <em>origin</em> to <em>struct</em>, its type being <em>id</em>.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> Assumes there is enough room at <em>struct</em> to store the structure
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32DEFINE_THIS_STRUCT">[<i>func</i>]<br>w32define_this_struct</a> ()</h2>
<h3>Returns an identifier for the currently defined structure at the current point.</h3>
<h3>Returns: (SEQUENCE) A structure identifier.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>{{struct number}} is returned if not currently defining a structure.
 Use <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>() to create an instance of the structure.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32DEFINE_UNION">[<i>func</i>]<br>w32define_union</a> (sequence fields,integer selector, integer data_assess)</h2>
<h3> Defines a union structure: the structure is any of the ones given in <em>fields</em>.</h3>
<h3>Returns: (SEQUENCE) A structure id, which you can use almost like any other.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> The <em>selector</em> argument is a routine_id. The associated routine must be a function that
takes an atom as sole argument. This atom is the memory address of the structure being queried.
 The function must return an integer, the index in <em>fields</em> of the variant form that is stored
 at that address. <br>
 <em>data_assess</em> is a routine_id of a function that takes an object (data to store in the union)
and returns, as above, which sort of variant of the union should be used.
<p>
Example:
<pre>
  -- The following function returns 1 if addr points to an submenu template entry, and 2 for an item/separator entry 
<p>
 integer isPopup, isDataPopup
 function isAPopup(atom addr)
 return w32iff(and_bits(peek(a)+peek(a+1)*256,MF_POPUP),1,2)
 end function
 isPopup = routine_id("isAPopup")
<p>
 function isDataForPopup(object x)
 return w32iff(atom(x),1,2)
 end function
<p>
 isDataPopup=routine_id("isDataForPopup")
<p>
 -- Now define a menu item template entry as understood by the LoadMenuIndirect() API.
 -- This has an option field (a word), an optional ID field (a word), and a wide char string.
<p>
 constant
 -- define a substructure that will store both option and ID
 FULLMENUITEMTEMPLATE_flags = w32allot(Word),
 FULLMENUITEMTEMPLATE_id = w32allot(Word),
 SIZEOF_FULLMENUITEMTEMPLATE = w32allotted_size(),  -- 4
 ID_FULLMENUITEMTEMPLATE = w32define_this_struct(),
<p>
 -- define the start of an entry as either a word or an item entry
 ID_STARTITEMTEMPLATE = w32define_union({Word,ID_FULLMENUITEMTEMPLATE},isPopup,isDataPopup),
<p>
 -- Now here is the MENUITEMTEMPLATE entry structure
 MENUITEMTEMPLATE_flags = w32allot(ID_STARTITEMTEMPLATE),
 MENUITEMTEMPLATE_mtString = w32allot(Ustrz),
 SIZEOF_MENUITEMTEMPLATE = w32allotted_size(),
<p>
 -- You may wish to access the original fields of the structure:
 -- define a specialised form of a STARTITEMTEMPLATE union
 MENUITEMENTRY = w32specialise(ID_STARTITEMTEMPLATE,ID_FULLMENUITEMTEMPLATE),
<p>
 -- Now define the subfields for access
 MENUITEMTEMPLATE_mtOption = {MENUITEMENTRY,FULLMENUITEMTEMPLATE_flags},
 MENUITEMTEMPLATE_mtID = {MENUITEMENTRY,FULLMENUITEMTEMPLATE_id}
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32FETCH">[<i>func</i>]<br>w32fetch</a> ( structure address, field )</h2>
<h3>Fetch field from structure.</h3>
<h3>Returns: OBJECT: Field from a structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>Data conversion is automatic. For example, if the field is
 an <strong>Lpsz</strong>, a sequence containing the string will automatically
be returned.
<p>
Example:
<pre>
-- fetch the average character width from the text metrics structure
 width = <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>( tm, tmAveCharWidth )
<p>
 -- Here we get individual elements from an <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a> array.
constant bCoords = w32allot( {4, Long} )
. . .
 x = <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>( rect, bCoords & 1)
 y = <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>( rect, bCoords & 2)
<p>
-- To get all the values at once
sequence coords
 coords = <a href="MEMORY_MANAGEMENT.htm#W32FETCH">w32fetch</a>( rect, bCoords)
<p>
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32FROM_MEMORY">[<i>func</i>]<br>w32from_memory</a> (atom struct,sequence s)</h2>
<h3>Returns the fields of a structure.</h3>
<h3>Returns: (SEQUENCE) List of field values.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> If a field is itself a structure, its address is returned. If you need actual data, use <a href="MEMORY_MANAGEMENT.htm#W32FROM_MEMORYEX">w32from_memoryEx</a>(),
which this function wraps.
No values are returned for filler fields: Align, AlignRel and ByteFill.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32FROM_MEMORYEX">[<i>func</i>]<br>w32from_memoryEx</a> (atom struct,sequence s,integer level)</h2>
<h3>Returns the fields of a structure.</h3>
<h3>Returns: (SEQUENCE) List of field values.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> If a field is itself a structure, its address is returned if <em>level</em> is 0.
 Use a positive value in <em>level</em> to define a maximum degree of recursion. Use -1 to resolve
at any depth (ie replacing an embedded structure address by a list of field values).
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32HANDLE_TO_MEMORY">[<i>func</i>]<br>w32handle_to_memory</a> (atom handle)</h2>
<h3>Gives current task exclusive access to the referenced memory block.</h3>
<h3>Returns: (ATOM) Pointer to memory block.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> The handle must have been acquired using w32acquire_handle(). <br>
Writing data outside of the referenced memory block will very likely crash your application.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32LLSETABORT">[<i>func</i>]<br>w32llSetAbort</a> ( i )</h2>
<h3>Possibly sets the routine id of an Abort routine.</h3>
<h3>Returns: The previous value set.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p><p>
Used to indicate if an error routine needs to be
called in the event of a catastophic error.
The error routine is assumed to be a procedure
that accepts a single sequence (typically an
 message string). <br>
Use -1 to remove the handler. Use any sequence to simply return the handler.
<p>
Example:
<p>
<pre>
integer RtnID, OldID
RtnID = routine_id("abortErr")
OldID = w32llSetAbort(RtnID)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32MANAGE_MEM">[<i>func</i>]<br>w32manage_mem</a> ( atom Owner, object Address)</h2>
<h3>Records an acquired memory for garbage collection.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> Normally this is handled automatically by <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>() but if you
are expected to manage some memory acquired by another means, such as
a Windows call or a 'C' routine, you can use this to record the memory for
 subsequent release by <a href="MEMORY_MANAGEMENT.htm#W32RELEASE_MEM">w32release_mem</a>(). If Address is a sequence, it is a sequence of addresses to manage.
<p>
Example:
<pre>
atom mset, pt, pstr
<p>
-- Establish a new memory set.
 mset = <a href="MEMORY_MANAGEMENT.htm#W32NEW_MEMSET">w32new_memset</a>()
-- calls a routine which returns a structure address.
pt = c_func( xyz, {abc})
-- register this memory
w32manage_mem(mset, pt)
. . .
give all the memory area in 'mset' back
w32release_mem(mset)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32NEW_MEMSET">[<i>func</i>]<br>w32new_memset</a> ( )</h2>
<h3>Allocates a unique id for a memory set.</h3>
<h3>Returns: ATOM: An id for a new memory set (memset).</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>A memset id is actually a machine address of a 4-bytes location. You can
 use this 4-byte area for anything you like, until you call <a href="MEMORY_MANAGEMENT.htm#W32RELEASE_MEM">w32release_mem</a>()
<p>
Example:
<p>
<pre>
      atom ss
<p>
		ss = w32new_memset()
      b = w32acquire_mem(ss, "All you need is love")
		...
      w32release_mem( ss )  -- Let go of set 'ss'
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32PEEK2">[<i>func</i>]<br>w32peek2</a> (object pos)</h2>
<h3>Retrieves a sequence of double byte encoded characters as a regular sequence</h3>
<h3>Returns: (OBJECT) A sequence where each element represents two contiguous bytes, lowest weight at lowest address.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> If pos is a {address,length} sequence, a sequence is returned. If <em>pos</em> is a
single atom, the 16-bit word at that address is returned.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32PEEK_STRING">[<i>func</i>]<br>w32peek_string</a> ( address )</h2>
<h3>Get sequence from address holding C-style string.</h3>
<h3>Returns: SEQUENCE: containing the C-style string.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> This is typically done automatically by the <a href="#FETCH">fetch</a>
function. Note that this will not work with UTF-16 encoded strings.
<p>
Example:
<p>
<pre>
      -- get a C-string from address
      sequence s
<p>
       s = <a href="MEMORY_MANAGEMENT.htm#W32PEEK_STRING">w32peek_string</a>( address )
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32PEEK_STRING16">[<i>func</i>]<br>w32peek_string16</a> (atom addr)</h2>
<h3> Returns a 0000 terminated DBCS encoded string starting at <em>addr</em>.</h3>
<h3>Returns: (SEQUENCE) A sequence of integers, all of them in the 0-65535 range.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p><p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32POKE_WORD">[<i>proc</i>]<br>w32poke_words</a> (atom at,object words)</h2>
<h3> Poke one or more words at <em>at</em>.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>words</em> is either a single word or a sequence of them. All low words are then stored.
 The caller is responsible to poke into memory s/he owns. 
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32REALISE">[<i>func</i>]<br>w32realise</a> (atom struct,integer flag)</h2>
<h3>Rebuilds a contiguous memory structure, possibly discarding virtual info</h3>
<h3>Returns: (SEQUENCE) {Address of rebuilt structure,size of the structure}.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>If you ever used w32store() on a variable length field in a structure, the targeted
member was most likely relocated. Since external code expects the structure to
occupy a contiguous space in memory, you have to call w32realise() to get the
address of a structure with the same data, but made   contiguous again.
 <em>struct</em> is the address of the structure to rebuild;
 <em>memset</em> is a memory set where to rebuild the structure;
 <em>flag</em> is zero if you don't plan to reuse the structure again, so that the old
one and the support data are recycled.
As always, you are responsible for freeing the returned structure.
Note that, if the structure has Align fields, the created structure will use a slightly oversize
memory block. The amount of slack past the end of the structure is not greater than the sum of
the widths of the Align fields minus their number - usually only a few bytes.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32RELEASE_HANDLE">[<i>proc</i>]<br>w32release_handle</a> (atom handle,integer flag)</h2>
<h3>Releases the referenced memory block, and optionally frees it.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>flag</em> is 0 to keep the handle, and nonzero to free it. <br>
 The handle must have been acquired using <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_HANDLE">w32acquire_handle</a>(). <br>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32RELEASE_MEM">[<i>proc</i>]<br>w32release_mem</a> ( atom structure )</h2>
<h3> Returns the memory allocated by <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>() back to the system.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> If <em>structure</em> is a memory set id, as returned by <a href="MEMORY_MANAGEMENT.htm#W32NEW_MEMSET">w32new_memset</a>(), then
all the memory owned in the memory set is returned and the memory set id
 is released. That is, it cannot be reused. <br>
 If <em>structure</em> is a memory address returned by <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>(), then just
that memory is released. The memory set it belonged to is still usable.
<p>
Example:
<pre>
atom mset, pt, pstr
<p>
-- Establish a new memory set.
 mset = <a href="MEMORY_MANAGEMENT.htm#W32NEW_MEMSET">w32new_memset</a>()
-- get enough memory to hold a UInt datatype
 xy = <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>( UInt )
-- allocate a point structure
 pt = <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>( mset, SIZEOF_POINT )
-- copy a Euphoria string to a 'C' string area.
 pstr = <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>( mset, "My String Data" )
. . .
give all the memory area in 'mset' back
w32release_mem(mset)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32SET_MEMORY">[<i>proc</i>]<br>w32set_memory</a> (atom struct,sequence id,sequence data)</h2>
<h3> Performs the same function as <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORY">w32to_memory</a>(), but stores data at address <em>struct</em>.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> No realisation is attempted at <em>addr</em>.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32SPECIALISE">[<i>func</i>]<br>w32specialise</a> (sequence union,object variant)</h2>
<h3>Returns a structure field descriptor that can be translated into an actual variant of a union.</h3>
<h3>Returns: (SEQUENCE) A field descriptor.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>union</em> is a field descriptor whose is of an union type. The point of w32specialise() is
 to give <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>() a hint about what exactly is to be stored there. <br>
 <em>variant</em> is either a field descriptor or a number. If a field descriptor, it must
 appear in the list of fields that <em>union</em> can have. If a number, it is the index of the
field to choose among those defining the union.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32STORE">[<i>proc</i>]<br>w32store</a> ( structure, field, value )</h2>
<h3>Store a value into a structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> Type conversion is automatic. For example, if an <strong>Lpsz</strong> field is
used, the value is automatically converted from a sequence to a
C-style string, and the address of that string is stored in the
 structure. <br>
 If <em>field</em> is a union, it must be specialised, so that w32store() knows how to store <em>data</em>.
If it is not, then the last known specialisation is used. Otherwise, you should call
 <a href="MEMORY_MANAGEMENT.htm#W32SPECIALISE">w32specialise</a>() so as to get a specialised union which w32store() can handle.
<p>
Special rules apply to the asBuffer and usBuffer types. Normally, you'd store a string
in such a field. However:
 <li> Using an atom stores the values 0 and 0;
 <li> Storing a pair {{},{u,v}}, where u and v are atoms, store these values without any
 reference to a string.  <br>
Example:
<p>
<pre>
      -- allocate RECT structure, and populate it
      atom rect
<p>
      -- allocate the structure
       rect = <a href="MEMORY_MANAGEMENT.htm#W32ACQUIRE_MEM">w32acquire_mem</a>(w32new_memset(), SIZEOF_RECT )
<p>
      -- store values into the structure
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, rectLeft,   x1 )
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, rectTop,    y1 )
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, rectRight,  x2 )
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, rectBottom, y2 )
<p>
       -- Here we store individual elements to an <a href="MEMORY_MANAGEMENT.htm#W32ALLOT">w32allot</a> array.
      constant bCoords = w32allot( {4, Long} )
      . . .
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, bCoords & 1, Col)
       <a href="MEMORY_MANAGEMENT.htm#W32STORE">w32store</a>( rect, bCoords & 2, Row)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32TO_MEMORY">[<i>func</i>]<br>w32to_memory</a> (sequence id,sequence data)</h2>
<h3>Initialises memory structiure of given type with supplied data.</h3>
<h3>Returns: (ATOM) Address of initialised structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>id</em> is a structure identifier, <em>data</em> is a sequence of field contents.
 If there are variable length/position members, use <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORYEX">w32to_memoryEx</a>() instead. <br>
 If supplied <em>data</em> is shorter than expected, trailing zeroes are automatically stored in
 the corresponding fields. <br>
This function supersedes most of the struct_XXX() functions, at least those which don't
process their arguments.
When structures start with the structure size, this value is automatically prepended to
 <em>data</em>, so that you need not bother with it.
Align, ByteFill and AlignRel fields are ignored, you should not to supply filler values.
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32TO_MEMORYEX">[<i>func</i>]<br>w32to_memoryEx</a> (atom mem,sequence id,sequence data,integer flag)</h2>
<h3>Initialises memory structiure of given type with supplied data.</h3>
<h3>Returns: (ATOM) Address of initialised structure.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p> <em>mem</em> is the memory set to allocate from, <em>id</em> is a structure identifier, <em>data</em> is a sequence of field contents.
 If <em>flag</em> is zero, a realised structure (see <a href="MEMORY_MANAGEMENT.htm#W32REALISE">w32realise</a>()) will be created, otherwise,
a virtual structure addresss will be returned. The flag is ignored if there are no
 variable length/position members. <a href="MEMORY_MANAGEMENT.htm#W32TO_MEMORY">w32to_memory</a>() wraps this function with <em>flag</em>=0. <br>
 If supplied <em>data</em> is shorter than expected, trailing zeroes are automatically stored in
 the corresponding fields. <br>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32USINGSAFECODE">w32UsingSafeCode</a>
<hr>
<h4>Documentation for Win32lib v0.70.18<br>
<a href="index.htm#makedocTOC">Table of Contents</a></h4>
<h2><a name="W32USINGSAFECODE">[<i>Var</i>]<br>w32UsingSafeCode</a> </h2>
<h3>Determines whether or not the 'safe' versions of peek and poke are used.</h3>
Category: <a href="#MEMORY_MANAGEMENT">Memory management</a><br>
<p><p>This is primarily as debugging aid. You only need to set this if you suspect
that your program is causing memory corruptions or accessing strange locations.
<p>
Set this to zero to turn off the safe versions..
<p>
The initial setting is 0. That is, the safe versions are not being used.
<p>
Example:
<pre>
     --Ensure I can change RAM safely
     w32UsingSafeCode = 1
     l_SafePoke4( adr, 0)
</pre>
<p>See Also: 
<a href="#ISFIELDOF">isFieldOf</a>,
<a href="#SETPREPROCESSDATAIN">setPreProcessDataIn</a>,
<a href="#SETSTARTWITHSIZE">setStartWithSize</a>,
<a href="#W32ACQUIRE_HANDLE">w32acquire_handle</a>,
<a href="#W32ACQUIRE_MEM">w32acquire_mem</a>,
<a href="#W32ADDRES">w32address</a>,
<a href="#W32ALLOT">w32allot</a>,
<a href="#W32ALLOTTED_BUFFER">w32allotted_buffer</a>,
<a href="#W32ALLOTTED_HANDLE">w32allotted_handle</a>,
<a href="#W32ALLOTTED_LENGTH">w32allotted_length</a>,
<a href="#W32ALLOTTED_SIZE">w32allotted_size</a>,
<a href="#W32ALLOTTED_SOFAR">w32allotted_sofar</a>,
<a href="#W32BUFFER_ADDRES">w32buffer_address</a>,
<a href="#W32BUFFER_LENGTH">w32buffer_length</a>,
<a href="#W32COPY_FIELD">w32copy_field</a>,
<a href="#W32COPY_STRUCT">w32copy_struct</a>,
<a href="#W32DEFINE_THIS_STRUCT">w32define_this_struct</a>,
<a href="#W32DEFINE_UNION">w32define_union</a>,
<a href="#W32FETCH">w32fetch</a>,
<a href="#W32FROM_MEMORY">w32from_memory</a>,
<a href="#W32FROM_MEMORYEX">w32from_memoryEx</a>,
<a href="#W32HANDLE_TO_MEMORY">w32handle_to_memory</a>,
<a href="#W32LLSETABORT">w32llSetAbort</a>,
<a href="#W32MANAGE_MEM">w32manage_mem</a>,
<a href="#W32NEW_MEMSET">w32new_memset</a>,
<a href="#W32PEEK2">w32peek2</a>,
<a href="#W32PEEK_STRING">w32peek_string</a>,
<a href="#W32PEEK_STRING16">w32peek_string16</a>,
<a href="#W32POKE_WORD">w32poke_words</a>,
<a href="#W32REALISE">w32realise</a>,
<a href="#W32RELEASE_HANDLE">w32release_handle</a>,
<a href="#W32RELEASE_MEM">w32release_mem</a>,
<a href="#W32SET_MEMORY">w32set_memory</a>,
<a href="#W32SPECIALISE">w32specialise</a>,
<a href="#W32STORE">w32store</a>,
<a href="#W32TO_MEMORY">w32to_memory</a>,
<a href="#W32TO_MEMORYEX">w32to_memoryEx</a>
<hr>
